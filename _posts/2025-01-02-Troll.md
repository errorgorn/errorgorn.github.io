---
tags: cp
---

## How to Troll Competitive Programmers

When doing lazy propagation in segment tree, people usually have a function to propagate values inside a node.

When I learnt lazy propagation, I did not use reference code and just coded it myself. I apparently did not know how to spell, so I named my function `propo`. This is how I managed to troll an many Singaporean CPers into spelling propagation as propogation. Even know as I am typing this blog, I still default to writing propogate... I will try to spell it correctly in this blog.

The earliest record I have of the `propo` thing being public is in the [dec course 2020 lecture notes on DS III](https://drive.google.com/drive/folders/1H2Cyp9155XR_XQwB3RFjbF6kFPTbisS5). If my memory serves me right, it was Rui Yuan and I who were preparing this lecture and I was the one who wrote the code with `propogate` as function names and as comments. I also distinctly remember coding lazy propagation during an online lecture. I definitely spelled propagation wrongly there as well.

Now, 4 years later. I realized that many people were actually spelling propagation wrongly as well. How many people exactly?

To test this, I decided to check people's submission on [Segment Tree 2](https://codebreaker.xyz/problem/segmenttree2) on codebreaker. This is what the top 20 people on codebreaker named their propagate function. Note that I only checked their first AC submission.

| Username             | Name of Function | Year | O/A  |
| -------------------- | ---------------- | ---- | ---- |
| PlayVoltz            | propagate        | 2023 | A    |
| Pan                  | propogate        | 2023 | O    |
| TheRaptor            | propogate        | 2021 | O    |
| penguin133           | propo            | 2020 | O    |
| LCJLY                | lazy_propagate   | 2022 | A    |
| ryangohca            | value            | 2020 |      |
| syy                  | value            | 2020 |      |
| AlphanumericUsername | lazy_propagate   | 2022 | A    |
| bribritt             | notlazy          | 2022 |      |
| errorgorn            | propo            | 2020 | O    |
| shoryu386            | lazy_propagate   | 2022 | A    |
| chenweilian          | -                | 2022 |      |
| blackscreen1         | propogate        | 2021 | O    |
| siewjh               | propo            | 2021 | O    |
| hmm                  | value            | 2021 |      |
| mofumofu             | prop             | 2021 |      |
| Sans12345            | forceProp        | 2022 |      |
| dsyz                 | propagate        | 2020 | A    |
| kxd                  | subnode          | 2022 |      |

Note that chenweilian does not have a propagation function because he used a fenwick tree.

But in the top 20, we have more people spelling propagate wrongly! What about the rest of the users?

To do this, I wrote a script to scrape codebreaker (please ask the judge devs for permission before doing this).

```python
LOGIN_SESSION="google-login-session=dQw4w9WgXcQ"

headers = {'Cookie' : LOGIN_SESSION}

import requests
from bs4 import BeautifulSoup
import pandas as pd
import json
import time

def getSubIds():
	res=[]
	URL = r"https://codebreaker.xyz/submissions?problem=segmenttree2&page="
	for x in range(1,81):
		time.sleep(1)
		
		page = requests.get(URL+str(x))
		soup = BeautifulSoup(page.content, "html.parser")
		table = pd.read_html(str(soup.find(id="myTable")))[0]
		
		table = table[table["Score"]==100]
		res += table["ID"].tolist()
	return res
	
def getSubInfo(subId):
	time.sleep(1)
	print(subId)
	
	URL = r"https://codebreaker.xyz/submission/"
	page = requests.get(URL+str(subId), headers=headers)
	soup = BeautifulSoup(page.content, "html.parser")
	table = pd.read_html(str(soup.find_all("table")[0]))[0]
	
	code = soup.find_all("textarea")[0].get_text()
	
	res = {
		"username" : table.at[1,1],
		"id" : subId,
		"date" : table.at[2,1],
		"code" : code
	}
	
	return res
	
subs = getSubIds()
print("total ",len(subs))
subs = [getSubInfo(x) for x in subs]

with open('data.json', 'w', encoding='utf-8') as f:
    json.dump(subs, f, ensure_ascii=False, indent=4)
```

<details style="background-color:powderblue"><summary markdown="span">The full json</summary>
```
[
    {
        "username": "Random52",
        "id": 583101,
        "date": "2024-12-30 11:35:58",
        "code": "#include <iostream>\r\n\r\nstruct Node {\r\n    uint32_t s, e, m;\r\n    Node *l, *r;\r\n\r\n    int64_t value, lazy;\r\n\r\n    Node(const uint32_t& init_s, const uint32_t& init_e) : s(init_s), e(init_e), m((s + e) / 2), l(nullptr), r(nullptr) {\r\n        value = 0;\r\n        lazy = 0;\r\n    }\r\n\r\n\t/*\r\n    ~Node() {\r\n        if (s != e) {\r\n            l->~Node();\r\n            r->~Node();\r\n        }\r\n\r\n        delete l;\r\n        delete r;\r\n    }\r\n\t*/\r\n\r\n    int64_t combine(const int64_t& a, const int64_t& b) {\r\n        return a + b;\r\n    }\r\n\r\n    void create() {\r\n        if (s != e) {\r\n            if (l == nullptr) {\r\n                l = new Node(s, m);\r\n                r = new Node(m + 1, e);\r\n            }\r\n        }\r\n    }\r\n\r\n    void propagate() {\r\n        if (lazy) {\r\n            value += lazy * (e - s + 1);\r\n\r\n            if (s != e) {\r\n\t\t\t\tcreate();\r\n\t\t\t\t\r\n                l->lazy += lazy;\r\n                r->lazy += lazy;\r\n            }\r\n\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    void add(const uint32_t& r_s, const uint32_t& r_e, const int64_t& new_value) {\r\n        create();\r\n        propagate();\r\n\r\n        if (r_s <= s && r_e >= e) {\r\n            lazy += new_value;\r\n            propagate();\r\n\r\n            return;\r\n        }\r\n        else if (r_e <= m) {\r\n            l->add(r_s, r_e, new_value);\r\n        }\r\n        else if (r_s >= m + 1) {\r\n            r->add(r_s, r_e, new_value);\r\n        }\r\n        else {\r\n            l->add(r_s, m, new_value);\r\n            r->add(m + 1, r_e, new_value);\r\n        }\r\n\r\n        l->propagate();\r\n        r->propagate();\r\n\r\n        value = combine(l->value, r->value);\r\n    }\r\n\r\n    int64_t query(const uint32_t& r_s, const uint32_t& r_e) {\r\n        create();\r\n        propagate();\r\n\r\n        if (r_s <= s && r_e >= e) {\r\n            return value;\r\n        }\r\n        else if (r_e <= m) {\r\n            return l->query(r_s, r_e);\r\n        }\r\n        else if(r_s >= m + 1) {\r\n            return r->query(r_s, r_e);\r\n        }\r\n\r\n        return combine(l->query(r_s, m), r->query(m + 1, r_e));\r\n    }\r\n};\r\n\r\nint main() {\r\n    std::ios::sync_with_stdio(false);\r\n    std::cin.tie(nullptr);\r\n\r\n    uint32_t n, q;\r\n\r\n    std::cin >> n >> q;\r\n\r\n    uint16_t o;\r\n    uint32_t l, r;\r\n    int16_t k;\r\n    Node tree(0, n - 1);\r\n\r\n    for (uint32_t i = 0; i < q; i++) {\r\n        std::cin >> o;\r\n\r\n        switch (o) {\r\n            case 1:\r\n                std::cin >> l >> r >> k;\r\n\r\n                tree.add(l - 1, r - 1, k);\r\n\r\n                break;\r\n            case 2:\r\n                std::cin >> l >> r;\r\n                \r\n                std::cout << tree.query(l - 1, r - 1) << '\\n';\r\n\r\n                break;\r\n        }\r\n    }\r\n    \r\n    return 0;\r\n}"
    },
    {
        "username": "duck",
        "id": 581195,
        "date": "2024-12-28 10:15:12",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node {\r\n    node *left, *right;\r\n    int S, E, val, lazy;\r\n    node(int _s, int _e) : S(_s), E(_e) {\r\n        left = right = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void prop(){\r\n        if(S == E) return;\r\n        int M = (S + E) / 2;\r\n        if(left == nullptr){ // no children\r\n            left = new node(S, M);\r\n            right = new node(M + 1, E);\r\n        }\r\n        if(lazy != 0){\r\n            // need to add lazy to left and right children\r\n            left->val += lazy * (M - S + 1);\r\n            left->lazy += lazy;\r\n            right->val += lazy * (E - M);\r\n            right->lazy += lazy;\r\n            // reset lazy tag\r\n            lazy = 0;\r\n        }\r\n    }\r\n    int qry(int l, int r) { // sum from index l to index r\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return 0;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            return val;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        return left->qry(l, r) + right->qry(l, r);\r\n    }\r\n    void upd(int l, int r, int v) {\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            // update the value of the node and the lazy tag, do not recurse\r\n            val += v * (E - S + 1); // all E - S + 1 nodes has their value increased\r\n            lazy += v;\r\n            return;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        left->upd(l, r, v);\r\n        right->upd(l, r, v);\r\n        // update current node value\r\n        val = left->val + right->val;\r\n    }\r\n} *root;\r\n\r\n// range add, range sum, lazy creation lazy propagation segment tree\r\nint32_t main() {\r\n\tint n, q; cin >> n >> q;\r\n    root = new node(1, n);\r\n\tfor (int i = 0; i < q; i++) {\r\n\t\tint t; cin >> t;\r\n\t\tif (t == 2) {\r\n\t\t\tint a, b; cin >> a >> b;\r\n\t\t\tcout << root->qry(a,b) << \"\\n\";\r\n\t\t}\r\n\t\tif (t == 1) {\r\n\t\t\tint a, b, c; cin >> a >> b >> c;\r\n\t\t\troot->upd(a,b,c);\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "LiuZq",
        "id": 580710,
        "date": "2024-12-27 20:04:45",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    ll s, e, m;\r\n    ll val, lazy;\r\n    node *l, *r;\r\n\r\n    node(ll S, ll E) {\r\n        s = S, e = E, m = (s + e) / 2;\r\n        val = 0;\r\n        lazy = 0;\r\n        l = r = nullptr;\r\n    }\r\n\r\n    void propagate() {\r\n        if (lazy) {\r\n            val += lazy * (e - s + 1);\r\n            if (s != e) {\r\n                if (!l) l = new node(s, m);\r\n                if (!r) r = new node(m + 1, e);\r\n                l->lazy += lazy;\r\n                r->lazy += lazy;\r\n            }\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    void update(ll L, ll R, ll V) {\r\n        propagate();\r\n        if (L > e || R < s) return;\r\n        if (L <= s && e <= R) {\r\n            lazy += V;\r\n            propagate();\r\n            return;\r\n        }\r\n        if (!l) l = new node(s, m);\r\n        if (!r) r = new node(m + 1, e);\r\n        l->update(L, R, V);\r\n        r->update(L, R, V);\r\n        val = (l ? l->val : 0) + (r ? r->val : 0);\r\n    }\r\n\r\n    ll query(ll L, ll R) {\r\n        propagate();\r\n        if (L > e || R < s) return 0;\r\n        if (L <= s && e <= R) return val;\r\n        if (!l) l = new node(s, m);\r\n        if (!r) r = new node(m + 1, e);\r\n        return l->query(L, R) + r->query(L, R);\r\n    }\r\n};\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n\r\n    ll n, q;\r\n    cin >> n >> q;\r\n\r\n    node *root = new node(1, n);\r\n\r\n    while (q--) {\r\n        int t;\r\n        ll l, r, k;\r\n        cin >> t >> l >> r;\r\n        if (t == 1) {\r\n            cin >> k;\r\n            root->update(l, r, k);\r\n        } else {\r\n            cout << root->query(l, r) << '\\n';\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "Sans12345",
        "id": 567758,
        "date": "2024-12-12 11:25:00",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long int ll;\r\nstruct segtree_val{\r\n    ll s,e,val,lazy;\r\n};\r\nstruct segtree{\r\n\tll s, e, m;\r\n\tsegtree_val cur = segtree_val({0,0,0,0});\r\n\tsegtree *l = nullptr, *r = nullptr;\r\n\t\r\n\tsegtree(ll ss, ll ee){\r\n\t\ts = ss, e = ee;\r\n\t\tm = (s+e)/2;\r\n        cur.s = s;\r\n        cur.e = e;\r\n\t}\r\n\t\r\n\tvoid createChildren(){\r\n\t\tif (l == nullptr && s != e){\r\n\t\t\tl = new segtree(s, m);\r\n\t\t\tr = new segtree(m+1, e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid prop(){\r\n\t\tcreateChildren();\r\n\t\tif (s != e){\r\n\t\t\tl->cur.lazy += cur.lazy;\r\n\t\t\tr->cur.lazy += cur.lazy;\r\n\t\t}\r\n\t\tcur.val += (cur.lazy * (e-s+1));\r\n\t\tcur.lazy = 0;\r\n\t}\r\n    segtree_val merge(segtree_val l1,segtree_val r1){\r\n        return segtree_val({s,e,l1.val+r1.val,cur.lazy});\r\n    }\r\n\t\r\n\t//range add\r\n\tvoid update(ll qs, ll qe, ll k){\r\n\t\tcreateChildren();\r\n\t\tprop();\r\n\t\tif (qs <= s && e <= qe){\r\n\t\t\tcur.lazy += k;\r\n\t\t\tprop();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tif (qe <= m){\r\n\t\t\tl->update(qs, qe, k);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\tr->update(qs, qe, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tl->update(qs, m, k);\r\n\t\t\tr->update(m+1, qe, k);\r\n\t\t}\r\n\t\t\r\n\t\tl->prop(); r->prop();\r\n        cur = merge(l->cur,r->cur);\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t//range sum\r\n\tsegtree_val query(ll qs, ll qe){\r\n\t\tcreateChildren();\r\n\t\tprop();\r\n\t\tif (qs <= s && e <= qe){\r\n\t\t\treturn cur;\r\n\t\t}\r\n\t\t\r\n\t\tif (qe <= m){\r\n\t\t\treturn l->query(qs, qe);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\treturn r->query(qs, qe);\r\n\t\t}\r\n\t\telse{\r\n\t\t\treturn merge(l->query(qs, m),r->query(m+1, qe));\r\n\t\t}\r\n\t}\r\n};\r\n\r\nsigned main(){\r\n\t\r\n\tint n, q; cin >> n >> q;\r\n\tsegtree st(0, n-1); //create segment tree with start index 0, end index n-1\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint t; cin >> t;\r\n\t\t\r\n\t\tif (t == 1){\r\n\t\t\t//update\r\n\t\t\tint l, r, k;\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\tl--; r--; //convert to 0-index\r\n\t\t\tst.update(l, r, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\t//query\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tl--; r--; //convert to 0-index\r\n\t\t\tcout << st.query(l, r).val << '\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "justin271828",
        "id": 565205,
        "date": "2024-12-10 21:41:32",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node {\r\n\tint s, e, m, val, lazy;\r\n\tnode *l, *r;\r\n\tnode (int S, int E) :\r\n\t\ts(S), e(E), m((S+E)/2), val(0), lazy(0) {\r\n\t\t\tl = nullptr;\r\n\t\t\tr = nullptr;}\r\n\tvoid prop() {\r\n\t\tif (l == nullptr) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);}\r\n\t\tl->val += lazy*(m-s+1);\r\n\t\tl->lazy += lazy;\r\n\t\tr->val += lazy*(e-m);\r\n\t\tr->lazy += lazy;\r\n\t\tlazy = 0;}\r\n\tvoid up(int x, int y, int k) {\r\n\t\tif (x > e || y < s) return;\r\n\t\tif (x <= s && e <= y) {\r\n\t\t\tlazy += k;\r\n\t\t\tval += k*(e-s+1);\r\n\t\t\treturn;}\r\n\t\tprop();\r\n\t\tl->up(x, y, k);\r\n\t\tr->up(x, y, k);\r\n\t\tval = l->val + r->val;}\r\n\tint q(int x, int y) {\r\n\t\tif (x > e || y < s) return 0;\r\n\t\tif (x <= s && e <= y) {return val;}\r\n\t\tprop();\r\n\t\treturn l->q(x, y) + r->q(x, y);}}*root;\r\n\r\nsigned main() {\r\n\tint N, Q;\r\n\tcin >> N >> Q;\r\n\troot = new node(1, N);\r\n\tint a, l, r, k;\r\n\tfor (int count = 0; count < Q; count++) {\r\n\t\tcin >> a;\r\n\t\tif (a == 1) {\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\troot->up(l, r, k);}\r\n\t\telse {\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->q(l, r) << \"\\n\";}}\r\n\treturn 0;}"
    },
    {
        "username": "FIips",
        "id": 565097,
        "date": "2024-12-10 20:30:08",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define debug(x) cerr << #x << \" = \" << x << '\\n'\r\nconst int inf = LLONG_MAX / 20;\r\n\r\nstruct node {\r\n    node *l, *r;\r\n    int s, e, m, val, lazy;\r\n    \r\n    node(int s_, int e_) : s(s_), e(e_), lazy(0) {\r\n        lazy = 0; val = 0;\r\n        l = r = nullptr;\r\n    }\r\n    \r\n    void prop() { \r\n        if(s == e) return;\r\n        m = (s + e) / 2;\r\n        \r\n        if(l == nullptr) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m + 1, e);\r\n\t\t}\r\n        \r\n        if(lazy != 0) {\r\n\t\t\tl -> val += (m - s + 1) * lazy; \r\n\t\t\tl -> lazy += lazy;\r\n\t\t\tr -> val += (e - m) * lazy;\r\n\t\t\tr -> lazy += lazy;\r\n\t\t\t\r\n\t\t\tlazy = 0;\r\n\t\t}\r\n    }\r\n    \r\n    int qry(int left, int right) { \r\n        if(left > e || right < s) return 0; \r\n        if(left <= s && e <= right) return val; \r\n        \r\n        prop(); \r\n        return l -> qry(left, right) + r -> qry(left, right);\r\n    }\r\n    \r\n    void update(int left, int right, int v) {\r\n        if(left > e || right < s) {\r\n            return;\r\n        }\r\n        \r\n        if(left <= s && e <= right) { \r\n            val += v * (e - s + 1); \r\n            lazy += v;\r\n            \r\n            return;\r\n        }\r\n\r\n        prop();\r\n\r\n        l -> update(left, right, v);\r\n        r -> update(left, right, v);\r\n        val = l -> val + r -> val;\r\n    }\r\n};\r\n\r\nint32_t  main() {\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\t\r\n\tint n, q;\r\n\tcin >> n >> q;\r\n\tnode lazytree(0, n - 1);\r\n\t\r\n\tfor(int i = 0; i < q; i++) {\r\n\t\tint t;\r\n\t\tcin >> t;\r\n\t\t\r\n\t\tif(t == 1) {\r\n\t\t\tint l, r, v;\r\n\t\t\tcin >> l >> r >> v;\r\n\t\t\t\r\n\t\t\tlazytree.update(l - 1, r - 1, v);\r\n\t\t} else {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\t\r\n\t\t\tcout << lazytree.qry(l - 1, r - 1) << '\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "vs358",
        "id": 564827,
        "date": "2024-12-10 15:28:14",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define ull unsigned long long\r\n#define ld long double\r\n#define INFF 300000\r\n#define INF (LLONG_MAX - 100)\r\n#define mp make_pair\r\n#define DEBUG(x) cout << \"DEBUG: \" << x << endl;\r\n#define drugs ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\r\n\r\ntypedef pair<int, int> pi;\r\ntypedef pair<int, pi> ipi;\r\ntypedef pair<pi, int> pii;\r\n\r\n\r\nstruct node{\r\n    int s, e, m;\r\n    int val, lazy;\r\n    node *l, *r;\r\n\r\n    node(int S, int E){\r\n        s = S, e = E;\r\n        m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n        l = nullptr;\r\n        r = nullptr;\r\n    }\r\n\r\n    void prop(){\r\n        if(s == e) return;\r\n        if(l == nullptr){\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n        l->val += lazy*((m-s)+1);\r\n        l->lazy += lazy;\r\n        r->val += lazy*((e-(m+1))+1);\r\n        r->lazy += lazy;\r\n        lazy = 0;\r\n    }\r\n\r\n    void upd(int S, int E, int V){\r\n       // cout << \"AT NODE: \" << s << \", \" << e << endl;\r\n        if(S > e or E < s) return;\r\n        if(s >= S and e <= E){\r\n           // cout << \"Updating val by \" << (e-s+1)*V << endl;\r\n            val += (e-s+1)*V;\r\n            lazy += V;\r\n            return;\r\n        }\r\n        prop();\r\n        l->upd(S, E, V);\r\n        r->upd(S, E, V);\r\n        val = l->val + r->val;\r\n    }\r\n\r\n    int qry(int S, int E){\r\n        //cout << \"AT NODE: \" << s << \", \" << e << endl;\r\n        if(S > e or E < s) return 0;\r\n        if(S <= s and e <= E) return val;\r\n        prop();\r\n        \r\n        return l->qry(S, E) + r->qry(S, E);\r\n        \r\n    }\r\n\r\n} *root;\r\n\r\nsigned main(){\r\n    drugs;\r\n    \r\n    int n, q;\r\n    cin >> n >> q;\r\n    root = new node(1, 1e9);\r\n    \r\n    for(int i = 0; i < q; i++){\r\n        int typ;\r\n        cin >> typ;\r\n        if(typ == 1){\r\n            int x, y, z;\r\n            cin >> x >> y >> z;\r\n            root->upd(x, y, z);\r\n        } else {\r\n            int x, y;\r\n            cin >> x >> y;\r\n            cout << root->qry(x, y) << '\\n';\r\n        }\r\n    \r\n        \r\n    }\r\n    \r\n}"
    },
    {
        "username": "Henries",
        "id": 564425,
        "date": "2024-12-10 00:04:40",
        "code": "\r\n\t\t\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node{\r\n\tnode *left,*right;\r\n\tlong long S,E,M,val;\r\n\tlong long lazy;\r\n\tnode (long long s,long long e):S(s), E(e){\r\n\t\tval = 0;\r\n\t\tleft = nullptr;\r\n\t\tright = nullptr;\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid prop(){\r\n\t\tif (S == E){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tM = (S + E) / 2;\r\n\t\tif (left == nullptr){\r\n\t\t\tleft = new node(S,M);\r\n\t\t\tright = new node(M+1,E);\r\n\t\t}\r\n\t\tif (lazy != 0){\r\n\t\t\tleft->val += lazy*(M-S+1);\r\n\t\t\tright->val += lazy*(E-M);\r\n\t\t\tright->lazy += lazy;\r\n\t\t\tleft->lazy += lazy;\r\n\t\t\tlazy = 0;\r\n\t\t}\r\n\t}\r\n\tlong long qry(long long l,long long r){\r\n\t\tif (l > E || r < S){\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\telse if (l <= S && r >= E){\r\n\t\t\treturn val;\r\n\t\t}\r\n\t\tprop();\r\n\t\treturn left->qry(l,r) + right->qry(l,r);\r\n\t}\r\n\tvoid upd(long long l,long long r,long long v){\r\n\t\tif (l > E || r < S){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (l <= S && E <= r){\r\n\t\t\tval += v * (E - S + 1);\r\n\t\t\tlazy += v;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tprop();\r\n\t\tleft->upd(l,r,v);\r\n\t\tright->upd(l,r,v);\r\n\t\tval = left->val + right->val;\r\n\t}\r\n}*segtree;\r\nint main(){\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\tlong long n,k;cin >> n >> k;\r\n\r\n\tsegtree = new node(0,n-1);\r\n\twhile (k--){\r\n\t\tlong long t;cin >> t;\r\n\t\tif (t == 1){\r\n\t\t\tlong long l,r,k;cin >> l >> r >> k;\r\n\t\t\tl--;\r\n\t\t\tr--;\r\n\t\t\tsegtree->upd(l,r,k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tlong long l,r;cin >> l >> r;\r\n\t\t\tl--;\r\n\t\t\tr--;\r\n\t\t\tlong long ans = segtree->qry(l,r);\r\n\t\t\tcout << ans << '\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "popperoni",
        "id": 564261,
        "date": "2024-12-09 21:51:33",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll long long\r\n#define ull unsigned long long\r\n#define pll pair<ll,ll>\r\n#define pqll priority_queue<ll>\r\n#define pqpll priority_queue<pll>\r\n#define pqllg priority_queue<ll, vector<ll>, greater<ll>>\r\n#define pqpllg priority_queue<pll, vector<pll>, greater<pll>>\r\n#define inf LLONG_MAX\r\n#define vll vector<ll>\r\n#define vqll vector<queue<ll>>\r\n#define qll queue<ll>\r\n#define stll stack<ll>\r\n#define se second\r\n#define fi first\r\n#define umll unordered_map<ll, ll>\r\n#define pb push_back\r\n#define pu push\r\n#define front fr\r\n\r\n\r\nstruct node {\r\n\tll S, E, val, lazy; \r\n\tnode *l, *r;\r\n\tnode (ll s, ll e) {\r\n\t\tS = s;\r\n\t\tE = e;\r\n\t\tval = 0;lazy=0;\r\n\t\tif (S==E) return;\r\n\t\tl = nullptr;\r\n\t\tr = nullptr;\r\n\t}\r\n\tvoid up(ll le, ll ri, ll v) {\r\n\t\tif(le>E||ri<S) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(le<=S&&E<=ri){\r\n\t\t\tval += v*(E-S+1);\r\n            lazy += v;\r\n            return;\r\n\t\t}\r\n\t\tprop();\r\n\t\tl->up(le,ri,v);\r\n\t\tr->up(le,ri,v);\r\n\t\tval = l->val+r->val;\r\n\t}\r\n\tvoid prop(){\r\n\t\tif(S==E)return;\r\n\t\tll M=(S+E)/2;\r\n\t\tif(l==nullptr){\r\n\t\t\tl=new node(S,M);\r\n\t\t\tr=new node(M+1,E);\r\n\t\t}\r\n\t\tif(lazy==0)return;\r\n\t\tl->val+=lazy*(M-S+1);\r\n\t\tl->lazy+=lazy;\r\n\t\tr->val+=lazy*(E-M);\r\n\t\tr->lazy+=lazy;\r\n\t\tlazy=0;\r\n\t}\r\n\tll qry(ll x,ll y) {\r\n\t\tif (E < x or S > y) return 0;\r\n\t\tif (x<=S and E<=y) return val;\r\n\t\tprop();\r\n\t\treturn l->qry(x, y)+r->qry(x,y);\r\n\t}\r\n};\r\n\r\n \r\nint main() {\r\n    ios_base::sync_with_stdio(0); \r\n    cin.tie(0); \r\n    cout.tie(0);\r\n    ll n,q;cin>>n>>q;\r\n    node *root=new node(1,n);\r\n    while(q--){\r\n\t\tll a;cin>>a;\r\n\t\tif(a==1){\r\n\t\t\tll b,c;cin>>a>>b>>c;\r\n\t\t\troot->up(a,b,c);\r\n\t\t}else{\r\n\t\t\tll b;cin>>a>>b;\r\n\t\t\tcout<<root->qry(a,b)<<endl;\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "wrizz69",
        "id": 563732,
        "date": "2024-12-09 15:21:32",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define f first\r\n#define s second\r\n#define p push\r\n#define pb push_back\r\n#define fastt ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\r\n\r\nstruct node{\r\n    int s, e, m; //range is [s,e], m is the middle point \r\n    int val; //sum of [s,e]\r\n    int lazy;\r\n    node *l, *r; \r\n    \r\n    node (int S, int E){\r\n    s = S, e = E, m = (s+e)/2;\r\n    val = 0; \r\n    lazy = 0;\r\n    //DONT CREATE CHILDREN YET!\r\n    }\r\n    \r\n    void create() {\r\n        if(s != e){//node is not yet a leaf, so create two children\r\n            l = new node(s, m); //create left child\r\n            r = new node (m+1, e); //create right child\r\n        }\r\n    }\r\n    \r\n    void propagate() { \r\n        if (lazy == 0) return; //do nothing\r\n        val += lazy * (e - s + 1); //size of segment\r\n        if (s!=e) { \r\n            if(l == nullptr) create();\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n    \r\n    void update(int S, int E, int V){ //add V to all S~E\r\n        if (s == S && e == E) lazy += V; //node is leaf\r\n        else{ //go down to find the leaf\r\n            if(l == nullptr) create(); \r\n            if (E <= m) l->update(S, E, V); \r\n            else if(S >= m+1) r->update(S, E, V);\r\n            else l->update(S, m, V), r->update(m+1, E, V); \r\n            \r\n            l->propagate(); r->propagate(); //remember to propogate your children before update yourself\r\n            val = l->val + r->val; //update the range sum\r\n        }\r\n    }\r\n\r\n    int query (int S, int E){ \r\n        if(l == nullptr) create(); //lazily create children\r\n        propagate();\r\n        if (s == S && e == E) return val; \r\n        else if (E <= m) return l->query(S, E); \r\n        else if(S >= m+1) return r->query(S, E); \r\n        else return l->query(S, m) + r->query(m+1, E); \r\n    }\r\n} *root;\r\n\r\nint32_t main() {\r\n    fastt\r\n    int n, q; cin >> n >> q;\r\n    root = new node(0, n);\r\n\r\n    for(int i = 0;i < q;i++) {\r\n        int x; cin >> x;\r\n\r\n        if(x == 1) {\r\n            //query\r\n            int y,z,q; cin >> y >> z >> q;\r\n            root -> update(y,z,q);\r\n        }\r\n        else {\r\n            int y,z; cin >> y >> z;\r\n            cout << root -> query(y,z) << \"\\n\";\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "jmuzhen",
        "id": 563687,
        "date": "2024-12-09 15:07:42",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n\r\n    node(int _s, int _e, int A[] = nullptr) : s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0),\r\n                                              l(nullptr), r(nullptr) {\r\n        if (A == nullptr) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s + e) >> 1, A), r = new node((s + e + 2) >> 1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != nullptr) return;\r\n        int m = (s + e) >> 1;\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n    }\r\n\r\n    void self_set(ll v) {\r\n        lset = true;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e - s + 1);\r\n        add_val = 0;\r\n    }\r\n\r\n    void self_add(ll v) {\r\n        if (lset) {\r\n            self_set(v + set_val);\r\n            return;\r\n        }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v * (e - s + 1);\r\n    }\r\n\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }\r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n\r\n    void combine() {\r\n        if (l == nullptr) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) {\r\n            self_add(v);\r\n            return;\r\n        }\r\n        int m = (s + e) >> 1;\r\n        create_children();\r\n        lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m + 1), y, v);\r\n        combine();\r\n    }\r\n\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) {\r\n            self_set(v);\r\n            return;\r\n        }\r\n        int m = (s + e) >> 1;\r\n        create_children();\r\n        lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m + 1), y, v);\r\n        combine();\r\n    }\r\n\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == nullptr || lset) return (sum / (e - s + 1)) * (y - x + 1);\r\n        int m = (s + e) >> 1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m + 1, y);\r\n    }\r\n\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == nullptr || lset) return mn;\r\n        int m = (s + e) >> 1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m + 1, y));\r\n    }\r\n\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == nullptr || lset) return mx;\r\n        int m = (s + e) >> 1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m + 1, y));\r\n    }\r\n\r\n    ~node() {\r\n        // note: deleting nullptr has no effect\r\n        delete l;\r\n        delete r;\r\n    }\r\n}*root;\r\n\r\n\r\nint main() {\r\n    int n; cin >> n;\r\n    root = new node(0, n);\r\n    int q; cin >> q;\r\n    while (q--) {\r\n        int t; cin >> t;\r\n        if (t == 2) {\r\n            int x, y; cin >> x >> y;\r\n            cout << root->range_sum(x, y) << '\\n';\r\n        }\r\n        else {\r\n            int x, y, z; cin >> x >> y >> z;\r\n            root -> add(x, y, z);\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "YSH2020",
        "id": 563685,
        "date": "2024-12-09 15:07:19",
        "code": "\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n\r\n    node(int _s, int _e, int A[] = nullptr) : s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0),\r\n                                              l(nullptr), r(nullptr) {\r\n        if (A == nullptr) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s + e) >> 1, A), r = new node((s + e + 2) >> 1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != nullptr) return;\r\n        int m = (s + e) >> 1;\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n    }\r\n\r\n    void self_set(ll v) {\r\n        lset = true;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e - s + 1);\r\n        add_val = 0;\r\n    }\r\n\r\n    void self_add(ll v) {\r\n        if (lset) {\r\n            self_set(v + set_val);\r\n            return;\r\n        }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v * (e - s + 1);\r\n    }\r\n\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }\r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n\r\n    void combine() {\r\n        if (l == nullptr) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) {\r\n            self_add(v);\r\n            return;\r\n        }\r\n        int m = (s + e) >> 1;\r\n        create_children();\r\n        lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m + 1), y, v);\r\n        combine();\r\n    }\r\n\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) {\r\n            self_set(v);\r\n            return;\r\n        }\r\n        int m = (s + e) >> 1;\r\n        create_children();\r\n        lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m + 1), y, v);\r\n        combine();\r\n    }\r\n\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == nullptr || lset) return (sum / (e - s + 1)) * (y - x + 1);\r\n        int m = (s + e) >> 1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m + 1, y);\r\n    }\r\n\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == nullptr || lset) return mn;\r\n        int m = (s + e) >> 1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m + 1, y));\r\n    }\r\n\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == nullptr || lset) return mx;\r\n        int m = (s + e) >> 1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m + 1, y));\r\n    }\r\n\r\n    ~node() {\r\n        // note: deleting nullptr has no effect\r\n        delete l;\r\n        delete r;\r\n    }\r\n}*root;\r\n\r\n\r\nint main() {\r\n    int n; cin >> n;\r\n    root = new node(0, n);\r\n    int q; cin >> q;\r\n    while (q--) {\r\n        int t; cin >> t;\r\n        if (t == 2) {\r\n            int x, y; cin >> x >> y;\r\n            cout << root->range_sum(x, y) << '\\n';\r\n        }\r\n        else {\r\n            int x, y, z; cin >> x >> y >> z;\r\n            root -> add(x, y, z);\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "nguyendinhanh1508",
        "id": 563395,
        "date": "2024-12-09 14:17:48",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define mx 200007\r\n#define inf LLONG_MAX/20\r\n#define pi pair<int, int>\r\n#define mp make_pair\r\n\r\nstruct node{\r\n\tnode *l = nullptr, *r = nullptr;\r\n\tint s, e, m;\r\n\t\r\n\t//lazy creation (segment tree can support range of 10^18)\r\n\t//root s = 0, e = 10^18\r\n\tint val, lazy; //lazy propagation (pass down)\r\n\t\r\n\tnode(int _s, int _e){\r\n\t\ts = _s;\r\n\t\te = _e;\r\n\t\t\r\n\t\tm = (s+e)/2;\r\n\t\tlazy = 0;\r\n\t\tval = 0;\r\n\t}\r\n\t\r\n\tvoid create(){\r\n\t\tif (s != e){\r\n\t\t\t//if not root node, create children\r\n\t\t\tif (l == nullptr){\r\n\t\t\t\tl = new node(s, m);\r\n\t\t\t\tr = new node(m+1, e);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid prop(){\r\n\t\t//propagate/pass down the lazy value\r\n\t\t\r\n\t\tif (lazy == 0) return;\r\n\t\t\r\n\t\t//change your value accordingly\r\n\t\tval += lazy * (e-s+1);\r\n\t\t\r\n\t\tif (s != e){\r\n\t\t\tcreate();\r\n\t\t\t//if not a leaf node\r\n\t\t\t//pass down lazy value\r\n\t\t\t//do not assume l->lazy and r->lazy are 0\r\n\t\t\t\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\t\r\n\t\tlazy = 0;\r\n\t}\r\n\t\r\n\tint query(int qs, int qe){\r\n\t\t//cerr << qs << ' ' << qe << ' ' << val << \"!!!\" << '\\n';\r\n\t\t\r\n\t\tcreate();\r\n\t\tprop();\r\n\t\tif (qs <= s && e <= qe){\r\n\t\t\t//completely covered\r\n\t\t\treturn val;\r\n\t\t}\r\n\t\t\r\n\t\tif (qe <= m){\r\n\t\t\t//only reaches left child\r\n\t\t\treturn l->query(qs, qe);\r\n\t\t}\r\n\t\tif (qs > m){\r\n\t\t\t//only reaches right child\r\n\t\t\treturn r->query(qs, qe);\r\n\t\t}\r\n\t\t\r\n\t\t//reaches both children\r\n\t\treturn l->query(qs, m) + r->query(m+1, qe);\r\n\t}\r\n\t\r\n\t//reach at most log(SIZE) nodes\r\n\t//for each query/update, only log(SIZE) nodes are created at most\r\n\t//so time complexity and memory complexity both O(log SIZE)\r\n\t\r\n\tvoid update(int qs, int qe, int k){\r\n\t\tcreate();\r\n\t\tprop();\r\n\t\tif (qs <= s && e <= qe){\r\n\t\t\t//completely covered\r\n\t\t\tlazy += k;\r\n\t\t\tprop();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tif (qe <= m){\r\n\t\t\tl->update(qs, qe, k);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\tr->update(qs, qe, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tl->update(qs, m, k);\r\n\t\t\tr->update(m+1, qe, k);\r\n\t\t}\r\n\t\t\r\n\t\tl->prop(); r->prop();\r\n\t\tval = l->val + r->val;\r\n\t}\r\n};\r\n\r\nint32_t main() {\r\n  ios_base::sync_with_stdio(0);\r\n  cin.tie(0);\r\n  cout.tie(0);\r\n  int n, q;\r\n  cin >> n >> q;\r\n  node stree(0, n - 1);\r\n  while(q--){\r\n\t  int t;\r\n\t  cin >> t;\r\n\t  if(t == 2){\r\n\t\t  int x, y;\r\n\t\t  cin >> x >> y;\r\n\t\t  x--;\r\n\t\t  y--;\r\n\t\t  cout << stree.query(x, y) << '\\n';\r\n\t  } else if(t == 1){\r\n\t\t  int a, b, c;\r\n\t\t  cin >> a >> b >> c;\r\n\t\t  a--;\r\n\t\t  b--;\r\n\t\t  stree.update(a, b, c);\r\n\t  }\r\n  }\r\n  return 0;\r\n}\r\n"
    },
    {
        "username": "ryangohca",
        "id": 562682,
        "date": "2024-12-09 10:32:56",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node {\r\n    node *l, *r;\r\n    int val, lazy;\r\n    node(): val(0), l(NULL), r(NULL), lazy(0){}\r\n    int value(int s, int e){\r\n        val += (e-s+1) * lazy;\r\n        if (s==e){\r\n            lazy = 0;\r\n            return val;\r\n        }\r\n        if (l == NULL) l = new node();\r\n        l->lazy += lazy;\r\n        if (r == NULL) r = new node();\r\n        r->lazy += lazy;\r\n        lazy = 0;\r\n        return val;\r\n    }\r\n    void update(int s, int e, int x, int y, int v) {\r\n        int m = (s + e) / 2;\r\n        if (s==x && e==y){\r\n           lazy += v;\r\n           return;\r\n        }\r\n        if (y <= m){\r\n            if (l == NULL) l = new node();\r\n            l->update(s, m, x, y, v);\r\n        } else if (x > m){\r\n            if (r == NULL) r = new node();\r\n            r->update(m+1, e, x, y, v);\r\n        } else {\r\n            if (l==NULL) l = new node();\r\n            if (r==NULL) r = new node();\r\n            l->update(s, m, x, m, v);\r\n            r->update(m+1, e, m+1, y, v);\r\n        }\r\n        val = (l==NULL?0:l->value(s, m)) + (r==NULL?0:r->value(m+1, e));\r\n    }\r\n    int query(int s, int e, int x, int y) {\r\n        value(s, e);\r\n        if (s == x && e == y) return val;\r\n        int m = (s + e) / 2;\r\n        if (x > m) return (r==NULL)? 0:r->query(m + 1, e, x, y);\r\n        if (y <= m) return (l==NULL)? 0:l->query(s, m, x, y);\r\n        if (l == NULL && r != NULL) return r->query(m+1, e, m+1, y);\r\n        if (l != NULL && r == NULL) return l->query(s, m, x, m);\r\n        if (l != NULL && r != NULL) return l->query(s, m, x, m) + r->query(m+1, e, m+1, y); //Change here for max\r\n        return 0;\r\n    }\r\n} *root;\r\nmain(){\r\n    int n, q; cin >> n >> q;\r\n    root = new node();\r\n    while (q--){\r\n        int t; cin >> t;\r\n        if (t == 1){\r\n            int a, b, c; cin >> a >> b >> c;\r\n            root->update(1, n, a, b, c);\r\n        } else {\r\n            int a, b; cin >> a >> b;\r\n            cout << root->query(1, n, a, b) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "Mimikyu",
        "id": 554427,
        "date": "2024-12-02 12:05:56",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define pii pair<int,int>\r\n#define f first\r\n#define s second\r\n#define pb push_back\r\n#define mp make_pair\r\n\r\nstruct node{\r\n\tint S,E,M,V,ladd;\r\n\tnode *l,*r;\r\n\tnode(int _S,int _E){\r\n\t\tS=_S;\r\n\t\tE=_E;\r\n\t\tM=(S+E)>>1;\r\n\t\tV=ladd=0;\r\n\t\tl=r=NULL;\r\n\t}\r\n\tvoid prop(){\r\n\t\tif(!l)l=new node(S,M);\r\n\t\tif(!r)r=new node(M+1,E);\r\n\t\tif(ladd!=0){\r\n\t\t\tl->ladd+=ladd;\r\n\t\t\tr->ladd+=ladd;\r\n\t\t\tl->V+=ladd*(M-S+1);\r\n\t\t\tr->V+=ladd*(E-M);\r\n\t\t\tladd=0;\r\n\t\t}\r\n\t}\r\n\tvoid upd(int x,int y,int v){\r\n\t\t//increase vals in range [x,y] by v\r\n\t\tprop();\r\n\t\tif(S==x and y==E){\r\n\t\t\tladd+=v;\r\n\t\t\tV+=v*(E-S+1);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(x>M)r->upd(x,y,v);\r\n\t\telse if(y<=M)l->upd(x,y,v);\r\n\t\telse{\r\n\t\t\tl->upd(x,M,v);\r\n\t\t\tr->upd(M+1,y,v);\r\n\t\t}\r\n\t\tV=l->V + r->V;\r\n\t}\r\n\tint sum(int x,int y){\r\n\t\t//sum elements in range [x,y]\r\n\t\tprop();\r\n\t\tif(S==x and E==y)return V;\r\n\t\tif(x>M)return r->sum(x,y);\r\n\t\telse if(y<=M)return l->sum(x,y);\r\n\t\telse return l->sum(x,M)+r->sum(M+1,y);\r\n\t}\r\n}*seggs;\r\n\r\nsigned main(){\r\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\r\n\tint n,q;cin>>n>>q;\r\n\tseggs=new node(0,n+1);\r\n\tfor(int i=0;i<q;i++){\r\n\t\tint a;cin>>a;\r\n\t\tif(a==1){\r\n\t\t\tint b,c,d;cin>>b>>c>>d;\r\n\t\t\tseggs->upd(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint b,c;cin>>b>>c;\r\n\t\t\tcout<<seggs->sum(b,c)<<'\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "Mimikyu",
        "id": 553744,
        "date": "2024-12-02 10:03:18",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nstruct node{\r\n    int S, E, M, V, ladd;\r\n    node *l,*r;\r\n    node(int _S,int _E){\r\n        S = _S;\r\n        E = _E;\r\n        M = (S + E) >> 1;\r\n        V = ladd = 0;\r\n        l = r = NULL;\r\n    }\r\n    void prop(){\r\n        if(!l) l = new node(S, M);\r\n        if(!r) r = new node(M + 1, E);\r\n        if(ladd != 0){\r\n            l->ladd += ladd;\r\n            r->ladd += ladd;\r\n            l->V += ladd * (M - S + 1);\r\n            r->V += ladd * (E - M);\r\n            ladd = 0;\r\n        }   \r\n    }\r\n    void upd(int x, int y, int v){\r\n        //increase vals in range [x,y] by v\r\n        prop();\r\n        if(S == x && E == y){\r\n            ladd += v;\r\n            V += v * (E - S + 1);\r\n            return;\r\n        }\r\n        if(x > M) r->upd(x, y, v);\r\n        else if(y <= M) l->upd(x, y, v);\r\n        else{\r\n            l->upd(x, M, v);\r\n            r->upd(M + 1, y, v);\r\n        }\r\n        V = l->V + r->V; \r\n    }\r\n    int sum(int x, int y){\r\n        //sum elements in range [x,y];\r\n        prop();\r\n        if(S == x && E == y) return V;\r\n        if(x > M) return r->sum(x, y);\r\n        else if(y <= M) return l->sum(x,y);\r\n        else return l->sum(x, M) + r->sum(M + 1, y);\r\n    }\r\n}*seggs;\r\nsigned main(){\r\n    int N, Q;\r\n    cin >> N >> Q;\r\n    seggs = new node(1, N);\r\n    for(int i=0;i<Q;i++){\r\n        int op;\r\n        cin >> op;\r\n        if(op == 1){\r\n            int l, r, k;\r\n            cin >> l >> r >> k;\r\n            seggs->upd(l, r, k);\r\n        }\r\n        else{\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << seggs->sum(l, r) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "Yanwang",
        "id": 544943,
        "date": "2024-11-14 15:56:11",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\nconst int MOD = 13371337;\r\nconst int INF = INT_MAX;\r\n#define ci pair<char,ll>\r\n#define ii pair<ll,ll>\r\n#define fi first\r\n#define se second\r\n#define show(x) cerr << #x << \" is \" << x << endl;\r\n#define f0r(n) for(int i = 0; i < n; i++)\r\n#define int long long\r\n\r\nstruct node{\r\n\tint s, e, mid, v, lazy;\r\n\tnode *l, *r;\r\n\tnode(int _s, int _e){\r\n\t\ts = _s; e = _e; mid = (s+e)/2; lazy = 0; \r\n\t}\r\n\tvoid create(){\r\n\t\tif (!l && s != e){\r\n\t\t\tl = new node(s, mid);\r\n\t\t\tr = new node(mid+1, e);\r\n\t\t}\r\n\t}\r\n\tint realval(){\r\n\t\treturn lazy * (e - s + 1) + v;\r\n\t}\r\n\tvoid upd(int x, int y, int u){\r\n\t\tif (x == s && y == e){\r\n\t\t\tlazy += u;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcreate();\r\n\t\tif (y <= mid) l->upd(x,y,u);\r\n\t\telse if (x > mid) r->upd(x,y,u);\r\n\t\telse{\r\n\t\t\tl->upd(x,mid,u);\r\n\t\t\tr->upd(mid+1,y,u);\r\n\t\t}\r\n\t\tv = l->realval() + r->realval();\r\n\t}\r\n\tint sum(int x, int y){\r\n\t\tif (x == s && y == e){\r\n\t\t\treturn realval();\r\n\t\t}\r\n\t\tcreate();\r\n\t\tint z = (y-x+1)*lazy;\r\n\t\tif (y <= mid) return l->sum(x,y) + z;\r\n\t\telse if (x > mid) return r->sum(x,y) + z;\r\n\t\telse{\r\n\t\t\treturn l->sum(x,mid) + r->sum(mid+1,y) + z;\r\n\t\t}\r\n\t\t\r\n\t}\r\n} *root;\r\n\r\nint32_t main(){\r\n\tint n, q;\r\n\tcin >> n >> q;\r\n\troot = new node(1, n);\r\n\twhile(q--){\r\n\t\tint a, b, c;\r\n\t\tcin >> a >>  b >> c;\r\n\t\tif (a == 1){\r\n\t\t\tint d;\r\n\t\t\tcin >> d;\r\n\t\t\troot->upd(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << root->sum(b,c) << endl;\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "Yanwang",
        "id": 544340,
        "date": "2024-11-13 22:18:07",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\n\r\nconst int MOD = 13371337;\r\nconst int MXN = 100005;\r\n#define int long long\r\n\r\nstruct SegmentTreeNode {\r\n    int sum = 0;  // Sum of the range\r\n    int lazy = 0; // Lazy propagation value\r\n    SegmentTreeNode *left = nullptr, *right = nullptr;\r\n};\r\n\r\nvoid propagate(SegmentTreeNode* node, int low, int high) {\r\n    if (node->lazy != 0) {\r\n        node->sum += (high - low + 1) * node->lazy;  // Apply the lazy value\r\n        if (low != high) { // Propagate laziness to children if not a leaf node\r\n            if (node->left == nullptr) node->left = new SegmentTreeNode();\r\n            if (node->right == nullptr) node->right = new SegmentTreeNode();\r\n            node->left->lazy += node->lazy;\r\n            node->right->lazy += node->lazy;\r\n        }\r\n        node->lazy = 0;\r\n    }\r\n}\r\n\r\nvoid update(SegmentTreeNode* node, int low, int high, int q_low, int q_high, int val) {\r\n    propagate(node, low, high);\r\n\r\n    if (q_low > high || q_high < low) return; // Out of range\r\n\r\n    if (q_low <= low && q_high >= high) { // Total range\r\n        node->sum += (high - low + 1) * val;\r\n        if (low != high) {\r\n            if (node->left == nullptr) node->left = new SegmentTreeNode();\r\n            if (node->right == nullptr) node->right = new SegmentTreeNode();\r\n            node->left->lazy += val;\r\n            node->right->lazy += val;\r\n        }\r\n        return;\r\n    }\r\n\r\n    // Partial range update\r\n    int mid = (low + high) / 2;\r\n    if (node->left == nullptr) node->left = new SegmentTreeNode();\r\n    if (node->right == nullptr) node->right = new SegmentTreeNode();\r\n    update(node->left, low, mid, q_low, q_high, val);\r\n    update(node->right, mid + 1, high, q_low, q_high, val);\r\n\r\n    node->sum = (node->left ? node->left->sum : 0) + (node->right ? node->right->sum : 0);\r\n}\r\n\r\nint query(SegmentTreeNode* node, int low, int high, int q_low, int q_high) {\r\n    propagate(node, low, high);\r\n\r\n    if (q_low > high || q_high < low) return 0; // Out of range\r\n\r\n    if (q_low <= low && q_high >= high) { // Total range\r\n        return node->sum;\r\n    }\r\n\r\n    // Partial range query\r\n    int mid = (low + high) / 2;\r\n    if (node->left == nullptr) node->left = new SegmentTreeNode();\r\n    if (node->right == nullptr) node->right = new SegmentTreeNode();\r\n    return query(node->left, low, mid, q_low, q_high) + query(node->right, mid + 1, high, q_low, q_high);\r\n}\r\n\r\nint32_t main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(0);\r\n\r\n    int n, q;\r\n    cin >> n >> q;\r\n\r\n    SegmentTreeNode* root = new SegmentTreeNode();  // Start with a single root node\r\n\r\n    while (q--) {\r\n        int t;\r\n        cin >> t;\r\n\r\n        if (t == 1) { // Update range [l, r] by k\r\n            int l, r, k;\r\n            cin >> l >> r >> k;\r\n            l--; r--; // Convert to 0-based index\r\n            update(root, 0, n - 1, l, r, k); // Recursive update\r\n        }\r\n\r\n        if (t == 2) { // Query the sum in range [l, r]\r\n            int l, r;\r\n            cin >> l >> r;\r\n            l--; r--; // Convert to 0-based index\r\n            cout << query(root, 0, n - 1, l, r) << endl; // Recursive query\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "zhehanp",
        "id": 535503,
        "date": "2024-11-02 15:56:25",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node {\r\n    node *left, *right;\r\n    int S, E, val, lazy;\r\n    node(int _s, int _e) : S(_s), E(_e) {\r\n        left = right = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void prop(){\r\n        if(S == E) return;\r\n        int M = (S + E) / 2;\r\n        if(left == nullptr){ // no children\r\n            left = new node(S, M);\r\n            right = new node(M + 1, E);\r\n        }\r\n        if(lazy != 0){\r\n            // need to add lazy to left and right children\r\n            left->val += lazy * (M - S + 1);\r\n            left->lazy += lazy;\r\n            right->val += lazy * (E - M);\r\n            right->lazy += lazy;\r\n            // reset lazy tag\r\n            lazy = 0;\r\n        }\r\n    }\r\n    int qry(int l, int r) { // sum from index l to index r\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return 0;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            return val;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        return left->qry(l, r) + right->qry(l, r);\r\n    }\r\n    void upd(int l, int r, int v) {\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            // update the value of the node and the lazy tag, do not recurse\r\n            val += v * (E - S + 1); // all E - S + 1 nodes has their value increased\r\n            lazy += v;\r\n            return;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        left->upd(l, r, v);\r\n        right->upd(l, r, v);\r\n        // update current node value\r\n        val = left->val + right->val;\r\n    }\r\n} *root;\r\n\r\n\r\nsigned main(){\r\n    int n,q;\r\n    cin>>n>>q;\r\n    root = new node (1,n);\r\n    for (int i{};i<q;++i){\r\n        int choice{};\r\n        cin>>choice;\r\n        if (choice == 1){\r\n            int a,b,v;\r\n            cin>>a>>b>>v;\r\n            root->upd(a,b,v);\r\n        }else{\r\n            int a,b;\r\n            cin>>a>>b;\r\n            cout<<root->qry(a,b)<<'\\n';\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "Dolphy",
        "id": 533221,
        "date": "2024-10-29 12:35:11",
        "code": "// tyx code copy paste coz testing it\r\n#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nstruct node{\r\n    int S, E, M, V, ladd;\r\n    node *l,*r;\r\n    node(int _S,int _E){\r\n        S = _S;\r\n        E = _E;\r\n        M = (S + E) >> 1;\r\n        V = ladd = 0;\r\n        l = r = NULL;\r\n    }\r\n    void prop(){\r\n        if(!l) l = new node(S, M);\r\n        if(!r) r = new node(M + 1, E);\r\n        if(ladd != 0){\r\n            l->ladd += ladd;\r\n            r->ladd += ladd;\r\n            l->V += ladd * (M - S + 1);\r\n            r->V += ladd * (E - M);\r\n            ladd = 0;\r\n        }   \r\n    }\r\n    void upd(int x, int y, int v){\r\n        //increase vals in range [x,y] by v\r\n        prop();\r\n        if(S == x && E == y){\r\n            ladd += v;\r\n            V += v * (E - S + 1);\r\n            return;\r\n        }\r\n        if(x > M) r->upd(x, y, v);\r\n        else if(y <= M) l->upd(x, y, v);\r\n        else{\r\n            l->upd(x, M, v);\r\n            r->upd(M + 1, y, v);\r\n        }\r\n        V = l->V + r->V; \r\n    }\r\n    int sum(int x, int y){\r\n        //sum elements in range [x,y];\r\n        prop();\r\n        if(S == x && E == y) return V;\r\n        if(x > M) return r->sum(x, y);\r\n        else if(y <= M) return l->sum(x,y);\r\n        else return l->sum(x, M) + r->sum(M + 1, y);\r\n    }\r\n}*seggs;\r\nsigned main(){\r\n    int N, Q;\r\n    cin >> N >> Q;\r\n    seggs = new node(1, N);\r\n    for(int i=0;i<Q;i++){\r\n        int op;\r\n        cin >> op;\r\n        if(op == 1){\r\n            int l, r, k;\r\n            cin >> l >> r >> k;\r\n            seggs->upd(l, r, k);\r\n        }\r\n        else{\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << seggs->sum(l, r) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "JustKitkat",
        "id": 530862,
        "date": "2024-10-16 23:55:52",
        "code": "// Author: JustKitkat\r\n// Status: WIP\r\n\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define el \"\\n\"\r\n#define arr array\r\n#define ll long long\r\n#define ld long double\r\n#define pii pair<int, int>\r\n#define pll pair<long long, long long>\r\n#define vi vector<int>\r\n#define vll vector<long long>\r\n#define vii vector<pair<int,int>>\r\n#define vllll vector<pair<ll,ll>>\r\n#define mii map<int, int>\r\n#define si set<int>\r\n#define sc set<char>\r\n#define pb push_back\r\n#define mp make_pair\r\n#define F first\r\n#define S second\r\n#define all(a) (a).begin(), (a).end()\r\n#define FOR(a,b) for(auto i=a;i<b;++i)\r\n#define DFOR(a,b) for(auto i=a;i>=b;--i)\r\n#define JFOR(a,b) for(auto j=a;j<b;++j)\r\n#define DJFOR(a,b) for(auto j=a;j>=b;--j)\r\n\r\nstring to_upper(string a) { for (int i=0;i<(int)a.size();++i) if (a[i]>='a' && a[i]<='z') a[i]-='a'-'A'; return a; }\r\nstring to_lower(string a) { for (int i=0;i<(int)a.size();++i) if (a[i]>='A' && a[i]<='Z') a[i]+='a'-'A'; return a; }\r\nbool prime(ll a) { if (a==1) return 0; for (int i=2;i<=round(sqrt(a));++i) if (a%i==0) return 0; return 1; }\r\nvoid yes() { cout<<\"YES\\n\"; }\r\nvoid no() { cout<<\"NO\\n\"; }\r\n\r\n#define __time__ { auto duration = chrono::duration<double>( /* Show runtime */ \\\r\nchrono::high_resolution_clock::now() - BEG); cout<<\"Time: \"<<duration.count()<<endl;}\r\n#define __output__ { FILE* file = freopen(\"../../../Testcases/test.out\", \"w\", stdout); }\r\n#define __input__ { FILE* file = freopen(\"../../../Testcases/test.in\", \"r\", stdin); }\r\n\r\nconst int MAX_N = 1e5 + 5;\r\nconst ll INF = 1e9;\r\nconst double PI = acos(-1);\r\nconst auto BEG = std::chrono::high_resolution_clock::now(); //Begining of the program\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long \r\n#define pii pair<int,int>\r\n#define dbg(v)\\\r\n    cout << \"Line(\" << __LINE__ << \") -> \" << #v << \" = \" << (v) << endl;\r\n\r\nstruct node{\r\n\tnode *left, *right;\r\n\tint S, E, val, lazy;\r\n\tnode(int _s, int _e) : S(_s), E(_e){\r\n\t\t\tleft = right = nullptr;\r\n\t\t\tval = 0;\r\n\t\t\tlazy = 0;\r\n\t}\r\n\r\n\tvoid prop(){\r\n\t\tif(S == E) return;\r\n\t\tint M = (S+E) >> 1;\r\n\t\tif(left == nullptr){\r\n\t\t\tleft = new node(S, M);\r\n\t\t\tright = new node(M+1, E);\r\n\t\t}\r\n\t\tif(lazy != 0){\r\n\t\t\tleft->val += lazy*(M-S+1);\r\n\t\t\tleft->lazy += lazy;\r\n\t\t\tright->val += lazy*(E-M);\r\n\t\t\tright->lazy += lazy;\r\n\t\t\tlazy = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tint qry(int l, int r){\r\n\t\tif (l > E || r < S) return 0;\r\n\t\tif(l <= S && E <= r) return val;\r\n\t\tprop();\r\n\t\treturn left->qry(l, r) + right->qry(l, r);\r\n\t}\r\n\t\r\n\tvoid upd(int l, int r, int v){\r\n\t\tif(l > E || r < S) return;\r\n\t\tif(l <= S && E <= r){\r\n\t\t\tval += v*(E-S+1);\r\n\t\t\tlazy += v;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tprop();\r\n\t\tleft->upd(l, r, v);\r\n\t\tright->upd(l, r, v);\r\n\t\tval = left->val + right->val;\r\n\t}\r\n};\r\n\r\nvoid solve(int tc){\r\n    int n, q;\r\n    cin>>n>>q;\r\n    node *st = new node(1,n);\r\n\r\n    FOR(0,q){\r\n        int a,b,c,d;\r\n        cin>>a>>b>>c;\r\n        if(a==1){cin>>d;st->upd(b,c,d);}\r\n        else cout<<st->qry(b,c)<<el;\r\n    }\r\n    \r\n}\r\n\r\n\r\nsigned main(){\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0); cout.tie(0);\r\n\r\n    //__output__ // Redirect output to test.out\r\n    //__input__ // Read test.in for input\r\n\r\n    int tc = 1;\r\n    //cin >> tc;\r\n    for (int t = 1; t <= tc; t++) {\r\n        // cout << \"Case #\" << t << \": \";\r\n        solve(t);\r\n    }\r\n\r\n    //__time__ //Runtime\r\n}\r\n// Note: int64_t for exactly 64 bit signed int"
    },
    {
        "username": "Shadow1",
        "id": 530852,
        "date": "2024-10-16 23:11:29",
        "code": "// Programmer: Shadow1\r\n\r\n#include <bits/stdc++.h>\r\n// #include <ext/pb_ds/assoc_container.hpp>\r\n// #include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\n\r\nusing ll = long long;\r\nusing ld = long double;\r\nusing ull = unsigned long long;\r\nusing str = string; // yay python!\r\n\r\n#define i64 int64_t\r\n#define show(x) cerr << (#x) << \" = \" << (x) << '\\n';\r\n#define output_vector(v) for(auto &x : v){cout << x << ' ';}cout << '\\n';\r\n#define output_pairvector(v) for(auto &x : v){cout << x.first << \" \" << x.second << '\\n';}\r\n#define vt vector\r\n#define pq priority_queue\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define pii pair<int,int>\r\n#define umap unordered_map\r\n#define uset unordered_set\r\n#define fir first\r\n#define sec second\r\n#define sz(x) ll(x.size())\r\n#define all(x) x.begin(), x.end()\r\n#define rall(x) x.rbegin(), x.rend()\r\n#define int ll\r\n#define discretize(x) sort(x.begin(), x.end()); x.erase(unique(x.begin(), x.end()), x.end());\r\n\r\n// T: O(n^3)\r\n// M : O(n + k log n) \r\n\r\nstruct node {\r\n    node *left, *right;\r\n    int S, E, val, lazy;\r\n    node(int _s, int _e) : S(_s), E(_e) {\r\n        left = right = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void prop(){\r\n        if(S == E) return;\r\n        int M = (S + E) / 2;\r\n        if(left == nullptr){ // no children\r\n            left = new node(S, M);\r\n            right = new node(M + 1, E);\r\n        }\r\n        if(lazy != 0){\r\n            // need to add lazy to left and right children\r\n            left->val += lazy * (M - S + 1);\r\n            left->lazy += lazy;\r\n            right->val += lazy * (E - M);\r\n            right->lazy += lazy;\r\n            // reset lazy tag\r\n            lazy = 0;\r\n        }\r\n    }\r\n    int qry(int l, int r) { // sum from index l to index r\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return 0;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            return val;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        return left->qry(l, r) + right->qry(l, r);\r\n    }\r\n    void upd(int l, int r, int v) {\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            // update the value of the node and the lazy tag, do not recurse\r\n            val += v * (E - S + 1); // all E - S + 1 nodes has their value increased\r\n            lazy += v;\r\n            return;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        left->upd(l, r, v);\r\n        right->upd(l, r, v);\r\n        // update current node value\r\n        val = left->val + right->val;\r\n    }\r\n} *root;\r\n\r\n\r\nvoid solve() {\r\n    int n, q;\r\n    cin >> n >> q;\r\n    root = new node(1, n);\r\n    while(q--) {\r\n        int t; cin >> t;\r\n        if(t == 1) {\r\n            int l, r, k;\r\n            cin >> l >> r >> k;\r\n            root->upd(l, r, k);\r\n        } else {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << root->qry(l, r) << '\\n';\r\n        }\r\n    }\r\n}\r\n\r\nsigned main() {\r\n    // freopen(\"output.txt\", \"w\", stdout);\r\n    // freopen(\"input.txt\", \"r\", stdin);\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL); \r\n    int T = 1;\r\n    // cin >> T;\r\n\r\n    while(T--)\r\n        solve();\r\n    return 0;\r\n}\r\n\r\n/* CHECK :\r\n1. COMPARATOR FUNCTION MUST RETURN FALSE WHEN ARGUMENTS ARE EQUAL!!!\r\n2. Overflow! Typecase int64_t on operations if varaibles are int\r\n3. Check array bounds!!!\r\n4. Check array indexing!!!\r\n5. Edge cases. (N==1)!!!\r\n*/"
    },
    {
        "username": "VNHbest",
        "id": 529132,
        "date": "2024-10-10 16:08:57",
        "code": "#include <bits/stdc++.h>\r\n#define ll long long\r\nusing namespace std;\r\nstruct node {\r\n    node *left, *right;\r\n    ll S, E, val, lazy;\r\n    node (ll S, ll E);\r\n    void prop();\r\n    void update(ll l, ll r, ll v);\r\n    ll queries (ll l ,ll r);\r\n}*tree;\r\n\r\nnode::node (ll S, ll E) {\r\n    this -> S = S;\r\n    this -> E = E;\r\n    val = 0;\r\n    lazy = 0;\r\n    left = right = nullptr;\r\n}\r\n\r\nvoid node::prop () {\r\n    if (S == E) return;\r\n    ll M = (S + E) / 2;\r\n    if (left == nullptr) {\r\n        left = new node(S, M);\r\n        right = new node(M + 1, E);\r\n    }\r\n    if (lazy != 0) {\r\n        left -> val += lazy*(M - S + 1);\r\n        left -> lazy += lazy;\r\n        right -> val += lazy*(E - M);\r\n        right -> lazy += lazy;\r\n        lazy = 0;\r\n    }\r\n}\r\nvoid node::update (ll l, ll r, ll v) {\r\n    if (E < l || S > r) {\r\n        return;\r\n    }\r\n    if (l <= S && E <= r) {\r\n        val += v*(E - S + 1);\r\n        lazy += v;\r\n        return;\r\n    }\r\n    prop();\r\n    left -> update(l, r, v);\r\n    right -> update(l, r, v);\r\n    val = left -> val + right -> val;\r\n}\r\n\r\nll node::queries (ll l, ll r) {\r\n    if (E < l || S > r) {\r\n        return 0;\r\n    }\r\n    if (l <= S && E <= r) {\r\n        return val;\r\n    }\r\n    prop();\r\n    return left -> queries(l, r) + right -> queries(l, r);\r\n}\r\n\r\nint main () {\r\n    ll n, q;\r\n    cin >> n >> q;\r\n    tree = new node(1, n);\r\n    for (long long i = 0; i < q; i++) {\r\n        ll a;\r\n        cin >> a;\r\n        if (a == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree -> update(l, r, v);\r\n        }\r\n        else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << tree -> queries(l, r) << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "shoryu386",
        "id": 521755,
        "date": "2024-08-29 00:33:38",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node{\r\n\tint s, e, m;\r\n\tint v = 0, lazy = 0;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\t\r\n\tnode(int ss, int ee){\r\n\t\ts = ss, e = ee;\r\n\t\tm = (s+e)/2;\r\n\t}\r\n\t\r\n\tvoid createChildren(){\r\n\t\tif (l == nullptr && s != e){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid prop(){\r\n\t\tcreateChildren();\r\n\t\tif (s != e){\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\tv += (lazy * (e-s+1)); //range sum\r\n\t\tlazy = 0;\r\n\t}\r\n\t\r\n\t//range add\r\n\tvoid update(int qs, int qe, int k){\r\n\t\tcreateChildren();\r\n\t\tprop();\r\n\t\tif (qs <= s && e <= qe){\r\n\t\t\tlazy += k;\r\n\t\t\tprop();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tif (qe <= m){\r\n\t\t\tl->update(qs, qe, k);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\tr->update(qs, qe, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tl->update(qs, m, k);\r\n\t\t\tr->update(m+1, qe, k);\r\n\t\t}\r\n\t\t\r\n\t\tl->prop(); r->prop();\r\n\t\tv = (l->v + r->v); //sum\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t//range sum\r\n\tint query(int qs, int qe){\r\n\t\tcreateChildren();\r\n\t\tprop();\r\n\t\tif (qs <= s && e <= qe){\r\n\t\t\treturn v;\r\n\t\t}\r\n\t\t\r\n\t\tif (qe <= m){\r\n\t\t\treturn l->query(qs, qe);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\treturn r->query(qs, qe);\r\n\t\t}\r\n\t\telse{\r\n\t\t\treturn l->query(qs, m) + r->query(m+1, qe);\r\n\t\t\t//sum\r\n\t\t}\r\n\t}\r\n};\r\n\r\nsigned main(){\r\n\t\r\n\tint n, q; cin >> n >> q;\r\n\tnode st(0, n-1); //create segment tree with start index 0, end index n-1\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint t; cin >> t;\r\n\t\t\r\n\t\tif (t == 1){\r\n\t\t\t//update\r\n\t\t\tint l, r, k;\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\tl--; r--; //convert to 0-index\r\n\t\t\tst.update(l, r, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\t//query\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tl--; r--; //convert to 0-index\r\n\t\t\tcout << st.query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "TheRaptor",
        "id": 515522,
        "date": "2024-08-07 10:29:05",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace __gnu_pbds;\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\ngp_hash_table<int,long long,custom_hash> FT[2];\r\n\r\ninline int hole(int x){\r\n\treturn x+(x>>10);\r\n}\r\nint N;\r\n\r\ninline void update(int nya, int x, long long v){\r\n\tfor(; x<=N; x+=x&-x){\r\n\t\tFT[nya][hole(x)] += v;\r\n\t}\r\n}\r\n\r\ninline long long query(int nya, int x){\r\n\tlong long ret = 0;\r\n\tfor(; x; x-=x&-x){\r\n\t\tret += FT[nya][hole(x)];\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\ninline void range_update(int x, int y, long long v){\r\n\tupdate(0, x, v);\r\n\tupdate(0, y+1, -v);\r\n\tupdate(1, x, (long long)v*(x-1));\r\n\tupdate(1, y+1, (long long)-v*y);\r\n}\r\n\r\ninline long long prefix_query(int x){\r\n\treturn (long long)query(0, x)*x - query(1, x);\r\n}\r\n\r\ninline long long range_query(int x, int y){\r\n\treturn prefix_query(y) - prefix_query(x-1);\r\n}\r\n\r\nint32_t main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    int q;\r\n    cin >> N >> q;\r\n    for(int i=0; i<q; i++){\r\n\t\tint cmd;\r\n\t\tcin >> cmd;\r\n\t\tif(cmd==1){\r\n\t\t\tint a,b;\r\n\t\t\tlong long c;\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\trange_update(a,b,c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint a,b;\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << range_query(a,b) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "TheRaptor",
        "id": 515521,
        "date": "2024-08-07 10:28:19",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace __gnu_pbds;\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\ngp_hash_table<int,long long,custom_hash> FT[2];\r\n\r\ninline int hole(int x){\r\n\treturn x+(x>>15);\r\n}\r\nint N;\r\n\r\ninline void update(int nya, int x, long long v){\r\n\tfor(; x<=N; x+=x&-x){\r\n\t\tFT[nya][hole(x)] += v;\r\n\t}\r\n}\r\n\r\ninline long long query(int nya, int x){\r\n\tlong long ret = 0;\r\n\tfor(; x; x-=x&-x){\r\n\t\tret += FT[nya][hole(x)];\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\ninline void range_update(int x, int y, long long v){\r\n\tupdate(0, x, v);\r\n\tupdate(0, y+1, -v);\r\n\tupdate(1, x, (long long)v*(x-1));\r\n\tupdate(1, y+1, (long long)-v*y);\r\n}\r\n\r\ninline long long prefix_query(int x){\r\n\treturn (long long)query(0, x)*x - query(1, x);\r\n}\r\n\r\ninline long long range_query(int x, int y){\r\n\treturn prefix_query(y) - prefix_query(x-1);\r\n}\r\n\r\nint32_t main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    int q;\r\n    cin >> N >> q;\r\n    for(int i=0; i<q; i++){\r\n\t\tint cmd;\r\n\t\tcin >> cmd;\r\n\t\tif(cmd==1){\r\n\t\t\tint a,b;\r\n\t\t\tlong long c;\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\trange_update(a,b,c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint a,b;\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << range_query(a,b) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "TheRaptor",
        "id": 515520,
        "date": "2024-08-07 10:26:36",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace __gnu_pbds;\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\ngp_hash_table<int,long long,custom_hash> FT[2];\r\n\r\ninline int hole(int x){\r\n\treturn x+(x>>15);\r\n}\r\nint N;\r\n\r\nvoid update(int nya, int x, long long v){\r\n\tfor(; x<=N; x+=x&-x){\r\n\t\tFT[nya][hole(x)] += v;\r\n\t}\r\n}\r\n\r\nlong long query(int nya, int x){\r\n\tlong long ret = 0;\r\n\tfor(; x; x-=x&-x){\r\n\t\tret += FT[nya][hole(x)];\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nvoid range_update(int x, int y, long long v){\r\n\tupdate(0, x, v);\r\n\tupdate(0, y+1, -v);\r\n\tupdate(1, x, (long long)v*(x-1));\r\n\tupdate(1, y+1, (long long)-v*y);\r\n}\r\n\r\nlong long prefix_query(int x){\r\n\treturn (long long)query(0, x)*x - query(1, x);\r\n}\r\n\r\nlong long range_query(int x, int y){\r\n\treturn prefix_query(y) - prefix_query(x-1);\r\n}\r\n\r\nint32_t main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    int q;\r\n    cin >> N >> q;\r\n    for(int i=0; i<q; i++){\r\n\t\tint cmd;\r\n\t\tcin >> cmd;\r\n\t\tif(cmd==1){\r\n\t\t\tint a,b;\r\n\t\t\tlong long c;\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\trange_update(a,b,c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint a,b;\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << range_query(a,b) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "TheRaptor",
        "id": 515519,
        "date": "2024-08-07 10:24:08",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace __gnu_pbds;\r\ngp_hash_table<int,long long> FT[2];\r\ninline int hole(int x){\r\n\treturn x+(x>>15);\r\n}\r\nint N;\r\n\r\nvoid update(int nya, int x, long long v){\r\n\tfor(; x<=N; x+=x&-x){\r\n\t\tFT[nya][hole(x)] += v;\r\n\t}\r\n}\r\n\r\nlong long query(int nya, int x){\r\n\tlong long ret = 0;\r\n\tfor(; x; x-=x&-x){\r\n\t\tret += FT[nya][hole(x)];\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nvoid range_update(int x, int y, long long v){\r\n\tupdate(0, x, v);\r\n\tupdate(0, y+1, -v);\r\n\tupdate(1, x, (long long)v*(x-1));\r\n\tupdate(1, y+1, (long long)-v*y);\r\n}\r\n\r\nlong long prefix_query(int x){\r\n\treturn (long long)query(0, x)*x - query(1, x);\r\n}\r\n\r\nlong long range_query(int x, int y){\r\n\treturn prefix_query(y) - prefix_query(x-1);\r\n}\r\n\r\nint32_t main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    int q;\r\n    cin >> N >> q;\r\n    for(int i=0; i<q; i++){\r\n\t\tint cmd;\r\n\t\tcin >> cmd;\r\n\t\tif(cmd==1){\r\n\t\t\tint a,b;\r\n\t\t\tlong long c;\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\trange_update(a,b,c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint a,b;\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << range_query(a,b) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "TheRaptor",
        "id": 515518,
        "date": "2024-08-07 10:19:10",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#include <ext/pb_ds/assoc_container.hpp>\r\nusing namespace __gnu_pbds;\r\nstruct custom_hash {\r\n    static uint64_t splitmix64(uint64_t x) {\r\n        // http://xorshift.di.unimi.it/splitmix64.c\r\n        x += 0x9e3779b97f4a7c15;\r\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\r\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\r\n        return x ^ (x >> 31);\r\n    }\r\n\r\n    size_t operator()(uint64_t x) const {\r\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\r\n        return splitmix64(x + FIXED_RANDOM);\r\n    }\r\n};\r\ngp_hash_table<int,long long,custom_hash> FT[2];\r\nint N;\r\n\r\nvoid update(int nya, int x, long long v){\r\n\tfor(; x<=N; x+=x&-x){\r\n\t\tFT[nya][x] += v;\r\n\t}\r\n}\r\n\r\nlong long query(int nya, int x){\r\n\tlong long ret = 0;\r\n\tfor(; x; x-=x&-x){\r\n\t\tret += FT[nya][x];\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nvoid range_update(int x, int y, long long v){\r\n\tupdate(0, x, v);\r\n\tupdate(0, y+1, -v);\r\n\tupdate(1, x, (long long)v*(x-1));\r\n\tupdate(1, y+1, (long long)-v*y);\r\n}\r\n\r\nlong long prefix_query(int x){\r\n\treturn (long long)query(0, x)*x - query(1, x);\r\n}\r\n\r\nlong long range_query(int x, int y){\r\n\treturn prefix_query(y) - prefix_query(x-1);\r\n}\r\n\r\nint32_t main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    int q;\r\n    cin >> N >> q;\r\n    for(int i=0; i<q; i++){\r\n\t\tint cmd;\r\n\t\tcin >> cmd;\r\n\t\tif(cmd==1){\r\n\t\t\tint a,b;\r\n\t\t\tlong long c;\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\trange_update(a,b,c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint a,b;\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << range_query(a,b) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "shoryu386",
        "id": 507646,
        "date": "2024-07-20 23:36:03",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node{\r\n\tnode *l = nullptr, *r = nullptr;\r\n\tint s, e, m;\r\n\t\r\n\t//lazy creation (segment tree can support range of 10^18)\r\n\t//root s = 0, e = 10^18\r\n\tint val, lazy; //lazy propagation (pass down)\r\n\t\r\n\tnode(int _s, int _e){\r\n\t\ts = _s;\r\n\t\te = _e;\r\n\t\t\r\n\t\tm = (s+e)/2;\r\n\t\tlazy = 0;\r\n\t\t\r\n\t\tval = 0;\r\n\t}\r\n\t\r\n\tvoid create(){\r\n\t\tif (s != e){\r\n\t\t\t//if not root node, create children\r\n\t\t\tif (l == nullptr){\r\n\t\t\t\tl = new node(s, m);\r\n\t\t\t\tr = new node(m+1, e);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid prop(){\r\n\t\t//propagate/pass down the lazy value\r\n\t\t\r\n\t\tif (lazy == 0) return;\r\n\t\t\r\n\t\t//change your value accordingly\r\n\t\tval += lazy * (e-s+1);\r\n\t\t\r\n\t\tif (s != e){\r\n\t\t\tcreate();\r\n\t\t\t//if not a leaf node\r\n\t\t\t//pass down lazy value\r\n\t\t\t//do not assume l->lazy and r->lazy are 0\r\n\t\t\t\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\t\r\n\t\tlazy = 0;\r\n\t}\r\n\t\r\n\tint query(int qs, int qe){\r\n\t\t//cerr << qs << ' ' << qe << ' ' << val << \"!!!\" << '\\n';\r\n\t\t\r\n\t\tcreate();\r\n\t\tprop();\r\n\t\tif (qs <= s && e <= qe){\r\n\t\t\t//completely covered\r\n\t\t\treturn val;\r\n\t\t}\r\n\t\t\r\n\t\tif (qe <= m){\r\n\t\t\t//only reaches left child\r\n\t\t\treturn l->query(qs, qe);\r\n\t\t}\r\n\t\tif (qs > m){\r\n\t\t\t//only reaches right child\r\n\t\t\treturn r->query(qs, qe);\r\n\t\t}\r\n\t\t\r\n\t\t//reaches both children\r\n\t\treturn l->query(qs, m) + r->query(m+1, qe);\r\n\t}\r\n\t\r\n\t//reach at most log(SIZE) nodes\r\n\t//for each query/update, only log(SIZE) nodes are created at most\r\n\t//so time complexity and memory complexity both O(log SIZE)\r\n\t\r\n\tvoid update(int qs, int qe, int k){\r\n\t\tcreate();\r\n\t\tprop();\r\n\t\tif (qs <= s && e <= qe){\r\n\t\t\t//completely covered\r\n\t\t\tlazy += k;\r\n\t\t\tprop();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tif (qe <= m){\r\n\t\t\tl->update(qs, qe, k);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\tr->update(qs, qe, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tl->update(qs, m, k);\r\n\t\t\tr->update(m+1, qe, k);\r\n\t\t}\r\n\t\t\r\n\t\tl->prop(); r->prop();\r\n\t\tval = l->val + r->val;\r\n\t}\r\n};\r\n\r\nmain() {\r\n\tint n, q; cin >> n >> q;\r\n\t\r\n\tnode segtree(0, n-1);\r\n\t\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint type, l, r, k; cin >> type;\r\n\t\t\r\n\t\tif (type == 1){\r\n\t\t\tcin >> l >> r >> k; l--; r--;\r\n\t\t\t\r\n\t\t\tsegtree.update(l, r, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin >> l >> r; l--; r--;\r\n\t\t\t\r\n\t\t\tcout << segtree.query(l, r) << '\\n';\r\n\t\t}\r\n\t\t\r\n\t\t//range set\r\n\t\t//set a whole range [l, r] to K\r\n\t\t\r\n\t\t//range update\r\n\t\t//add a value K to all elements in the range [l, r]\r\n\t}\r\n}\r\n"
    },
    {
        "username": "Oonhan",
        "id": 505686,
        "date": "2024-07-14 23:38:41",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node{\r\n    int s, e, m, v, lazy;\r\n    node *l = nullptr;\r\n    node *r = nullptr;\r\n    \r\n    node(int _s, int _e){\r\n        s = _s; e = _e;\r\n        m = (s + e) >> 1;\r\n        v = lazy = 0;\r\n    }\r\n    \r\n    void prop(){\r\n        create();\r\n        if(lazy == 0) return;\r\n        v += lazy * (e-s+1);\r\n        if(s != e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n    \r\n    void create(){\r\n        if(s != e && l == nullptr){\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n    \r\n    int query(int x, int y){\r\n        prop();\r\n        if(s == x && e == y) return v;\r\n        else{\r\n            if(x > m) return r->query(x, y);\r\n            if(y <= m) return l->query(x, y);\r\n            return l->query(x, m) + r->query(m+1, y);\r\n        }\r\n    }\r\n    \r\n    void update(int x, int y, int add){\r\n        prop();\r\n        if(s == x && e == y){ lazy += add; return; }\r\n        else{\r\n            if(x > m) r->update(x, y, add);\r\n            else if(y <= m) l->update(x, y, add);\r\n            else{\r\n                l->update(x, m, add);\r\n                r->update(m+1, y, add);\r\n            }\r\n            l->prop(); r->prop();\r\n            v = l->v + r->v;\r\n        }\r\n    }\r\n} *root;\r\n\r\nsigned main(){\r\n    ios::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    \r\n    int n, q; cin >> n >> q;\r\n    root = new node(1, n);\r\n    while(q --){\r\n        int a; cin >> a;\r\n        if(a == 1){\r\n            int l, r, k; cin >> l >> r >> k;\r\n            root->update(l, r, k);\r\n        } else{\r\n            int l, r; cin >> l >> r;\r\n            cout << root->query(l, r) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "lHog",
        "id": 498855,
        "date": "2024-06-28 15:20:12",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nstruct node {\r\n\tlong long s, e, v, lz = 0;\r\n\tnode *l, *r;\r\n\tnode (long long ss, long long ee) {\r\n\t\ts = ss, e = ee;\r\n\t\tv = 0;\r\n\t\tl = r = NULL;\r\n\t}\r\n\tvoid prop() {\r\n\t\tif (s < e) {\r\n\t\t\tif (!l) l = new node (s, (s+e)/2);\r\n\t\t\tif (!r) r = new node ((s+e)/2+1, e);\r\n\t\t\tl -> add(s, e, lz);\r\n\t\t\tr -> add(s, e, lz);\r\n\t\t\tlz = 0;\r\n\t\t}\r\n\t}\r\n\tvoid add(long long a, long long b, long long c) {\r\n\t\tif (a <= s && e <= b) {\r\n\t\t\tlz += c;\r\n\t\t\tv += (e-s+1)*c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tprop();\r\n\t\tif (a <= (s+e)/2) l -> add(a, b, c);\r\n\t\tif ((s+e)/2 < b) r -> add(a, b, c);\r\n\t\tv = l -> v+r -> v;\r\n\t}\r\n\tlong long query(long long a, long long b) {\r\n\t\tif (a <= s && e <= b) return v;\r\n\t\tprop();\r\n\t\tlong long ans = 0;\r\n\t\tif (a <= (s+e)/2) ans = l -> query(a, b);\r\n\t\tif ((s+e)/2 < b) ans += r -> query(a, b);\r\n\t\treturn ans;\r\n\t}\r\n} *root;\r\nint main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\tlong long n, q;\r\n\tcin >> n >> q;\r\n\troot = new node (0, n);\r\n\twhile (q--) {\r\n\t\tlong long a, b, c;\r\n\t\tcin >> a;\r\n\t\tif (a == 1) {\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\troot -> add(a, b, c);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << root -> query(a, b) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n\r\n"
    },
    {
        "username": "lHog",
        "id": 496943,
        "date": "2024-06-25 07:15:59",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define eb emplace_back\r\n#define mp make_pair\r\ntypedef pair<int,int> pii;\r\n#define f first\r\n#define s second\r\n\r\n#ifdef local\r\n#define debug(x) cerr<<\"Line \"<<_LINE_<<\": \"<<#x<<\"=\"<<x<<'\\n';\r\nbool deb=true;\r\n#else\r\n#define debug(x);\r\nbool deb=false;//for in-code checking\r\n#endif\r\n\r\n#define min(a,b) ((a<b)?a:b)\r\n#define max(a,b) ((a>b)?a:b)\r\n#define lbd lower_bound\r\n#define upb upper_bound\r\n\r\n//const int mod=1000000007 or 998244353;\r\n\r\nstruct node{//range sum...\r\n  int s,e,v,lz=0;\r\n  node *l,*r;\r\n  node(int ss,int ee){\r\n    s=ss;e=ee;\r\n    v=0; //range sum\r\n    l=r=NULL;\r\n  }\r\n  void prop(){\r\n    if(s<e){\r\n      if(!l)l=new node(s,(s+e)/2);\r\n      if(!r)r=new node((s+e)/2+1,e);\r\n      l->add(s,e,lz);\r\n      r->add(s,e,lz);\r\n      lz=0;\r\n    }\r\n  }\r\n  void add(int a,int b,int c){\r\n    if(a<=s && e<=b){\r\n      lz+=c;\r\n      v+=(e-s+1)*c;\r\n      return;\r\n    }\r\n    prop();\r\n    if(a<=(s+e)/2)l->add(a,b,c);\r\n    if((s+e)/2<b)r->add(a,b,c);\r\n    v=l->v+r->v;\r\n  }\r\n  int query(int a,int b){\r\n    if(a<=s && e<=b)return v;\r\n    prop();\r\n    int ans=0;\r\n    if(a<=(s+e)/2)ans=l->query(a,b);\r\n    if((s+e)/2<b)ans+=r->query(a,b);\r\n    return ans;\r\n  }\r\n} *root;\r\n\r\nint32_t main(){\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  int n,q;\r\n  cin>>n>>q;\r\n  root=new node(0,n);\r\n  while(q--){\r\n    int a,b,c;\r\n    cin>>a;\r\n    if(a==1){\r\n      cin>>a>>b>>c;\r\n      root->add(a,b,c);\r\n    }else{\r\n      cin>>a>>b;\r\n      cout<<root->query(a,b)<<'\\n';\r\n    }\r\n  }\r\n  return 0;\r\n}"
    },
    {
        "username": "bakchormee",
        "id": 493875,
        "date": "2024-06-21 14:19:08",
        "code": "#include <bits/stdc++.h> \r\nusing namespace std; \r\n#define ll long long \r\n#define INF 1e16+7\r\n\r\nstruct node{\r\n\tll s, e, m, v, lazy;\r\n\t\r\n\tnode *l, *r;\r\n\t\r\n\tnode(ll _s, ll _e){\r\n\t\ts = _s, e = _e, m = (s+e)/2, v = 0, lazy = 0;\r\n\t}\r\n\t\r\n\tvoid create(){\r\n\t\tif(s != e){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid propogate(){\r\n\t\tif(l == nullptr) create();\r\n\t\tif(lazy == 0) return;\r\n\t\tv += lazy*(e-s+1);\r\n\t\tif(s != e){\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\t\r\n\tvoid up(ll _s, ll _e, ll value){\r\n\t\tif(l == nullptr) create();\r\n\t\tif(_s == s && _e == e){\r\n\t\t\tlazy += value;\r\n\t\t\treturn;\r\n\t\t} else {\r\n\t\t\tif(m < _s){\r\n\t\t\t\tr->up(_s, _e, value);\r\n\t\t\t} else if(_e <= m){\r\n\t\t\t\tl->up(_s, _e, value);\r\n\t\t\t} else {\r\n\t\t\t\tl->up(_s, m, value), r->up(m+1, _e, value);\r\n\t\t\t}\r\n\t\t\tl->propogate(); r->propogate();\r\n\t\t\tv = l->v + r->v;\r\n\t\t}\r\n\t}\r\n\t\r\n\tll qry(ll _s, ll _e){\r\n\t\tif(l == nullptr) create();\r\n\t\tpropogate();\r\n\t\tif(_s == s && _e == e){\r\n\t\t\treturn v;\r\n\t\t} else {\r\n\t\t\tif(_e <= m){\r\n\t\t\t\treturn l->qry(_s, _e);\r\n\t\t\t} else if(_s > m){\r\n\t\t\t\treturn r->qry(_s, _e);\r\n\t\t\t} else {\r\n\t\t\t\treturn l->qry(_s, m) + r->qry(m+1, _e);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n} *root;\r\n\r\n\r\nint main(){\r\n\tll n, q; cin >> n >> q;\r\n\troot = new node(1, n+1);\r\n\tfor(ll i = 0; i < q; i++){\r\n\t\tll t; cin >> t;\r\n\t\tif(t == 2){\r\n\t\t\tll x, y; cin >> x >> y;\r\n\t\t\tcout << root->qry(x, y) << \"\\n\";\r\n\t\t} else {\r\n\t\t\tll a, b, c; cin >> a >> b >> c;\r\n\t\t\troot->up(a, b, c);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n"
    },
    {
        "username": "TheRaptor",
        "id": 473670,
        "date": "2024-05-17 16:18:27",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nunordered_map<int,long long> fenw,fenw2;\r\nconst long long mxn=1000000005;\r\nvoid up(int x, long long v, unordered_map<int,long long> &f){\r\n\tfor(;x<mxn;x+=x&-x) f[x]+=v;\r\n}\r\nlong long qu(int x, unordered_map<int,long long> &f){\r\n\tlong long ret=0;\r\n\tfor(;x;x-=x&-x) if(f.find(x)!=f.end()) ret+=f[x];\r\n\treturn ret;\r\n}\r\nvoid update(int x, int y, long long v){\r\n\tup(x,v,fenw);\r\n\tup(y+1,-v,fenw);\r\n\tup(x,-(x-1)*v,fenw2);\r\n\tup(y+1,y*v,fenw2);\r\n}\r\nlong long query(int x, int y){\r\n\tlong long a=qu(y,fenw)*y+qu(y,fenw2);\r\n\tlong long b=qu(x-1,fenw)*(x-1)+qu(x-1,fenw2);\r\n\treturn a-b;\r\n}\r\nint32_t main(){\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint n,m;\r\n\tcin >> n >> m;\r\n\twhile(m--){\r\n\t\tint x;\r\n\t\tcin >> x;\r\n\t\tif(x==1){\r\n\t\t\tlong long a,b,c;\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\tupdate(a,b,c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tlong long a,b;\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << query(a,b) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "Batigol",
        "id": 473451,
        "date": "2024-05-17 13:13:48",
        "code": "#include<bits/stdc++.h>\r\n#define ll long long\r\n#define vll vector<ll>\r\n#define pll pair<ll,ll>\r\nusing namespace std;\r\nstruct node{\r\n    node *left,*right;\r\n    ll S,E,val,lazy;\r\n    node(ll S, ll E);\r\n    void prop();\r\n    void update(ll l , ll r, ll v);\r\n    ll queries(ll l, ll r);\r\n} *segtree;\r\nnode::node(ll S, ll E){\r\n    this->S = S;\r\n    this->E = E;\r\n    left = right = nullptr;\r\n    val = 0;\r\n    lazy = 0;\r\n}\r\nvoid node::prop(){\r\n    if(S==E) return;\r\n    ll M = (S+E)/2;\r\n    if(left == nullptr){\r\n        left = new node(S,M);\r\n        right = new node(M+1, E);\r\n    }\r\n    if(lazy!=0){\r\n        left->val+=lazy*(M-S+1);\r\n        right->val += lazy*(E-M);\r\n        left->lazy+=lazy;\r\n        right->lazy += lazy;\r\n        lazy = 0;\r\n    }\r\n}\r\nvoid node::update(ll l, ll r, ll v){\r\n    if(l>E||r<S){\r\n        return;\r\n    }\r\n    if(l<=S&&E<=r){\r\n        val+= v*(E-S+1);\r\n        lazy +=v;\r\n        return;\r\n    }\r\n    prop();\r\n    left->update(l,r,v);\r\n    right->update(l,r,v);\r\n    val = left->val+right->val;\r\n}\r\nll node::queries(ll l, ll r){\r\n    if(l>E||r<S){\r\n        return 0;\r\n    }\r\n    if(l<=S&&E<=r){\r\n        return val;\r\n    }\r\n    prop();\r\n    return left->queries(l,r)+right->queries(l,r);\r\n}\r\nint main(){\r\n    ll n, q;\r\n    cin>>n>>q;\r\n    segtree = new node(0,++n);\r\n    while(q--){\r\n        ll dir;\r\n        cin>>dir;\r\n        if(dir==1){\r\n            ll l,r,v;\r\n            cin>>l>>r>>v;\r\n            segtree->update(l-1,r-1,v);\r\n        }else{\r\n            ll l,r;\r\n            cin>>l>>r;\r\n            cout<<segtree->queries(l-1,r-1)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "liuyueyang0510",
        "id": 471968,
        "date": "2024-05-14 18:29:04",
        "code": "# include <bits/stdc++.h>\r\n# define ll long long\r\n\r\nusing namespace std;\r\n\r\nbool x = false; // update : true // increment : false\r\nint y = 3; // min query : 1 // max query : 2 // sum query : 3\r\nbool z = false; // 0-index : true // 1-index : false\r\n\r\nstruct node {\r\n    ll s, e, m, n, lazy;\r\n    node *l, *r;\r\n\r\n    node(ll a, ll b) {\r\n        s = a;\r\n        e = b;\r\n        m = (s + e) / 2;\r\n        n = 0;\r\n        lazy = 0;\r\n    }\r\n\r\n    void build() {\r\n        if (s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m + 1, e);\r\n        }\r\n    }\r\n\r\n    void propagate() {\r\n        if (l == nullptr)\r\n            build();\r\n        if (lazy == 0)\r\n            return;\r\n        if (x && y < 3)\r\n            n = lazy;\r\n        if (!x && y < 3)\r\n            n += lazy;\r\n        if (x && y == 3)\r\n            n = (e - s + 1) * lazy;\r\n        if (!x && y == 3)\r\n            n += (e - s + 1) * lazy;\r\n        if (s != e) {\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\n    ll query(ll a, ll b) {\r\n        if (l == nullptr)\r\n            build();\r\n        propagate();\r\n        if (a == s && b == e)\r\n            return n;\r\n        else if (b <= m)\r\n            return l->query(a, b);\r\n        else if (a > m)\r\n            return r->query(a, b);\r\n        else {\r\n            if (y == 1)\r\n                return min(l->query(a, m), r->query(m + 1, b));\r\n            else if (y == 2)\r\n                return max(l->query(a, m), r->query(m + 1, b));\r\n            else\r\n                return l->query(a, m) + r->query(m + 1, b);\r\n        }\r\n    }\r\n\r\n    void update(ll a, ll b, ll v) {\r\n        if (l == nullptr)\r\n            build();\r\n        propagate();\r\n        if (a == s && b == e) {\r\n            if (x)\r\n                lazy = v;\r\n            else\r\n                lazy += v;\r\n        }\r\n        else {\r\n            if (b <= m)\r\n                l->update(a, b, v);\r\n            else if (a > m)\r\n                r->update(a, b, v);\r\n            else\r\n                l->update(a, m, v), r->update(m + 1, b, v);\r\n            l->propagate();\r\n            r->propagate();\r\n            if (y == 1)\r\n                n = min(l->n, r->n);\r\n            else if (y == 2)\r\n                n = max(l->n, r->n);\r\n            else\r\n                n = l->n + r->n;\r\n        }\r\n    }\r\n} *root;\r\n\r\nint main() {\r\n    ll n, q, t, a, b, c;\r\n    cin >> n >> q;\r\n    if (z)\r\n        root = new node(0, n - 1);\r\n    else\r\n        root = new node(1, n);\r\n    while (q--) {\r\n        cin >> t;\r\n        if (t == 2) {\r\n            cin >> a >> b;\r\n            cout << root->query(a, b) << \"\\n\";\r\n        }\r\n        else {\r\n            cin >> a >> b >> c;\r\n            root->update(a, b, c);\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "liuyueyang0510",
        "id": 471188,
        "date": "2024-05-12 10:53:02",
        "code": "# include <bits/stdc++.h>\r\n# define ll long long\r\n\r\nusing namespace std;\r\n\r\nstruct node {\r\n    ll s, e, m, n, lazy;\r\n    node *l, *r;\r\n\r\n    node(ll a, ll b) {\r\n        s = a;\r\n        e = b;\r\n        m = (s + e) / 2;\r\n        n = 0;\r\n        lazy = 0;\r\n    }\r\n\r\n    void build() {\r\n        if (s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m + 1, e);\r\n        }\r\n    }\r\n\r\n    void propagate() {\r\n        if (l == nullptr)\r\n            build();\r\n        if (lazy == 0)\r\n            return;\r\n        n += (e - s + 1) * lazy;\r\n        if (s != e) {\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\n    ll query(ll a, ll b) {\r\n        if (l == nullptr)\r\n            build();\r\n        propagate();\r\n        if (a == s && b == e)\r\n            return n;\r\n        else if (b <= m)\r\n            return l->query(a, b);\r\n        else if (a > m)\r\n            return r->query(a, b);\r\n        else\r\n            return l->query(a, m) + r->query(m + 1, b);\r\n    }\r\n\r\n    void update(ll a, ll b, ll v) {\r\n        if (l == nullptr)\r\n            build();\r\n        if (a == s && b == e)\r\n            lazy += v;\r\n        else {\r\n            if (b <= m)\r\n                l->update(a, b, v);\r\n            else if (a > m)\r\n                r->update(a, b, v);\r\n            else\r\n                l->update(a, m, v), r->update(m + 1, b, v);\r\n            l->propagate();\r\n            r->propagate();\r\n            n = l->n + r->n;\r\n        }\r\n    }\r\n} *root;\r\n\r\nint main() {\r\n    ll n, q, t, a, b, c;\r\n    cin >> n >> q;\r\n    node* root = new node(1, n);\r\n    while (q--) {\r\n        cin >> t;\r\n        if (t == 2) {\r\n            cin >> a >> b;\r\n            cout << root->query(a, b) << \"\\n\";\r\n        }\r\n        else {\r\n            cin >> a >> b >> c;\r\n            root->update(a, b, c);\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "helloworld",
        "id": 468740,
        "date": "2024-05-06 07:47:29",
        "code": "#include<bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nstruct node {\r\n    int s, e, m, val, lazy;\r\n    node *l, *r;\r\n    node(int x, int y) {\r\n        s = x, e = y;\r\n        if(s != e) {\r\n            m = (s + e) / 2, val = 0, lazy = 0;\r\n        }\r\n    }\r\n    void create() {\r\n        if(s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m + 1, e);\r\n        }\r\n    }\r\n    void prop() {\r\n        if(lazy != 0) {\r\n            l->val += lazy * (m - s + 1);\r\n            l->lazy += lazy;\r\n            r->val += lazy * (e - m);\r\n            r->lazy += lazy;\r\n            lazy = 0;\r\n        }\r\n    }\r\n    void upd(int x, int y, int k) {\r\n        if(l == nullptr) create();\r\n        if(x > e || y < s) return;\r\n        if(x <= s && y >= e) {\r\n            val += k * (e - s + 1);\r\n            lazy += k;\r\n            return;\r\n        }\r\n        prop();\r\n        l->upd(x, y, k);\r\n        r->upd(x, y, k);\r\n        val = l->val + r->val;\r\n    }\r\n    int qry(int x, int y) {\r\n        if(l == nullptr) create();\r\n        if(x > e || y < s) return 0;\r\n        if(x <= s && y >= e) return val;\r\n        prop();\r\n        return l->qry(x, y) + r->qry(x, y);\r\n    }\r\n} *root;\r\nsigned main() {\r\n    int n, q;\r\n    cin >> n >> q;\r\n    root = new node(1, n);\r\n    for(int i = 0; i < q; i++) {\r\n        int t;\r\n        cin >> t;\r\n        if(t == 1) {\r\n            int x, y, k;\r\n            cin >> x >> y >> k;\r\n            root->upd(x, y, k);\r\n        }\r\n        else {\r\n            int x, y;\r\n            cin >> x >> y;\r\n            cout << root->qry(x, y) << \"\\n\";\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "Kiameimon",
        "id": 443381,
        "date": "2024-03-14 14:31:18",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ld = long double;\r\nusing ll = long long;\r\nusing u64 =  uint64_t;\r\nusing u128 = __uint128_t;\r\nusing pii = pair<int,int>;\r\nusing pll = pair<ll,ll>;\r\nusing pdd = pair<ld, ld>;\r\nusing intpt = complex<u64>;\r\nusing llpt = complex<ll>;\r\nusing ldpt = complex<ld>;\r\n#define getchar_unlocked getchar\r\n#define dbg(v)\\\r\n\tcout << \"Line(\" << __LINE__ << \") -> \" << #v << \" = \" << (v) << endl;\r\n\r\nconst ll ID = 0; //replace with identity (do the same for U if U != T)\r\nstruct node{\r\n\tusing T = ll; // replace with type of value\r\n\tusing U = ll; // replace with type of update\r\n\tnode *left, *right;\r\n\tint S, E, M;\r\n\tT val; U lazy;\r\n\tnode(int s, int e) : S(s), E(e), val(ID), lazy(ID) {\r\n\t\tM = (S+E) >> 1;\r\n\t\tleft = right = nullptr;\r\n\t}\r\n\tnode(auto first, auto last, int s = 0) : S(s), E(last-first+s), lazy(ID) {\r\n\t\tif(S == E){\r\n\t\t\tval = *first;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tM = (S+E) >> 1;\r\n\t\tauto mid = first+M-S;\r\n\t\tleft = new node(first, mid, S);\r\n\t\tright = new node(mid+1, last, M+1);\r\n\t\tval = op(left->val, right->val);\r\n\t}\r\n\tstatic T op(T a, T b){\r\n\t\treturn a+b; // replace operation as necessary\r\n\t}\r\n\tvoid op1(U v){\r\n\t\tval += v*(E-S+1); // replace operation as necessary\r\n\t\tlazy += v; // replace operation as necessary\r\n\t}\r\n\tvoid prop(){\r\n\t\tif(left == nullptr){\r\n\t\t\tleft = new node(S, M);\r\n\t\t\tright = new node(M+1, E);\r\n\t\t}\r\n\t\tif(lazy == ID) return;\r\n\t\tleft->op1(lazy);\r\n\t\tright->op1(lazy);\r\n\t\tlazy = ID;\r\n\t}\r\n\tT qry(int l, int r){\r\n\t\tif(l > E || r < S) return ID; // replace 0 with identity\r\n\t\tif(l <= S && E <= r) return val;\r\n\t\tprop();\r\n\t\treturn op(left->qry(l, r), right->qry(l, r));\r\n\t}\r\n\tvoid upd(int l, int r, U v){\r\n\t\tif(l > E || r < S) return;\r\n\t\tif(l <= S && E <= r) return op1(v);\r\n\t\tprop();\r\n\t\tleft->upd(l, r, v);\r\n\t\tright->upd(l, r, v);\r\n\t\tval = op(left->val, right->val);\r\n\t}\r\n};\r\n\t\r\nsigned main() {\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n\t\r\n\tint n, tc; cin >> n >> tc;\r\n\tnode *segtree = new node(1, n);\r\n\twhile(tc--){\r\n\t\tint q; cin >> q;\r\n\t\tif(q == 1){\r\n\t\t\tint l, r, v; cin >> l >> r >> v;\r\n\t\t\tsegtree->upd(l, r, v);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint l, r; cin >> l >> r;\r\n\t\t\tcout<< segtree->qry(l, r) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n"
    },
    {
        "username": "ZivTheONe",
        "id": 438716,
        "date": "2024-03-07 18:35:56",
        "code": "#include <iostream>\r\n#include <bits/stdc++.h>\r\n#include <map>\r\n#include <vector>\r\n#include <cmath>\r\n#include <algorithm>\r\n#include <unistd.h>     //required for usleep()\r\n\r\n\r\nusing namespace std;\r\n\r\ntypedef unsigned long long ull;\r\ntypedef long long ll;\r\ntypedef unsigned int uint;\r\ntypedef pair<int, int> pii;\r\ntypedef pair<ll, ll> pll;\r\ntypedef tuple<ll, ll, ll> tll;\r\ntypedef vector<ll> vll;\r\ntypedef vector<int> vi;\r\n\r\nconst ll S =  5, MOD = 1e9 + 7;\r\n\r\n#define LSOne(S) ((S) & -(S))                    // the key operation\r\nstruct Node {\r\n    ll val = 0;\r\n    Node* left  = NULL;\r\n    Node* right = NULL;\r\n};\r\n\r\nclass FenwickTree {\r\n    private:\r\n    Node startPoint;\r\n    int S;\r\n    void changeNode(Node* &curr, Node* &ptr){\r\n        if (!ptr) ptr = new Node();\r\n        curr = ptr;\r\n    }\r\n    ll check(ll targ, ll v){\r\n        Node* curr = &startPoint;\r\n        ll l = 1, r = S, mid, res = 0;\r\n        while (r >= l){\r\n            mid = (l + r) / 2;\r\n            if (mid >= targ){\r\n                curr -> val += v, r = mid - 1; \r\n                if (mid == targ) {res += curr -> val; break;}\r\n                changeNode(curr, curr -> left);\r\n            }\r\n            else{\r\n                res += curr -> val, l = mid + 1;\r\n                changeNode(curr, curr -> right);\r\n            } \r\n        }\r\n        return res;\r\n    }\r\n    public:\r\n    FenwickTree(int m) { S = m + 4; } \r\n    void update(ll targ, ll v = 1) {check(targ, v);}\r\n    ll   rsq(ll targ)              {return check(targ, 0);}\r\n};\r\n\r\nclass RURQ  {                                    // RURQ variant\r\nprivate:                                         // needs two helper FTs\r\n  FenwickTree rupq, purq;                              // one PURQ\r\npublic:\r\n  RURQ(int m) : rupq(FenwickTree(m)), purq(FenwickTree(m)) {} // initialization\r\n  void range_update(ll ui, ll uj, ll v) {\r\n    rupq.update(ui, v);  rupq.update(uj + 1, -v);              // [ui, ui+1, .., uj] +v\r\n    purq.update(ui, v*(ui-1));                   // -(ui-1)*v before ui\r\n    purq.update(uj+1, -v*uj);                    // +(uj-ui+1)*v after uj\r\n  }\r\n  ll rsq(int j) {return rupq.rsq( j )*j -  purq.rsq( j );}\r\n  ll rsq(int i, int j) { return rsq(j) - rsq(i-1); } // standard\r\n};\r\n\r\nclass Solution {\r\n    public:\r\n    int N, Q, opt, l, r, k;\r\n\tvoid seggyTree2(){\r\n        cin >> N >> Q;\r\n        RURQ rurq(N);\r\n        for (; Q > 0; Q--){\r\n            cin >> opt >> l >> r;\r\n            if (opt == 1) {cin >> k; rurq.range_update(l, r, k);}\r\n            else          {cout << rurq.rsq(l, r) << '\\n';}\r\n        }\r\n    }\r\n};\r\n\r\nint main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(0), cout.tie(0);\r\n\r\n    Solution p;\r\n    p.seggyTree2();\r\n}"
    },
    {
        "username": "ZivTheONe",
        "id": 438715,
        "date": "2024-03-07 18:12:38",
        "code": "#include <iostream>\r\n#include <bits/stdc++.h>\r\n#include <map>\r\n#include <vector>\r\n#include <cmath>\r\n#include <algorithm>\r\n#include <unistd.h>     //required for usleep()\r\n\r\n\r\nusing namespace std;\r\n\r\ntypedef unsigned long long ull;\r\ntypedef long long ll;\r\ntypedef unsigned int uint;\r\ntypedef pair<int, int> pii;\r\ntypedef pair<ll, ll> pll;\r\ntypedef tuple<ll, ll, ll> tll;\r\ntypedef vector<ll> vll;\r\ntypedef vector<int> vi;\r\n\r\nconst ll S =  5, MOD = 1e9 + 7;\r\n\r\n#define LSOne(S) ((S) & -(S))                    // the key operation\r\nstruct Node {\r\n    ll val = 0;\r\n    Node* left  = NULL;\r\n    Node* right = NULL;\r\n};\r\n\r\nclass FenwickTree {\r\n    private:\r\n    Node startPoint;\r\n    int S;\r\n    void changeNode(Node* &curr, Node* &ptr){\r\n        if (!ptr) ptr = new Node();\r\n        curr = ptr;\r\n    }\r\n    ll check(ll targ, ll v){\r\n        Node* curr = &startPoint;\r\n        ll l = 1, r = S, mid, res = 0;\r\n        while (r >= l){\r\n            mid = (l + r) / 2;\r\n            if (mid >= targ){\r\n                curr -> val += v, r = mid - 1; \r\n                if (mid == targ) {res += curr -> val; break;}\r\n                changeNode(curr, curr -> left);\r\n            }\r\n            else{\r\n                res += curr -> val, l = mid + 1;\r\n                changeNode(curr, curr -> right);\r\n            } \r\n        }\r\n        return res;\r\n    }\r\n    public:\r\n    FenwickTree(int m) { S = m + 4; } \r\n    void update(ll targ, ll v = 1) {check(targ, v);}\r\n    ll   rsq(ll targ)              {return check(targ, 0);}\r\n};\r\n\r\nclass RUPQ {                                     // RUPQ variant\r\nprivate:\r\n  FenwickTree ft;                                // internally use PURQ FT\r\npublic:\r\n  RUPQ(int m) : ft(FenwickTree(m)) {}\r\n  void range_update(ll ui, ll uj, ll v) {\r\n    ft.update(ui, v);                            // [ui, ui+1, .., m] +v\r\n    ft.update(uj+1, -v);                         // [uj+1, uj+2, .., m] -v\r\n  }                                              // [ui, ui+1, .., uj] +v\r\n  ll point_query(int i) { return ft.rsq(i); }    // rsq(i) is sufficient\r\n};\r\n\r\nclass RURQ  {                                    // RURQ variant\r\nprivate:                                         // needs two helper FTs\r\n  RUPQ rupq;                                     // one RUPQ and\r\n  FenwickTree purq;                              // one PURQ\r\npublic:\r\n  RURQ(int m) : rupq(RUPQ(m)), purq(FenwickTree(m)) {} // initialization\r\n  void range_update(ll ui, ll uj, ll v) {\r\n    rupq.range_update(ui, uj, v);                // [ui, ui+1, .., uj] +v\r\n    purq.update(ui, v*(ui-1));                   // -(ui-1)*v before ui\r\n    purq.update(uj+1, -v*uj);                    // +(uj-ui+1)*v after uj\r\n  }\r\n  ll rsq(int j) {\r\n    return rupq.point_query( j )*j -               // optimistic calculation\r\n           purq.rsq( j );                          // cancelation factor\r\n  }\r\n  ll rsq(int i, int j) { return rsq(j) - rsq(i-1); } // standard\r\n};\r\n\r\nclass Solution {\r\n    public:\r\n    int N, Q, opt, l, r, k;\r\n\tvoid seggyTree2(){\r\n        cin >> N >> Q;\r\n        RURQ rurq(N);\r\n        for (; Q > 0; Q--){\r\n            cin >> opt >> l >> r;\r\n            if (opt == 1) {cin >> k; rurq.range_update(l, r, k);}\r\n            else          {cout << rurq.rsq(l, r) << '\\n';}\r\n        }\r\n    }\r\n};\r\n\r\nint main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(0), cout.tie(0);\r\n\r\n    Solution p;\r\n    p.seggyTree2();\r\n}"
    },
    {
        "username": "ZhongDing",
        "id": 434355,
        "date": "2024-03-01 09:46:38",
        "code": "\r\n#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nstruct Node {\r\n    long long start, end, sum, lazy;\r\n    Node *left, *right;\r\n\r\n    Node(long long s, long long e): start(s), end(e), sum(0), lazy(0), left(nullptr), right(nullptr) {}\r\n};\r\n\r\nclass LazySegmentTree {\r\nprivate:\r\n    Node* root;\r\n\r\n    void updateRange(Node* node, long long us, long long ue, long long diff) {\r\n        // First, check if there are any pending updates for this node\r\n        if (node->lazy != 0) {\r\n            // Apply the pending updates\r\n            node->sum += (node->end - node->start + 1) * node->lazy;\r\n            // Propagate the update to the children\r\n            if (node->start != node->end) { // Not a leaf node\r\n                if (!node->left) node->left = new Node(node->start, (node->start + node->end) / 2);\r\n                if (!node->right) node->right = new Node((node->start + node->end) / 2 + 1, node->end);\r\n                node->left->lazy += node->lazy;\r\n                node->right->lazy += node->lazy;\r\n            }\r\n            node->lazy = 0;\r\n        }\r\n\r\n        // Out of range\r\n        if (node->start > ue || node->end < us) return;\r\n\r\n        // Current segment is totally within range [us, ue]\r\n        if (node->start >= us && node->end <= ue) {\r\n            node->sum += (node->end - node->start + 1) * diff;\r\n            if (node->start != node->end) { // Not a leaf node\r\n                if (!node->left) node->left = new Node(node->start, (node->start + node->end) / 2);\r\n                if (!node->right) node->right = new Node((node->start + node->end) / 2 + 1, node->end);\r\n                node->left->lazy += diff;\r\n                node->right->lazy += diff;\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Otherwise, propagate the updates to children and then update the current sum\r\n        if (!node->left) node->left = new Node(node->start, (node->start + node->end) / 2);\r\n        if (!node->right) node->right = new Node((node->start + node->end) / 2 + 1, node->end);\r\n        updateRange(node->left, us, ue, diff);\r\n        updateRange(node->right, us, ue, diff);\r\n        node->sum = node->left->sum + node->right->sum;\r\n    }\r\n\r\n    long long getSum(Node* node, long long qs, long long qe) {\r\n        if (!node) return 0; // Empty node\r\n\r\n        // Apply any pending lazy updates\r\n        if (node->lazy != 0) {\r\n            node->sum += (node->end - node->start + 1) * node->lazy;\r\n            if (node->start != node->end) { // Not a leaf node\r\n                if (!node->left) node->left = new Node(node->start, (node->start + node->end) / 2);\r\n                if (!node->right) node->right = new Node((node->start + node->end) / 2 + 1, node->end);\r\n                node->left->lazy += node->lazy;\r\n                node->right->lazy += node->lazy;\r\n            }\r\n            node->lazy = 0;\r\n        }\r\n\r\n        // Total overlap\r\n        if (node->start >= qs && node->end <= qe) return node->sum;\r\n\r\n        // No overlap\r\n        if (node->end < qs || node->start > qe) return 0;\r\n\r\n        // Partial overlap, check children\r\n        return getSum(node->left, qs, qe) + getSum(node->right, qs, qe);\r\n    }\r\n\r\npublic:\r\n    LazySegmentTree(long long size) {\r\n        root = new Node(0, size - 1);\r\n    }\r\n\r\n    void updateRange(long long us, long long ue, long long diff) {\r\n        updateRange(root, us, ue, diff);\r\n    }\r\n\r\n    long long getSum(long long qs, long long qe) {\r\n        return getSum(root, qs, qe);\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q;\r\n\tcin>>N>>Q;\r\n    LazySegmentTree st(1e9+2);\r\n    for (long long i = 0;i<Q;i++){\r\n\t\tlong long q;\r\n\t\tcin>>q;\r\n\t\tif (q == 1){\r\n\t\t\tlong long l,r,k;\r\n\t\t\tcin>>l>>r>>k;\r\n\t\t\tst.updateRange(l,r,k);\r\n\t\t}\r\n\t\tif (q == 2){\r\n\t\t\tlong long l,r;\r\n\t\t\tcin>>l>>r;\r\n\t\t\tcout<<st.getSum(l,r)<<endl;\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "Hhw48",
        "id": 429016,
        "date": "2024-02-23 23:35:05",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node{\r\n\tint s, e, m;\r\n\tint v = 0, lz = 0; node *l = nullptr, *r = nullptr;\r\n\t\r\n\tnode(int _s, int _e){\r\n\t\ts = _s, e = _e, m = s + (e-s)/2;\r\n\t}\r\n\t\r\n\tvoid makeChild(){\r\n\t\tif (s != e && l == nullptr) l = new node(s, m), r = new node(m+1, e);\r\n\t}\r\n\t\r\n\tvoid prop(){\r\n\t\tv += lz * (e-s+1);\r\n\t\tmakeChild();\r\n\t\tif (s != e) l->lz += lz, r->lz += lz; \r\n\t\t\r\n\t\tlz = 0;\t\t\r\n\t}\r\n\t\r\n\tvoid update(int qs, int qe, int k){\r\n\t\tmakeChild();\r\n\t\tif (qs == s && e == qe){\r\n\t\t\tlz += k;\r\n\t\t\tprop();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tprop();\r\n\t\tif (qe <= m){\r\n\t\t\tl->update(qs, qe, k);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\tr->update(qs, qe, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tl->update(qs, m, k);\r\n\t\t\tr->update(m+1, qe, k);\r\n\t\t}\r\n\t\t\r\n\t\tl->prop(); r->prop();\r\n\t\tv = l->v + r->v;\r\n\t}\r\n\t\r\n\tint query(int qs, int qe){\r\n\t\tmakeChild(); prop();\r\n\t\tif (qs == s && e == qe){\r\n\t\t\treturn v;\r\n\t\t}\r\n\t\t\r\n\t\tif (qe <= m){\r\n\t\t\treturn l->query(qs, qe);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\treturn r->query(qs, qe);\r\n\t\t}\r\n\t\telse{\r\n\t\t\treturn l->query(qs, m) + r->query(m+1, qe);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nmain(){\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint n, q; cin >> n >> q;\r\n\tnode *st = new node(1, n);\r\n\twhile(q--){\r\n\t\tint x,a,b,c;\r\n\t\tcin>>x>>a>>b;\r\n\t\tif(x==1){\r\n\t\t\tcin>>c;\r\n\t\t\tst->update(a,b,c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout<<st->query(a,b)<<'\\n';\r\n\t\t}\r\n\t}\r\n}\r\n\r\n"
    },
    {
        "username": "funnymagicman",
        "id": 428207,
        "date": "2024-02-23 18:52:34",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node{\r\n\tint s, e, m;\r\n\tint v = 0, lz = 0; node *l = nullptr, *r = nullptr;\r\n\t\r\n\tnode(int _s, int _e){\r\n\t\ts = _s, e = _e, m = s + (e-s)/2;\r\n\t}\r\n\t\r\n\tvoid makeChild(){\r\n\t\tif (s != e && l == nullptr) l = new node(s, m), r = new node(m+1, e);\r\n\t}\r\n\t\r\n\tvoid prop(){\r\n\t\tv += lz * (e-s+1);\r\n\t\tmakeChild();\r\n\t\tif (s != e) l->lz += lz, r->lz += lz; \r\n\t\t\r\n\t\tlz = 0;\t\t\r\n\t}\r\n\t\r\n\tvoid update(int qs, int qe, int k){\r\n\t\tmakeChild();\r\n\t\tif (qs == s && e == qe){\r\n\t\t\tlz += k;\r\n\t\t\tprop();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tprop();\r\n\t\tif (qe <= m){\r\n\t\t\tl->update(qs, qe, k);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\tr->update(qs, qe, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tl->update(qs, m, k);\r\n\t\t\tr->update(m+1, qe, k);\r\n\t\t}\r\n\t\t\r\n\t\tl->prop(); r->prop();\r\n\t\tv = l->v + r->v;\r\n\t}\r\n\t\r\n\tint query(int qs, int qe){\r\n\t\tmakeChild(); prop();\r\n\t\tif (qs == s && e == qe){\r\n\t\t\treturn v;\r\n\t\t}\r\n\t\t\r\n\t\tif (qe <= m){\r\n\t\t\treturn l->query(qs, qe);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\treturn r->query(qs, qe);\r\n\t\t}\r\n\t\telse{\r\n\t\t\treturn l->query(qs, m) + r->query(m+1, qe);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nmain(){ ios_base::sync_with_stdio(0); cin.tie(0);\r\n\tint n, q; cin >> n >> q;\r\n\t\r\n\tnode *st = new node(1, n);\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint com; cin >> com;\r\n\t\t\r\n\t\tif (com == 1){\r\n\t\t\tint l, r, k; cin >> l >> r >> k;\r\n\t\t\tst->update(l, r, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint l, r; cin >> l >> r;\r\n\t\t\tcout << st->query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "funnymagicman",
        "id": 428206,
        "date": "2024-02-23 18:52:17",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node{\r\n\tint s, e, m;\r\n\tint v = 0, lz = 0; node *l = nullptr, *r = nullptr;\r\n\t\r\n\tnode(int _s, int _e){\r\n\t\ts = _s, e = _e, m = s + (e-s)/2;\r\n\t}\r\n\t\r\n\tvoid makeChild(){\r\n\t\tif (s != e && l == nullptr) l = new node(s, m), r = new node(m+1, e);\r\n\t}\r\n\t\r\n\tvoid prop(){\r\n\t\tv += lz * (e-s+1);\r\n\t\tmakeChild();\r\n\t\tif (s != e) l->lz += lz, r->lz += lz; \r\n\t\t\r\n\t\tlz = 0;\t\t\r\n\t}\r\n\t\r\n\tvoid update(int qs, int qe, int k){\r\n\t\tmakeChild();\r\n\t\tif (qs == s && e == qe){\r\n\t\t\tlz += k;\r\n\t\t\tprop();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tprop();\r\n\t\tif (qe <= m){\r\n\t\t\tl->update(qs, qe, k);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\tr->update(qs, qe, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tl->update(qs, m, k);\r\n\t\t\tr->update(m+1, qe, k);\r\n\t\t}\r\n\t\t\r\n\t\tl->prop(); r->prop();\r\n\t\tv = l->v + r->v;\r\n\t}\r\n\t\r\n\tint query(int qs, int qe){\r\n\t\tmakeChild(); prop();\r\n\t\tif (qs == s && e == qe){\r\n\t\t\treturn v;\r\n\t\t}\r\n\t\t\r\n\t\tif (qe <= m){\r\n\t\t\treturn l->query(qs, qe);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\treturn r->query(qs, qe);\r\n\t\t}\r\n\t\telse{\r\n\t\t\treturn l->query(qs, m) + r->query(m+1, qe);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nmain(){\r\n\tint n, q; cin >> n >> q;\r\n\t\r\n\tnode *st = new node(1, n);\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint com; cin >> com;\r\n\t\t\r\n\t\tif (com == 1){\r\n\t\t\tint l, r, k; cin >> l >> r >> k;\r\n\t\t\tst->update(l, r, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint l, r; cin >> l >> r;\r\n\t\t\tcout << st->query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "funnymagicman",
        "id": 428202,
        "date": "2024-02-23 18:48:47",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node{\r\n\tint s, e, m;\r\n\tint v = 0, lz = 0; node *l = nullptr, *r = nullptr;\r\n\t\r\n\tnode(int _s, int _e){\r\n\t\ts = _s, e = _e, m = (s+e)/2;\r\n\t}\r\n\t\r\n\tvoid makeChild(){\r\n\t\tif (s != e && l == nullptr) l = new node(s, m), r = new node(m+1, e);\r\n\t}\r\n\t\r\n\tvoid prop(){\r\n\t\tv += lz * (e-s+1);\r\n\t\tmakeChild();\r\n\t\tif (s != e) l->lz += lz, r->lz += lz; \r\n\t\t\r\n\t\tlz = 0;\t\t\r\n\t}\r\n\t\r\n\tvoid update(int qs, int qe, int k){\r\n\t\tmakeChild();\r\n\t\tif (qs == s && e == qe){\r\n\t\t\tlz += k;\r\n\t\t\tprop();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tprop();\r\n\t\tif (qe <= m){\r\n\t\t\tl->update(qs, qe, k);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\tr->update(qs, qe, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tl->update(qs, m, k);\r\n\t\t\tr->update(m+1, qe, k);\r\n\t\t}\r\n\t\t\r\n\t\tl->prop(); r->prop();\r\n\t\tv = l->v + r->v;\r\n\t}\r\n\t\r\n\tint query(int qs, int qe){\r\n\t\tmakeChild(); prop();\r\n\t\tif (qs == s && e == qe){\r\n\t\t\treturn v;\r\n\t\t}\r\n\t\t\r\n\t\tif (qe <= m){\r\n\t\t\treturn l->query(qs, qe);\r\n\t\t}\r\n\t\telse if (qs > m){\r\n\t\t\treturn r->query(qs, qe);\r\n\t\t}\r\n\t\telse{\r\n\t\t\treturn l->query(qs, m) + r->query(m+1, qe);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nmain(){\r\n\tint n, q; cin >> n >> q;\r\n\t\r\n\tnode *st = new node(1, n);\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint com; cin >> com;\r\n\t\t\r\n\t\tif (com == 1){\r\n\t\t\tint l, r, k; cin >> l >> r >> k;\r\n\t\t\tst->update(l, r, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint l, r; cin >> l >> r;\r\n\t\t\tcout << st->query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "YEethui",
        "id": 427373,
        "date": "2024-02-23 11:34:37",
        "code": "// live segtree implementation in school during math\r\n\r\n#include <iostream>\r\n#define int long long\r\nusing namespace std;\r\n\r\nint n, m;\r\n\r\nstruct SEG\r\n{\r\n    int l, r, mid;\r\n    int v, lazy;\r\n    SEG *lptr, *rptr;\r\n    \r\n    SEG(int L, int R)\r\n    {\r\n        l=L; r=R; mid=(l+r)>>1;\r\n        v=lazy=0;\r\n        lptr=rptr=nullptr;\r\n    }\r\n    void build()\r\n    {\r\n        if (lptr==nullptr) lptr=new SEG(l, mid);\r\n        if (rptr==nullptr) rptr=new SEG(mid+1, r);\r\n    }\r\n    void update(int x, int y, int val)\r\n    {\r\n        if (l==x && r==y)\r\n        {\r\n            v+=val*(r-l+1);\r\n            lazy+=val;\r\n            return;\r\n        }\r\n        build();\r\n        prop();\r\n        if (y<=mid) lptr->update(x, y, val);\r\n        else if (x>=mid+1) rptr->update(x, y, val);\r\n        else\r\n        {\r\n            lptr->update(x, mid, val);\r\n            rptr->update(mid+1, y, val);\r\n        }\r\n        v=lptr->v+rptr->v;\r\n    }\r\n    int query(int x, int y)\r\n    {\r\n        if (l==x && r==y) return v;\r\n        build();\r\n        prop();\r\n        if (y<=mid) return lptr->query(x, y);\r\n        else if (x>=mid+1) return rptr->query(x, y);\r\n        else return lptr->query(x, mid)+rptr->query(mid+1, y);\r\n    }\r\n    void prop()\r\n    {\r\n        if (lazy==0) return;\r\n        lptr->v+=lazy*(mid-l+1);\r\n        lptr->lazy+=lazy;\r\n        rptr->v+=lazy*(r-mid);\r\n        rptr->lazy+=lazy;\r\n        lazy=0;\r\n    }\r\n} *seg;\r\n\r\nsigned main()\r\n{\r\n    cin>>n>>m;\r\n    \r\n    seg=new SEG(0, n-1);\r\n    while (m--)\r\n    {\r\n        int t; cin>>t;\r\n        if (t==1)\r\n        {\r\n            int l, r, val; cin>>l>>r>>val; l--; r--;\r\n            seg->update(l, r, val);\r\n        }\r\n        else\r\n        {\r\n            int l, r; cin>>l>>r; l--; r--;\r\n            cout<<seg->query(l, r)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "gelastropod",
        "id": 426250,
        "date": "2024-02-22 15:49:33",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node\r\n{\r\n\tint s, e, m, v, lazy;\r\n\tnode* l = NULL, * r = NULL;\r\n\r\n\tnode(int _s, int _e) : s(_s), e(_e), m((_s + _e) / 2), v(0), lazy(0) {}\r\n\r\n\tvoid prop()\r\n\t{\r\n\t\tif (s == e) return;\r\n\t\tif (l == nullptr)\r\n\t\t\tl = new node(s, m),\r\n\t\t\tr = new node(m + 1, e);\r\n\t\tl->v += lazy * (m - s + 1);\r\n\t\tr->v += lazy * (e - m);\r\n\t\tl->lazy += lazy;\r\n\t\tr->lazy += lazy;\r\n\t\tlazy = 0;\r\n\t}\r\n\r\n\tvoid upd(int a, int b, int k)\r\n\t{\r\n\t\tif (s > b || e < a)\r\n\t\t\treturn;\r\n\t\tif (s >= a && e <= b)\r\n\t\t{\r\n\t\t\tv += k * (e - s + 1);\r\n\t\t\tlazy += k;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tprop();\r\n\t\tl->upd(a, b, k);\r\n\t\tr->upd(a, b, k);\r\n\t\tv = l->v + r->v;\r\n\t}\r\n\r\n\tint rsq(int a, int b)\r\n\t{\r\n\t\tif (s > b || e < a)\r\n\t\t\treturn 0;\r\n\t\tif (s >= a && e <= b)\r\n\t\t\treturn v;\r\n\t\tprop();\r\n\t\treturn l->rsq(a, b) + r->rsq(a, b);\r\n\t}\r\n} *root;\r\n\r\nsigned main()\r\n{\r\n\tint N, Q, q, l, r, k;\r\n\tcin >> N >> Q;\r\n\troot = new node(1, N);\r\n\tfor (int i = 0; i < Q; i++)\r\n\t{\r\n\t\tcin >> q >> l >> r;\r\n\t\tif (q == 1)\r\n\t\t{\r\n\t\t\tcin >> k;\r\n\t\t\troot->upd(l, r, k);\r\n\t\t}\r\n\t\telse if (q == 2)\r\n\t\t{\r\n\t\t\tcout << root->rsq(l, r) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "Xiaoyang",
        "id": 423940,
        "date": "2024-02-20 18:33:39",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define fi first\r\n#define se second\r\n#define pii pair<long long,long long>\r\n#define pb push_back\r\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\r\n#define inf 0x3f3f3f3f\r\n#define rep(i,a,b) for (ll i=a;i<(b);i++)\r\n#define MP make_pair\r\n#define SZ(x) (ll(x.size()))\r\n#define ll long long\r\n#define mod 1000000007\r\n#define ALL(x) x.begin(),x.end()\r\n#define endl \"\\n\"\r\nvoid inc(ll &a,ll b) {a=(a+b)%mod;}\r\nvoid dec(ll &a,ll b) {a=(a-b+mod)%mod;}\r\nll lowbit(ll x) {return x&(-x);}\r\nll expo(ll base,ll p) {ll ret=1;while(p>0){if (p%2ll==1ll) ret=ret*base%mod;base=base*base%mod;p/=2ll;}return ret;}\r\n\r\nconst ll maxn=5e6+5;\r\nll lc[maxn],rc[maxn],tree[maxn],add[maxn];\r\nll tot=1,rt=1;\r\n\r\nvoid pushdown(ll c,ll cl, ll cr){\r\n\tif(lc[c]==-1)lc[c]=++tot;\r\n\tif(rc[c]==-1)rc[c]=++tot;\r\n\tll mid=cl+cr>>1;\r\n\ttree[lc[c]]+=add[c]*(mid-cl+1);\r\n\tadd[lc[c]]+=add[c];\r\n\ttree[rc[c]]+=add[c]*(cr-mid);\r\n\tadd[rc[c]]+=add[c];\r\n\tadd[c]=0;\r\n}\r\nvoid update(ll &c,ll cl, ll cr, ll l, ll r, ll val){\r\n\tif(c==-1)c=++tot;\r\n\tif(l<=cl and cr<=r){\r\n\t\ttree[c]+=val*(cr-cl+1);\r\n\t\tadd[c]+=val;\r\n\t\treturn;\r\n\t}\r\n\tpushdown(c,cl,cr);\r\n\tll mid=cl+cr>>1;\r\n\tif(l<=mid)update(lc[c],cl,mid,l,r,val);\r\n\tif(r>mid)update(rc[c],mid+1,cr,l,r,val);\r\n\ttree[c]=tree[lc[c]]+tree[rc[c]];\r\n\treturn;\r\n}\r\nll query(ll c,ll cl, ll cr, ll l, ll r){\r\n\tif(c==-1)return 0;\r\n\tif(l<=cl and cr<=r)return tree[c];\r\n\tpushdown(c,cl,cr);\r\n\tll mid=cl+cr>>1;\r\n\tll ans=0;\r\n\tif(l<=mid)ans+=query(lc[c],cl,mid,l,r);\r\n\tif(r>mid)ans+=query(rc[c],mid+1,cr,l,r);\r\n\treturn ans;\r\n}\r\nint main(){\r\n    ios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tmemset(lc,-1,sizeof lc);\r\n\tmemset(rc,-1,sizeof rc);\r\n\tll n,q;cin>>n>>q;\r\n\twhile(q--){\r\n\t\tll op;cin>>op;\r\n\t\tif(op==1){\r\n\t\t\tll l,r,k;cin>>l>>r>>k;\r\n\t\t\tupdate(rt,1,n,l,r,k);\r\n\t\t}else{\r\n\t\t\tll l,r;cin>>l>>r;\r\n\t\t\tcout<<query(1,1,n,l,r)<<endl;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n/*5 5\r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5*/\r\n"
    },
    {
        "username": "Tyx2019",
        "id": 422451,
        "date": "2024-02-19 08:10:27",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nstruct node{\r\n    int S, E, M, V, ladd;\r\n    node *l,*r;\r\n    node(int _S,int _E){\r\n        S = _S;\r\n        E = _E;\r\n        M = (S + E) >> 1;\r\n        V = ladd = 0;\r\n        l = r = NULL;\r\n    }\r\n    void prop(){\r\n        if(!l) l = new node(S, M);\r\n        if(!r) r = new node(M + 1, E);\r\n        if(ladd != 0){\r\n            l->ladd += ladd;\r\n            r->ladd += ladd;\r\n            l->V += ladd * (M - S + 1);\r\n            r->V += ladd * (E - M);\r\n            ladd = 0;\r\n        }   \r\n    }\r\n    void upd(int x, int y, int v){\r\n        //increase vals in range [x,y] by v\r\n        prop();\r\n        if(S == x && E == y){\r\n            ladd += v;\r\n            V += v * (E - S + 1);\r\n            return;\r\n        }\r\n        if(x > M) r->upd(x, y, v);\r\n        else if(y <= M) l->upd(x, y, v);\r\n        else{\r\n            l->upd(x, M, v);\r\n            r->upd(M + 1, y, v);\r\n        }\r\n        V = l->V + r->V; \r\n    }\r\n    int sum(int x, int y){\r\n        //sum elements in range [x,y];\r\n        prop();\r\n        if(S == x && E == y) return V;\r\n        if(x > M) return r->sum(x, y);\r\n        else if(y <= M) return l->sum(x,y);\r\n        else return l->sum(x, M) + r->sum(M + 1, y);\r\n    }\r\n}*seggs;\r\nsigned main(){\r\n    int N, Q;\r\n    cin >> N >> Q;\r\n    seggs = new node(1, N);\r\n    for(int i=0;i<Q;i++){\r\n        int op;\r\n        cin >> op;\r\n        if(op == 1){\r\n            int l, r, k;\r\n            cin >> l >> r >> k;\r\n            seggs->upd(l, r, k);\r\n        }\r\n        else{\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << seggs->sum(l, r) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "bribritt",
        "id": 422125,
        "date": "2024-02-18 15:55:41",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\nstruct node{\r\n    ll s, e, v, mid, lazy;\r\n    node *l, *r;\r\n    node(ll _s, ll _e) {\r\n        s = _s; e = _e; v = 0; mid = (s + e) / 2; lazy = 0;\r\n    }\r\n    void create() {\r\n        if(!l && s != e) {\r\n            l = new node(s, mid);\r\n            r = new node(mid + 1, e);\r\n        }\r\n    }\r\n    ll truevalue() {\r\n        return lazy * (e - s + 1) + v;\r\n    }\r\n    ll query(ll x, ll y) {\r\n        if(s == x && e == y) {return truevalue();}\r\n        create();\r\n        ll ans = (y - x + 1) * lazy;\r\n        if(y <= mid) return l->query(x, y) + ans;\r\n        else if(x > mid) return r->query(x, y) + ans;\r\n        else return l->query(x,mid) + r->query(mid + 1,y) + ans;\r\n    }\r\n    void update(ll x, ll y, ll u) {\r\n        if(x == s && y == e) {\r\n            lazy += u; return;\r\n        }\r\n        create();\r\n        if(y <= mid) l->update(x, y, u);\r\n        else if(x > mid) r->update(x, y, u);\r\n        else {l->update(x, mid, u); r->update(mid + 1, y, u);}\r\n        v = l->truevalue() + r->truevalue();\r\n    }\r\n} root = node(1,1e9);\r\n\r\nint main() {\r\n    ll N, Q, A, B, C; cin >> N >> Q; root.create();\r\n    while(Q--) {\r\n        cin >> A >> B >> C;\r\n        if(A == 1) {\r\n            ll k; cin >> k;\r\n            root.update(B, C, k);\r\n        } else {\r\n            cout << root.query(B, C) << \"\\n\";\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "Bulbasheen",
        "id": 409890,
        "date": "2024-02-04 12:50:47",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\n\r\nstruct Vertex {\r\n    int left, right;\r\n    ll lazy = 0;\r\n    ll sum = 0;\r\n    Vertex *lchild = nullptr, *rchild = nullptr;\r\n\r\n    Vertex(int lb, int rb){\r\n        left = lb;\r\n        right = rb;\r\n    }\r\n\r\n    void extend() {\r\n        if (!lchild && left + 1 < right) {\r\n            int t = (left + right) / 2;\r\n            lchild = new Vertex(left, t);\r\n            rchild = new Vertex(t, right);\r\n        }\r\n    }\r\n\r\n    void add(int l, int r, ll x) {\r\n        extend();\r\n        if (lazy != 0){\r\n            sum += lazy * (right - left);\r\n            if (lchild) {\r\n                lchild->lazy += lazy;\r\n                rchild->lazy += lazy;\r\n            }\r\n            lazy = 0;\r\n        }\r\n        sum += x * (right - left - max(l - left, 0) - max(right - r, 0));\r\n        if (lchild) {\r\n            if (l <= left and r >= right){\r\n                lchild->lazy += x;\r\n                rchild->lazy += x;\r\n            }\r\n            else{\r\n                if (max(lchild->left, l) < min(lchild->right, r))\r\n                    lchild->add(l, r, x);\r\n                if (max(rchild->left, l) < min(rchild->right, r))\r\n                    rchild->add(l, r, x);\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    ll get_sum(int lq, int rq) {\r\n        if (lazy != 0){\r\n            sum += lazy * (right - left);\r\n            extend();\r\n            if (lchild) {\r\n                lchild->lazy += lazy;\r\n                rchild->lazy += lazy;\r\n            }\r\n            lazy = 0;\r\n        }\r\n        if (lq <= left && right <= rq)\r\n            return sum;\r\n        if (max(left, lq) >= min(right, rq))\r\n            return 0;\r\n        extend();\r\n        return lchild->get_sum(lq, rq) + rchild->get_sum(lq, rq);\r\n    }\r\n};\r\n\r\nint main(){\r\n    int N, Q, a, b, c, d;\r\n    cin >> N >> Q;\r\n    Vertex tree = Vertex(0, N);\r\n    for (int i = 0; i < Q; i++){\r\n        cin >> a;\r\n        if (a-1) {\r\n            cin >> b >> c;\r\n            cout << tree.get_sum(b-1, c) << \"\\n\";\r\n        }\r\n        else{\r\n            cin >> b >> c >> d;\r\n            tree.add(b-1, c, d);\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "zyq69",
        "id": 409871,
        "date": "2024-02-04 12:30:28",
        "code": "#include <iostream>\r\nusing namespace std;\r\n#define int long long\r\nint N, Q;\r\n\r\nstruct node{\r\n\tint S, E, M;\r\n\tint lazy_add, val;\r\n\tnode *l, *r;\r\n\tnode (int _S, int _E): S(_S), E(_E), M((S+E)/2), l(NULL), r(NULL), lazy_add(0), val(0) {}\r\n    void prop(){\r\n        if(!l){\r\n            l = new node(S, M);\r\n            r = new node(M+1, E);\r\n        }\r\n        if(lazy_add){\r\n            l->val += (M - S + 1) * lazy_add;\r\n            r->val += (E - M) * lazy_add;\r\n            l->lazy_add += lazy_add;\r\n            r->lazy_add += lazy_add;\r\n            lazy_add = 0;\r\n        }\r\n    }\r\n\tvoid update (int x, int y, int v){\r\n\t\tif(x <= S && y >= E){\r\n\t\t\tval += v*(E-S+1);\r\n\t\t\tlazy_add += v;\r\n\t\t\treturn;\r\n\t\t}\r\n        prop();\r\n\t\tif(y <= M) l->update(x, y, v);\r\n\t\telse if(x >= M+1) r->update(x, y, v);\r\n\t\telse{\r\n\t\t\tl->update(x, M, v);\r\n\t\t\tr->update(M+1, y, v);\r\n\t\t}\r\n\t\tval = l->val + r->val;\r\n\t}\r\n\tint query(int x, int y){\r\n\t\tif(x <= S && E <= y){\r\n\t\t\treturn val;\r\n\t\t}\r\n        prop();\r\n\t\tif(y <= M) return l->query(x, y);\r\n\t\tif(x >= M+1) return r->query(x, y);\r\n\t\treturn l->query(x, M) + r->query(M+1, y);\r\n\t}\r\n}*root;\r\n\r\nint32_t main() {\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tcin >> N >> Q;\r\n\troot = new node(1, N);\r\n\twhile (Q--) {\r\n\t\tint op, l, r, k;\r\n\t\tcin >> op >> l >> r;\r\n\t\tif (op == 1) {\r\n\t\t\tcin >> k;\r\n\t\t\troot->update(l, r, k);\r\n\t\t} else {\r\n\t\t\tcout << root->query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}"
    },
    {
        "username": "jxlau",
        "id": 402770,
        "date": "2024-01-26 15:27:45",
        "code": "#include <iostream>\r\n#define int long long\r\n\r\nusing namespace std;\r\n\r\nstruct node {\r\n    node *l, *r;\r\n    int s, m, e;\r\n    int val, lazyadd;\r\n    \r\n    node (int ss, int ee) {\r\n        s = ss;\r\n        e = ee;\r\n        m = (s + e) / 2;\r\n        val = lazyadd = 0;\r\n        l = r = NULL;\r\n    }\r\n    \r\n    int value() {\r\n        if (s == e) return val + lazyadd;\r\n        if (l == NULL) l = new node(s, m);\r\n        if (r == NULL) r = new node(m+1, e);\r\n        val += lazyadd * (e-s + 1);\r\n        l->lazyadd += lazyadd;\r\n        r->lazyadd += lazyadd;\r\n        lazyadd = 0;\r\n        return val;\r\n    }\r\n    \r\n    void update(int x, int y, int v) {\r\n        value();\r\n        \r\n        if (s == x && e == y) {lazyadd += v; return;};\r\n        if (x > m) r->update(x, y, v);\r\n        else if (y <= m) l->update(x, y, v);\r\n        else l->update(x, m, v), r->update(m+1, y, v);\r\n        \r\n        val = l->value() + r->value();\r\n    }\r\n    \r\n    int query(int x, int y) {\r\n        value();\r\n        if (s == x && e == y) {\r\n            return value();\r\n        }\r\n        \r\n        if (x > m) return r->query(x, y);\r\n        else if (y <= m) return l->query(x, y);\r\n        \r\n        return l->query(x, m) + r->query(m+1, y);\r\n    }\r\n} *st;\r\n\r\nint32_t main()\r\n{\r\n    int n, q, t, l, r, k;\r\n    cin >> n >> q;\r\n    st = new node(1, n);\r\n    for (int i = 0; i < q; i++) {\r\n        cin >> t >> l >> r;\r\n        \r\n        if (t == 1) {\r\n            cin >> k;\r\n            st->update(l, r, k);\r\n        } else if (t == 2) {\r\n            cout << st->query(l, r) << '\\n';\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "bribritt",
        "id": 402623,
        "date": "2024-01-26 14:40:59",
        "code": "// is this supposed to pass?\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef unordered_map<ll,ll> um;\r\n#define MAXN 1073741824 // 1 << 30\r\num ft1, ft2;\r\nll lsB(ll x) {return x & (-x);}\r\nll query(um &ft, ll x, ll y) {\r\n    if(x == 1) {\r\n        ll sum = 0;\r\n        for(; y; y -= lsB(y)) {sum += ft[y];}\r\n        return sum;\r\n    } else return query(ft, 1, y) - query(ft, 1, x-1);\r\n}\r\nvoid ptUpdate(um &ft, ll x, ll v) {\r\n    for(; x < MAXN; x += lsB(x)) ft[x] += v;\r\n}\r\nvoid RU(ll a, ll b, ll v) {\r\n    ptUpdate(ft1, a, v);\r\n    ptUpdate(ft2, a, -(a-1)*v);\r\n    ptUpdate(ft1, b + 1, -v);\r\n    ptUpdate(ft2, b + 1, b * v);\r\n}\r\nll RQ(ll a, ll b) {\r\n    if(a == 1) return query(ft1, 1, b) * b + query(ft2, 1, b);\r\n    else return RQ(1, b) - RQ(1, a - 1);\r\n}\r\nint main() {\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n\tint n, q; cin >> n >> q;\r\n\tfor(int l,r,k;q--;) {\r\n\t\tcin >> l;\r\n\t\tif(l==1) {\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\tRU(l,r,k);\r\n\t\t} else {\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << RQ(l,r) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "bribritt",
        "id": 402617,
        "date": "2024-01-26 14:39:08",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef unordered_map<ll,ll> um;\r\n#define MAXN 1210201069\r\num ft1, ft2;\r\nll lsB(ll x) {return x & (-x);}\r\nll query(um &ft, ll x, ll y) {\r\n    if(x == 1) {\r\n        ll sum = 0;\r\n        for(; y; y -= lsB(y)) {sum += ft[y];}\r\n        return sum;\r\n    } else return query(ft, 1, y) - query(ft, 1, x-1);\r\n}\r\nvoid ptUpdate(um &ft, ll x, ll v) {\r\n    for(; x < MAXN; x += lsB(x)) ft[x] += v;\r\n}\r\nvoid RU(ll a, ll b, ll v) {\r\n    ptUpdate(ft1, a, v);\r\n    ptUpdate(ft2, a, -(a-1)*v);\r\n    if(1) {\r\n        ptUpdate(ft1, b + 1, -v);\r\n        ptUpdate(ft2, b + 1, b * v);\r\n    }\r\n}\r\nll RQ(ll a, ll b) {\r\n    if(a == 1) return query(ft1, 1, b) * b + query(ft2, 1, b);\r\n    else return RQ(1, b) - RQ(1, a - 1);\r\n}\r\n\r\nint main() {\r\n\tint n, q; cin >> n >> q;\r\n\tfor(int l,r,k;q--;) {\r\n\t\tcin >> l;\r\n\t\tif(l==1) {\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\tRU(l,r,k);\r\n\t\t} else {\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << RQ(l,r) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "dsyz",
        "id": 396423,
        "date": "2024-01-17 22:38:57",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\n#define MAXN (1000005)\r\nstruct node{\r\n\tll s,e,m,v,lazy;\r\n\tnode *l = nullptr,*r = nullptr; //please remember to set to nullptr (if not it might RTE)\r\n\tnode(ll _s,ll _e){\r\n\t\ts = _s;\r\n\t\te = _e;\r\n\t\tm = (s + e) / 2;\r\n\t\tv = 0;\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(l == nullptr && s != e){\r\n\t\t\tl = new node(s,m);\r\n\t\t\tr = new node(m + 1,e);\r\n\t\t}\r\n\t}\r\n\tvoid propo(){\r\n\t\tcreate();\r\n\t\tif(lazy == 0){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tv += lazy * (e - s + 1);\r\n\t\tif(s != e){\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid update(ll x,ll y,ll nval){\r\n\t\tif(s == x && e == y) lazy += nval;\r\n\t\telse{\r\n\t\t\tcreate();\r\n\t\t\tif(x > m) r -> update(x,y,nval);\r\n\t\t\telse if(y <= m) l -> update(x,y,nval);\r\n\t\t\telse l -> update(x,m,nval), r -> update(m + 1,y,nval);\r\n\t\t\tl->propo(), r->propo();\r\n\t\t\tv = l->v + r->v;\r\n\t\t}\r\n\t}\r\n\tlong long query(ll x,ll y){\r\n\t\tcreate();\r\n\t\tpropo();\r\n\t\tif(s == x && e == y){\r\n\t\t\treturn v;\r\n\t\t}else{\r\n\t\t\tif(x > m) return r->query(x,y);\r\n\t\t\telse if(y <= m) return l->query(x,y);\r\n\t\t\telse return l->query(x,m) + r-> query(m + 1,y);\r\n\t\t}\r\n\t}\r\n} *root;\r\nint main() {\r\n\tios_base::sync_with_stdio(false);cin.tie(0);\r\n\tll N,Q;\r\n\tcin>>N>>Q;\r\n\troot = new node(0,N + 1);\r\n\tfor(ll i = 0;i < Q;i++){\r\n\t\tll a;\r\n\t\tcin>>a;\r\n\t\tif(a == 1){\r\n\t\t\tll L,R,k;\r\n\t\t\tcin>>L>>R>>k;\r\n\t\t\tL--, R--;\r\n\t\t\troot -> update(L,R,k);\r\n\t\t}else if(a == 2){\r\n\t\t\tll L,R;\r\n\t\t\tcin>>L>>R;\r\n\t\t\tL--, R--;\r\n\t\t\tcout<<root -> query(L,R)<<'\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "dsyz",
        "id": 396422,
        "date": "2024-01-17 22:38:42",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\n#define MAXN (10005)\r\nstruct node{\r\n\tll s,e,m,v,lazy;\r\n\tnode *l = nullptr,*r = nullptr; //please remember to set to nullptr (if not it might RTE)\r\n\tnode(ll _s,ll _e){\r\n\t\ts = _s;\r\n\t\te = _e;\r\n\t\tm = (s + e) / 2;\r\n\t\tv = 0;\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(l == nullptr && s != e){\r\n\t\t\tl = new node(s,m);\r\n\t\t\tr = new node(m + 1,e);\r\n\t\t}\r\n\t}\r\n\tvoid propo(){\r\n\t\tcreate();\r\n\t\tif(lazy == 0){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tv += lazy * (e - s + 1);\r\n\t\tif(s != e){\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid update(ll x,ll y,ll nval){\r\n\t\tif(s == x && e == y) lazy += nval;\r\n\t\telse{\r\n\t\t\tcreate();\r\n\t\t\tif(x > m) r -> update(x,y,nval);\r\n\t\t\telse if(y <= m) l -> update(x,y,nval);\r\n\t\t\telse l -> update(x,m,nval), r -> update(m + 1,y,nval);\r\n\t\t\tl->propo(), r->propo();\r\n\t\t\tv = l->v + r->v;\r\n\t\t}\r\n\t}\r\n\tlong long query(ll x,ll y){\r\n\t\tcreate();\r\n\t\tpropo();\r\n\t\tif(s == x && e == y){\r\n\t\t\treturn v;\r\n\t\t}else{\r\n\t\t\tif(x > m) return r->query(x,y);\r\n\t\t\telse if(y <= m) return l->query(x,y);\r\n\t\t\telse return l->query(x,m) + r-> query(m + 1,y);\r\n\t\t}\r\n\t}\r\n} *root;\r\nint main() {\r\n\tios_base::sync_with_stdio(false);cin.tie(0);\r\n\tll N,Q;\r\n\tcin>>N>>Q;\r\n\troot = new node(0,N + 1);\r\n\tfor(ll i = 0;i < Q;i++){\r\n\t\tll a;\r\n\t\tcin>>a;\r\n\t\tif(a == 1){\r\n\t\t\tll L,R,k;\r\n\t\t\tcin>>L>>R>>k;\r\n\t\t\tL--, R--;\r\n\t\t\troot -> update(L,R,k);\r\n\t\t}else if(a == 2){\r\n\t\t\tll L,R;\r\n\t\t\tcin>>L>>R;\r\n\t\t\tL--, R--;\r\n\t\t\tcout<<root -> query(L,R)<<'\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "hwy",
        "id": 393917,
        "date": "2024-01-13 11:01:39",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<ll, ll> pll;\r\ntypedef vector<ll> vll;\r\ntypedef vector<pll> vpll;\r\ntypedef vector<string> vs;\r\ntypedef vector<bool> vb;\r\ntypedef map<ll, ll> mll;\r\ntypedef set<ll> sll;\r\ntypedef queue<ll> qll;\r\ntypedef queue<pll> qpll;\r\n\r\n#define all(x) x.begin(), x.end()\r\n#define sz(x) (ll) x.size()\r\n#define fr front()\r\n#define bk back()\r\n#define pb push_back\r\n#define pf push_front\r\n#define fi first\r\n#define se second\r\n#define FOR(i, a, b, inc) for (ll i = a; i < b; i += inc)\r\n#define RFOR(i, a, b, inc) for (ll i = b - 1; i >= a; i -= inc)\r\n#define REP(i, a) FOR(i, 0, a, 1)\r\n#define RREP(i, a) RFOR(i, 0, a, 1)\r\n#define each(a, x) for (auto& a: x)\r\n\r\nstruct Node {\r\n    ll val, lazy, l, r, lf, rg;\r\n    Node(): val(0), lazy(0), lf(-1), rg(-1) {}\r\n};\r\n\r\nconst ll INF = 1e9;\r\nconst ll M = 1e9 + 7;\r\nNode segTree[(ll) 2e7];\r\nll cnt = 2;\r\n\r\nvoid propagate(ll idx) {\r\n    if (segTree[idx].lazy) {\r\n        segTree[idx].val += (segTree[idx].r - segTree[idx].l + 1) * segTree[idx].lazy;\r\n        ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n        \r\n        if (segTree[idx].lf == -1) {\r\n            segTree[idx].lf = cnt++;\r\n            segTree[segTree[idx].lf].l = segTree[idx].l;\r\n            segTree[segTree[idx].lf].r = mid;\r\n        }\r\n        \r\n        if (segTree[idx].rg == -1) {\r\n            segTree[idx].rg = cnt++;\r\n\r\n            segTree[segTree[idx].rg].l = mid + 1;\r\n            segTree[segTree[idx].rg].r = segTree[idx].r;\r\n        }\r\n\r\n        segTree[segTree[idx].lf].lazy += segTree[idx].lazy;\r\n        segTree[segTree[idx].rg].lazy += segTree[idx].lazy;\r\n        segTree[idx].lazy = 0;\r\n    }\r\n}\r\n\r\nvoid update(ll idx, ll x, ll y, ll v) {\r\n    if (segTree[idx].l == x && segTree[idx].r == y) {\r\n        segTree[idx].lazy += v;\r\n        propagate(idx);\r\n        return;\r\n    }\r\n\r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    if (x > mid) update(segTree[idx].rg, x, y, v);\r\n    else if (y <= mid) update(segTree[idx].lf, x, y, v);\r\n    else {\r\n        update(segTree[idx].lf, x, mid, v);\r\n        update(segTree[idx].rg, mid + 1, y, v);\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n    segTree[idx].val = segTree[segTree[idx].lf].val + segTree[segTree[idx].rg].val;\r\n}\r\n\r\nll query(ll idx, ll x, ll y) {\r\n    propagate(idx);\r\n\r\n    if (segTree[idx].l == x && segTree[idx].r == y) return segTree[idx].val;\r\n    \r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n\r\n    if (x > mid) return query(segTree[idx].rg, x, y);\r\n    else if (y <= mid) return query(segTree[idx].lf, x, y);\r\n    else return query(segTree[idx].lf, x, mid) + query(segTree[idx].rg, mid + 1, y);\r\n}\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\n    ll n, q; cin >> n >> q;\r\n\r\n    segTree[1].l = 1; segTree[1].r = n;//(ll) 1e9;\r\n\r\n    while (q--) {\r\n        ll t; cin >> t;\r\n        \r\n        if (t == 1) {\r\n            ll l, r, x; cin >> l >> r >> x;\r\n            update(1, l, r, x);\r\n        } else {\r\n            ll l, r; cin >> l >> r;\r\n            cout << query(1, l, r) << endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "Hijackedsoul",
        "id": 388308,
        "date": "2024-01-04 22:05:14",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node {\r\n    node *left, *right;\r\n    int S, E, val, lazy;\r\n    node(int _s, int _e) : S(_s), E(_e) {\r\n        left = right = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void prop(){\r\n        if(S == E) return;\r\n        int M = (S + E) / 2;\r\n        if(left == nullptr){ // no children\r\n            left = new node(S, M);\r\n            right = new node(M + 1, E);\r\n        }\r\n        if(lazy != 0){\r\n            // need to add lazy to left and right children\r\n            left->val += lazy * (M - S + 1);\r\n            left->lazy += lazy;\r\n            right->val += lazy * (E - M);\r\n            right->lazy += lazy;\r\n            // reset lazy tag\r\n            lazy = 0;\r\n        }\r\n    }\r\n    int qry(int l, int r) { // sum from index l to index r\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return 0;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            return val;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        return left->qry(l, r) + right->qry(l, r);\r\n    }\r\n    void upd(int l, int r, int v) {\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            // update the value of the node and the lazy tag, do not recurse\r\n            val += v * (E - S + 1); // all E - S + 1 nodes has their value increased\r\n            lazy += v;\r\n            return;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        left->upd(l, r, v);\r\n        right->upd(l, r, v);\r\n        // update current node value\r\n        val = left->val + right->val;\r\n    }\r\n} *root;\r\n// range add, range sum, lazy creation lazy propagation segment tree\r\n\r\nint32_t main(){\r\n\tint n, m;\r\n\tstd::cin >> n >> m;\r\n\tnode *root = new node (1, n);\r\n\tfor(int i=0; i<m; i++){\r\n\t\tint t;\r\n\t\tstd::cin >> t;\r\n\t\tif(t==1){\r\n\t\t\tint a, b, c;\r\n\t\t\tstd::cin >> a >> b >> c;\r\n\t\t\troot->upd(a, b, c);\r\n\t\t\t}\r\n\t\telse{\r\n\t\t\tint a, b;\r\n\t\t\tstd::cin >> a >> b;\r\n\t\t\tstd::cout << root->qry(a, b) << \"\\n\";\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n"
    },
    {
        "username": "peaceknight05",
        "id": 386326,
        "date": "2024-01-01 15:00:34",
        "code": "#include <iostream>\r\n#include <vector>\r\n#include <sstream>\r\n\r\nusing namespace std;\r\n\r\nstruct node {\r\n\tint s, e;\r\n\tlong long value = 0, lazy = 0;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\t\r\n\tnode(int sb, int eb) {\r\n\t\ts = sb;\r\n\t\te = eb;\r\n\t}\r\n\t\r\n\tvoid extend() {\r\n\t\tif (!l && s + 1 < e) {\r\n\t\t\tint m = (s + e) / 2;\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m, e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid propogate() {\r\n\t\tif (lazy != 0) {\r\n\t\t\tvalue += lazy * (e - s);\r\n\t\t\tif (l) {\r\n\t\t\t\tl->lazy += lazy;\r\n\t\t\t\tr->lazy += lazy;\r\n\t\t\t}\r\n\t\t\tlazy = 0;\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid upd(int su, int eu, long long k) {\r\n\t\textend();\r\n\t\tif (su <= s && e <= eu) {\r\n\t\t\tlazy += k;\r\n\t\t\tpropogate();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tpropogate();\r\n\t\tif (max(s, su) >= min(e, eu))\r\n\t\t\treturn;\r\n\t\tl->upd(su, eu, k);\r\n\t\tr->upd(su, eu, k);\r\n\t\tvalue = l->value + r->value;\r\n\t}\r\n\t\r\n\tlong long query(int sq, int eq) {\r\n\t\tif (sq <= s && e <= eq) {\r\n\t\t\textend();\r\n\t\t\tpropogate();\r\n\t\t\treturn value;\r\n\t\t}\r\n\t\tif (max(s, sq) >= min(e, eq))\r\n\t\t\treturn 0;\r\n\t\textend();\r\n\t\tpropogate();\r\n\t\treturn l->query(sq, eq) + r->query(sq, eq);\r\n\t}\r\n};\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    \r\n    int n, q;\r\n    cin >> n >> q;\r\n    node st(0, n);\r\n\r\n    for (int x = 0; x < q; x++) {\r\n        int com, a, b, c;\r\n        cin >> com >> a >> b;\r\n        a--;\r\n        if (com == 1) {\r\n            cin >> c;\r\n            st.upd(a, b, c);\r\n        } else {\r\n            cout << st.query(a, b) << '\\n';\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}"
    },
    {
        "username": "JIZHE",
        "id": 381712,
        "date": "2023-12-29 22:31:56",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define ll long long\r\n#define ld long double\r\n#define ull unsigned long long\r\n#define pi pair<int,int>\r\n#define vt vector\r\n#define mp make_pair\r\n#define pb push_back\r\n#define eb emplace_back\r\n#define fi first\r\n#define se second\r\n#define fast ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define sz(x) (int)x.size()\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\nsigned main() {\r\n\tfast\r\n\tint n,q;\r\n\tcin >> n >> q;\r\n\troot = new node(0,n);\r\n\tfor(int i=0;i<q;i++){\r\n\t\tint lol;\r\n\t\tcin >> lol;\r\n\t\tif(lol == 1){\r\n\t\t\tint l,r,k;\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\troot->add(l,r,k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint l,r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tint o = root->range_sum(l,r);\r\n\t\t\tcout << o << \"\\n\";\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "username": "jmuzhen",
        "id": 372471,
        "date": "2023-12-19 10:40:43",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll sum;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n\r\n    node(int _s, int _e, int A[] = nullptr) : s(_s), e(_e), sum(0), add_val(0), set_val(0),\r\n                                              l(nullptr), r(nullptr) {\r\n        if (A == nullptr) return;\r\n        if (s == e) sum = A[s];\r\n        else {\r\n            l = new node(s, (s + e) >> 1, A), r = new node((s + e + 2) >> 1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != nullptr) return;\r\n        int m = (s + e) >> 1;\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n    }\r\n\r\n    void self_set(ll v) {\r\n        set_val = v;\r\n        sum = v * (e - s + 1);\r\n        add_val = 0;\r\n    }\r\n\r\n    void self_add(ll v) {\r\n        if (set_val != 0) {\r\n            self_set(v + set_val);\r\n            return;\r\n        }\r\n        add_val += v;\r\n        sum += v * (e - s + 1);\r\n    }\r\n\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (set_val != 0) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            set_val = 0;\r\n        }\r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n\r\n    void combine() {\r\n        if (l == nullptr) return;\r\n        sum = l->sum + r->sum;\r\n    }\r\n\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) {\r\n            self_add(v);\r\n            return;\r\n        }\r\n        int m = (s + e) >> 1;\r\n        create_children();\r\n        lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m + 1), y, v);\r\n        combine();\r\n    }\r\n\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) {\r\n            self_set(v);\r\n            return;\r\n        }\r\n        int m = (s + e) >> 1;\r\n        create_children();\r\n        lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m + 1), y, v);\r\n        combine();\r\n    }\r\n\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == nullptr || set_val != 0) return (sum / (e - s + 1)) * (y - x + 1);\r\n        int m = (s + e) >> 1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m + 1, y);\r\n    }\r\n\r\n    ~node() {\r\n        // note: deleting nullptr has no effect\r\n        delete l;\r\n        delete r;\r\n    }\r\n};\r\n\r\nint main() {\r\n    int n, q;\r\n    cin >> n >> q;\r\n    node *root = new node(-1e9, 1e9);\r\n    while (q--) {\r\n        int t;\r\n        cin >> t;\r\n        if (t == 1) {\r\n            int a, b, u;\r\n            cin >> a >> b >> u;\r\n            root->add(a, b, u);\r\n        } else {\r\n            int l, r; cin >> l >> r;\r\n            cout << root->range_sum(l, r) << endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "jmuzhen",
        "id": 372470,
        "date": "2023-12-19 10:40:23",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll sum;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n\r\n    node(int _s, int _e, int A[] = nullptr) : s(_s), e(_e), sum(0), add_val(0), set_val(0),\r\n                                              l(nullptr), r(nullptr) {\r\n        if (A == nullptr) return;\r\n        if (s == e) sum = A[s];\r\n        else {\r\n            l = new node(s, (s + e) >> 1, A), r = new node((s + e + 2) >> 1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != nullptr) return;\r\n        int m = (s + e) >> 1;\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n    }\r\n\r\n    void self_set(ll v) {\r\n        set_val = v;\r\n        sum = v * (e - s + 1);\r\n        add_val = 0;\r\n    }\r\n\r\n    void self_add(ll v) {\r\n        if (set_val != 0) {\r\n            self_set(v + set_val);\r\n            return;\r\n        }\r\n        add_val += v;\r\n        sum += v * (e - s + 1);\r\n    }\r\n\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (set_val != 0) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            set_val = 0;\r\n        }\r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n\r\n    void combine() {\r\n        if (l == nullptr) return;\r\n        sum = l->sum + r->sum;\r\n    }\r\n\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) {\r\n            self_add(v);\r\n            return;\r\n        }\r\n        int m = (s + e) >> 1;\r\n        create_children();\r\n        lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m + 1), y, v);\r\n        combine();\r\n    }\r\n\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) {\r\n            self_set(v);\r\n            return;\r\n        }\r\n        int m = (s + e) >> 1;\r\n        create_children();\r\n        lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m + 1), y, v);\r\n        combine();\r\n    }\r\n\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == nullptr || set_val != 0) return (sum / (e - s + 1)) * (y - x + 1);\r\n        int m = (s + e) >> 1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m + 1, y);\r\n    }\r\n\r\n    ~node() {\r\n        // note: deleting nullptr has no effect\r\n        delete l;\r\n        delete r;\r\n    }\r\n};\r\n\r\nint main() {\r\n    int n, q;\r\n    cin >> n >> q;\r\n    node *root = new node(-1, 1e9);\r\n    while (q--) {\r\n        int t;\r\n        cin >> t;\r\n        if (t == 1) {\r\n            int a, b, u;\r\n            cin >> a >> b >> u;\r\n            root->add(a, b, u);\r\n        } else {\r\n            int l, r; cin >> l >> r;\r\n            cout << root->range_sum(l, r) << endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "jmuzhen",
        "id": 372309,
        "date": "2023-12-18 21:04:33",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll sum;\r\n    ll add_val;\r\n    node *l, *r;\r\n\r\n    node(int _s, int _e, int A[] = nullptr) : s(_s), e(_e), sum(0), add_val(0),\r\n                                              l(nullptr), r(nullptr) {\r\n        if (A == nullptr) return;\r\n        if (s == e) sum = A[s];\r\n        else {\r\n            l = new node(s, (s + e) >> 1, A), r = new node((s + e + 2) >> 1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != nullptr) return;\r\n        int m = (s + e) >> 1;\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n    }\r\n\r\n    void self_add(ll v) {\r\n        add_val += v;\r\n        sum += v * (e - s + 1);\r\n    }\r\n\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n\r\n    void combine() {\r\n        if (l == nullptr) return;\r\n        sum = l->sum + r->sum;\r\n    }\r\n\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) {\r\n            self_add(v);\r\n            return;\r\n        }\r\n        int m = (s + e) >> 1;\r\n        create_children();\r\n        lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m + 1), y, v);\r\n        combine();\r\n    }\r\n\r\n    void set(int x, int y, ll v) {\r\n        add(x, y, v - range_sum(x, y));\r\n    }\r\n\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == nullptr) return (sum / (e - s + 1)) * (y - x + 1);\r\n        int m = (s + e) >> 1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m + 1, y);\r\n    }\r\n\r\n    ~node() {\r\n        // note: deleting nullptr has no effect\r\n        delete l;\r\n        delete r;\r\n    }\r\n};\r\n\r\nint main() {\r\n    int n, q;\r\n    cin >> n >> q;\r\n    node *root = new node(1, n);\r\n    while (q--) {\r\n        int t;\r\n        cin >> t;\r\n        if (t == 1) {\r\n            int a, b, u;\r\n            cin >> a >> b >> u;\r\n            root->add(a, b, u);\r\n        } else {\r\n            int l, r; cin >> l >> r;\r\n            cout << root->range_sum(l, r) << endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "jmuzhen",
        "id": 372308,
        "date": "2023-12-18 21:03:19",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n\r\n    node(int _s, int _e, int A[] = nullptr) : s(_s), e(_e), sum(0), lset(0), add_val(0), set_val(0),\r\n                                              l(nullptr), r(nullptr) {\r\n        if (A == nullptr) return;\r\n        if (s == e) sum = A[s];\r\n        else {\r\n            l = new node(s, (s + e) >> 1, A), r = new node((s + e + 2) >> 1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != nullptr) return;\r\n        int m = (s + e) >> 1;\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n    }\r\n\r\n    void self_set(ll v) {\r\n        lset = true;\r\n        set_val = v;\r\n        sum = v * (e - s + 1);\r\n        add_val = 0;\r\n    }\r\n\r\n    void self_add(ll v) {\r\n        if (lset) {\r\n            self_set(v + set_val);\r\n            return;\r\n        }\r\n        add_val += v;\r\n        sum += v * (e - s + 1);\r\n    }\r\n\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }\r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n\r\n    void combine() {\r\n        if (l == nullptr) return;\r\n        sum = l->sum + r->sum;\r\n    }\r\n\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) {\r\n            self_add(v);\r\n            return;\r\n        }\r\n        int m = (s + e) >> 1;\r\n        create_children();\r\n        lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m + 1), y, v);\r\n        combine();\r\n    }\r\n\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) {\r\n            self_set(v);\r\n            return;\r\n        }\r\n        int m = (s + e) >> 1;\r\n        create_children();\r\n        lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m + 1), y, v);\r\n        combine();\r\n    }\r\n\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == nullptr || lset) return (sum / (e - s + 1)) * (y - x + 1);\r\n        int m = (s + e) >> 1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m + 1, y);\r\n    }\r\n\r\n    ~node() {\r\n        // note: deleting nullptr has no effect\r\n        delete l;\r\n        delete r;\r\n    }\r\n};\r\n\r\nint main() {\r\n    int n, q;\r\n    cin >> n >> q;\r\n    node *root = new node(1, n);\r\n    while (q--) {\r\n        int t;\r\n        cin >> t;\r\n        if (t == 1) {\r\n            int a, b, u;\r\n            cin >> a >> b >> u;\r\n            root->add(a, b, u);\r\n        } else {\r\n            int l, r; cin >> l >> r;\r\n            cout << root->range_sum(l, r) << endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "aureliony",
        "id": 370855,
        "date": "2023-12-17 23:01:50",
        "code": "// #define ONLINE_JUDGE 1\r\n#ifdef ONLINE_JUDGE\r\n#pragma GCC optimize(\"O3\")\r\n#pragma GCC target(\"avx2\")\r\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\r\n// #pragma GCC optimize(\"unroll-loops\")\r\n#endif\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n// #include <ext/pb_ds/assoc_container.hpp> // ~170ms longer compile time\r\n// #include <ext/pb_ds/tree_policy.hpp>\r\n// using namespace __gnu_pbds;\r\n// template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n// template<class T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n// #define endl '\\n'\r\n#define INF32 (0x3f3f3f3f)\r\n#define INF64 (0x3f3f3f3f3f3f3f3fLL)\r\n#define INF (INF32)\r\n#define PI (3.14159265358979323846f)\r\n#define EPS (1e-11f)\r\n#define typeof(x) remove_reference<decltype(x)>::type\r\n#define _picktype(a,b) common_type<typeof(a),typeof(b)>::type\r\n#define rep(i,a,b) for(_picktype((a),(b)) i=(a); (a)<(b) ? i<(b) : i>(b); (a)<(b) ? i++:i--)\r\n#define fori(a,b) rep(i,(a),(b))\r\n#define forj(a,b) rep(j,(a),(b))\r\n#define fork(a,b) rep(k,(a),(b))\r\n#define forl(a,b) rep(l,(a),(b))\r\n#define forit(a,b) for(auto it=(a); it!=(b); it++)\r\n#define rforit(a,b) for(auto it=(a); it!=(b); it--)\r\n#define all(x) (x).begin(), (x).end()\r\n#define rall(x) (x).rbegin(), (x).rend()\r\n#define mset(a,b) memset(a,b,sizeof(a))\r\n#define fi first\r\n#define se second\r\n#define pb push_back\r\n#define pf push_front\r\nusing uint = unsigned int;\r\nusing ll = long long;\r\nusing ull = unsigned long long;\r\nusing pii = pair<int, int>;\r\nusing pll = pair<ll, ll>;\r\nusing vi = vector<int>;\r\nusing vii = vector<pii>;\r\nusing vll = vector<ll>;\r\nusing vpll = vector<pll>;\r\n#ifdef _WIN32\r\n#define getchar _getchar_nolock\r\n#define putchar _putchar_nolock\r\n#else\r\n#define getchar getchar_unlocked\r\n#define putchar putchar_unlocked\r\n#endif\r\ntemplate<class T> void getInteger(T& x) { int ch; do { ch = getchar(); } while (ch != '-' && (ch < '0' || ch > '9')); bool neg = ch == '-'; if (neg) ch = getchar(); while (ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + ch - '0', ch = getchar(); if (neg) x = -x; }\r\nint getint() { int x = 0; getInteger(x); return x; }\r\nll getll() { ll x = 0; getInteger(x); return x; }\r\nstring getstr() { string s; int ch; do { ch = getchar(); } while (ch < '!' || ch > '~'); while (ch >= '!' && ch <= '~') s.pb(ch), ch = getchar(); return s; }\r\nstring getline() { string s; int ch; do { ch = getchar(); } while (ch < ' ' || ch > '~'); while (ch >= ' ' && ch <= '~') s.pb(ch), ch = getchar(); return s; }\r\ndouble getdouble() { return stod(getstr()); }\r\nint gi() { return getint(); }\r\nll gll() { return getll(); }\r\nstring gs() { return getstr(); }\r\ndouble gd() { return getdouble(); }\r\nvoid put(string s, bool nl = true) { for (char c : s) putchar(c); if (nl) putchar('\\n'); }\r\nvoid put(char c, bool nl = true) { putchar(c); if (nl) putchar('\\n'); }\r\nchar _digits[20];\r\nvoid put(int n, bool nl = true) {\r\n    if (n < 0) putchar('-'), n = -n;\r\n    int i=0;\r\n    do _digits[i++] = n%10; while(n/=10);\r\n    while (i--) putchar(_digits[i] + 48);\r\n    if (nl) putchar('\\n');\r\n}\r\nvoid put(size_t n, bool nl = true) {\r\n    put((int)n, nl);\r\n}\r\nvoid put(ll n, bool nl = true) {\r\n    if (n < 0) putchar('-'), n = -n;\r\n    int i=0;\r\n    do _digits[i++] = n%10; while(n/=10);\r\n    while (i--) putchar(_digits[i] + 48);\r\n    if (nl) putchar('\\n');\r\n}\r\nvoid put(vector<int>& v) { \r\n    fori(0, v.size()-1){put(v[i],false);putchar(' ');}\r\n    put(v.back());\r\n}\r\nvoid put(vector<ll>& v) { \r\n    fori(0, v.size()-1){put(v[i],false);putchar(' ');}\r\n    put(v.back());\r\n}\r\nvoid put(deque<int>& v) { \r\n    fori(0, v.size()-1){put(v[i],false);putchar(' ');}\r\n    put(v.back());\r\n}\r\nvoid put(deque<ll>& v) { \r\n    fori(0, v.size()-1){put(v[i],false);putchar(' ');}\r\n    put(v.back());\r\n}\r\nbool eq(double a, double b) {\r\n    return abs(a-b) <= (1e-9);\r\n}\r\nconst uint64_t FIXED_RANDOM = (uint64_t)make_unique<char>().get() ^ (uint64_t)chrono::high_resolution_clock::now().time_since_epoch().count();\r\nstruct CustomHash {\r\n    static constexpr uint64_t C = (uint64_t)(4e18*acos(0))+71;\r\n    template <class T> size_t hash_impl(const T& container) const {\r\n        return (std::hash<uint64_t>()(std::apply([](const auto&... xs) { return (Component(xs), ..., 0); }, container)) ^ FIXED_RANDOM) * C;\r\n    }\r\n    template <class T> struct Component {\r\n        static const std::hash<T> hasher;\r\n        const T& value;\r\n        Component(const T& value) : value(value) {}\r\n        uint64_t operator,(uint64_t h) const {\r\n            h ^= hasher(value);\r\n            h ^= h << (sizeof(uint64_t) * 4 - 1);\r\n            return h;\r\n        }\r\n    };\r\n    template <class T> size_t operator()(const T& value) const {\r\n        static constexpr std::hash<T> hasher;\r\n        return __builtin_bswap64((hasher(value) ^ FIXED_RANDOM) * C);\r\n    }\r\n    template <class... T> size_t operator()(const std::tuple<T...>& tuple) const {\r\n        return hash_impl(tuple);\r\n    }\r\n    template <class... T> size_t operator()(const std::pair<T...>& pair) const {\r\n        return hash_impl(pair);\r\n    }\r\n};\r\ntemplate<class T>\r\nvector<int> argsort(const vector<T> &array) {\r\n    vector<int> indices(array.size());\r\n    iota(indices.begin(), indices.end(), 0);\r\n    sort(indices.begin(), indices.end(),\r\n        [&array](int left, int right) {\r\n          return array[left] < array[right];\r\n        });\r\n    return indices;\r\n}\r\nstruct DSU {\r\n    vector<int> par;\r\n    DSU(int n) { par.resize(n, -1); }\r\n    int find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\r\n    int root(int x) { return find(x); }\r\n    bool conn(int x, int y) { return find(x) == find(y); }\r\n    void merge(int x, int y)\r\n    {\r\n        if ((x = find(x)) == (y = find(y)))\r\n            return;\r\n        if (par[y] < par[x])\r\n            swap(x, y);\r\n        par[x] += par[y];\r\n        par[y] = x;\r\n    }\r\n    void setpar(int x, int y) {\r\n        // set parent of x to y\r\n        if ((x = find(x)) == (y = find(y)))\r\n            return;\r\n        par[y] += par[x];\r\n        par[x] = y;\r\n    }\r\n};\r\nvector<bool> sieve(ll maxprime) {\r\n    if (maxprime == 1) return vector<bool>(2,0);\r\n    vector<bool> prime(maxprime+1, 1);\r\n    prime[0] = 0;\r\n    prime[1] = 0;\r\n    ll p = 2;\r\n    prime[p] = 1;\r\n    while (p*p <= maxprime) {\r\n        if (prime[p]) {\r\n            for (ll e = p+p; e <= maxprime; e += p) {\r\n                prime[e] = 0;\r\n            }\r\n        }\r\n        p++;\r\n    }\r\n    return prime;\r\n}\r\nvector<bool> segmented_sieve(ll l, ll r) {\r\n    ll n = (ll)(sqrt((ll)(r+1)))+1;\r\n    vector<bool> prime = sieve(n);\r\n    vector<bool> isPrime(r-l+1, 1);\r\n    if (l == 0) {\r\n        isPrime[0] = 0;\r\n        isPrime[1] = 0;\r\n    }\r\n    if (l == 1) isPrime[0] = 0;\r\n    fori(0,prime.size()) {\r\n        if (!prime[i]) continue;\r\n        for (ll j = max((ll)(i*i), (ll)((l+i-1)/i*i)); j <= r; j += i)\r\n            isPrime[j-l] = 0;\r\n    }\r\n    return isPrime;\r\n}\r\n\r\nll choose(ll n, ll k) {\r\n    if (k>n) return 0;\r\n    if (k==0 or k==n) return 1;\r\n    ll ans = 1;\r\n    fori(1,k+1) ans = ans * (n-k+i)/i;\r\n    return ans;\r\n}\r\n\r\nstruct node {\r\n  int from, to;\r\n  long long value, lazy;\r\n  node *left, *right;\r\n  node() {\r\n    from=1;\r\n    to=1e9;\r\n    value=0;\r\n    lazy=0;\r\n    left=NULL;\r\n    right=NULL;\r\n  }\r\n  void extend() {\r\n    if(left==NULL) {\r\n      left=new node();\r\n      right=new node();\r\n      left->from=from;\r\n      left->to=(from+to)>>1;\r\n      right->from=((from+to)>>1)+1;\r\n      right->to=to;\r\n    }\r\n  }\r\n};\r\n \r\nnode *root;\r\n \r\nvoid update_tree(node *curr, int left, int right, long long value) {\r\n  if(curr->lazy) {\r\n    curr->value+=(curr->to-curr->from+1)*curr->lazy;\r\n    if(curr->from!=curr->to) {\r\n      curr->extend();\r\n      curr->left->lazy+=curr->lazy;\r\n      curr->right->lazy+=curr->lazy;\r\n    }\r\n    curr->lazy=0;\r\n  }\r\n  if((curr->from)>(curr->to) || (curr->from)>right || (curr->to)<left) return;\r\n  if(curr->from>=left && curr->to<=right) {\r\n    curr->value+=(curr->to-curr->from+1)*value;\r\n    if(curr->from!=curr->to) {\r\n      curr->extend();\r\n      curr->left->lazy+=value;\r\n      curr->right->lazy+=value;\r\n    }\r\n    return;\r\n  }\r\n  curr->extend();\r\n  update_tree(curr->left,left,right,value);\r\n  update_tree(curr->right,left,right,value);\r\n  curr->value=curr->left->value + curr->right->value;\r\n}\r\n \r\nlong long query_tree(node *curr, int left, int right) {\r\n  if((curr->from)>(curr->to) || (curr->from)>right || (curr->to)<left) return 0;\r\n  if(curr->lazy) {\r\n    curr->value+=(curr->to-curr->from+1)*curr->lazy;\r\n    curr->extend();\r\n    curr->left->lazy+=curr->lazy;\r\n    curr->right->lazy+=curr->lazy;\r\n    curr->lazy=0;\r\n  }\r\n  if(curr->from>=left && curr->to<=right) return curr->value;\r\n  long long q1,q2;\r\n  curr->extend();\r\n  q1=query_tree(curr->left,left,right);\r\n  q2=query_tree(curr->right,left,right);\r\n  return q1+q2;\r\n}\r\n\r\n#define PP put(\"\")\r\n#define MOD (1000000007)\r\nvoid imp() { put(\"NO\"); exit(0); }\r\n\r\nvoid solve() {\r\n    int n = gi(), q = gi();\r\n    root = new node();\r\n    fori(0,q) {\r\n        int a = gi(), l = gi(), r = gi();\r\n        if (a == 1) {\r\n            ll k = gll();\r\n            update_tree(root, l, r, k);\r\n        } else {\r\n            put(query_tree(root, l, r));\r\n        }\r\n    }\r\n}\r\n\r\nsigned main() {\r\n    // ios::sync_with_stdio(0); cin.tie(0);\r\n    cout.precision(16); cout << fixed;\r\n    int t = 1;\r\n    // t = gi();\r\n    fori(0,t) {\r\n        solve();\r\n    }\r\n}"
    },
    {
        "username": "wongyikai",
        "id": 364857,
        "date": "2023-12-12 19:43:15",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n    ll n,q;\r\n    cin >> n >> q;\r\n    root = new node(1,n);\r\n    ll temp,l,r,k;\r\n    for (int i=0;i<q;i++){\r\n        cin >> temp >> l >> r;\r\n        if (temp==1) {\r\n            cin >> k;\r\n            root->add(l,r,k);\r\n        }\r\n        else cout << root->range_sum(l,r) << \"\\n\";\r\n    }\r\n}"
    },
    {
        "username": "Huoi",
        "id": 364777,
        "date": "2023-12-12 19:26:26",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct Node {\r\n    Node *l, *r;\r\n\r\n    int tl, tr, tm;\r\n    int val, lzy; \r\n\r\n    Node(int s, int e) {\r\n        tl = s, tr = e, tm = (tl + tr) / 2;\r\n        val = lzy = 0;\r\n        l = r = nullptr;\r\n    }\r\n\r\n    void push() {\r\n        if (tl == tr) {\r\n            return;\r\n        }\r\n\r\n        if (l == nullptr) {\r\n            l = new Node(tl, tm);\r\n            r = new Node(tm + 1, tr);\r\n        }\r\n\r\n        if (lzy != 0) {\r\n            l->val += lzy * (tm - tl + 1);\r\n            l->lzy += lzy;\r\n            r->val += lzy * (tr - tm);\r\n            r->lzy += lzy;\r\n            lzy = 0;\r\n        }\r\n    }\r\n\r\n    void update(int s, int e, int x) {\r\n        if (tl > e || tr < s) {\r\n            return;\r\n        }\r\n\r\n        if (tl >= s && tr <= e) {\r\n            val += x * (tr - tl + 1);\r\n            lzy += x;\r\n            return;\r\n        }\r\n\r\n        push();\r\n        l->update(s, e, x);\r\n        r->update(s, e, x);\r\n        val = l->val + r->val;\r\n    }\r\n\r\n    int query(int s, int e) {\r\n        if (tl > e || tr < s) {\r\n            return 0;\r\n        }\r\n\r\n        if (tl >= s && tr <= e) {\r\n            return val;\r\n        }\r\n\r\n        push();\r\n        return l->query(s, e) + r->query(s, e);\r\n    }\r\n} *root;\r\n\r\nvoid solve() {\r\n    int n, q;\r\n    cin >> n >> q;\r\n\r\n    root = new Node(1, n);\r\n\r\n    while (q--) {\r\n        int qt; cin >> qt;\r\n\r\n        if (qt == 1) {\r\n            int l, r, k;\r\n            cin >> l >> r >> k;\r\n            root->update(l, r, k);\r\n        } else {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << root->query(l, r) << \"\\n\";\r\n        }\r\n    }\r\n}\r\n\r\nsigned main() {\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    solve();\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "yuhong",
        "id": 364323,
        "date": "2023-12-12 13:34:47",
        "code": "#include <bits/stdc++.h>\r\n#include<ext/pb_ds/assoc_container.hpp>\r\n#include<ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\ntemplate <typename T>\r\nusing ordered_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\r\n#define endl '\\n'\r\n#define ll long long\r\n#define pb push_back\r\n#define vi vector<int>\r\n#define vll vector<long long>\r\n#define sz(x) (int)x.size()\r\n#define int long long\r\n#define float double\r\n#define all(x) x.begin(),x.end()\r\n#define pii pair<int,int>\r\n#define rep(i,a,b) for (ll i = a; i<b; i++)\r\n#define repo(i,a,b) for (int i = a; i>=b; i--)\r\n#define fi first\r\n#define se second\r\n//int decrow[4] = {-1,0,1,0};\r\n//int deccol[4] = {0,1,0,-1};\r\n//int dp[100001][100001];\r\n//int arr[100001];\r\nint dy[8] = {0,  0, 1, -1, 1, -1 , 1, -1};\r\nint dx[8] = {1, -1, 0,  0, 1, -1, -1,  1};\r\nconst int MAXN = 2e5 + 10;\r\nconst int MOD = 1e9+7;\r\nconst int INF = 1e18;\r\nint n,x,m;\r\nvector<pii> v;\r\nint total = 0;\r\nint ans = 0;\r\n//segment tree\r\nstruct node{\r\n    int start,end,value,lazy;\r\n    node *l, *r;\r\n    node(int s,int e){\r\n      start = s, end = e;\r\n      l = nullptr, r = nullptr;\r\n      lazy = 0, value = 0;\r\n    }\r\n    void propogate(){\r\n      if(start==end){\r\n        return;\r\n      }\r\n      if(lazy!=0){\r\n        int mid = (start+end)/2;\r\n        l->value += lazy*(mid-start+1);\r\n        r->value += lazy*(end-mid);\r\n        l->lazy += lazy;\r\n        r->lazy += lazy;\r\n\r\n        lazy = 0;\r\n      }\r\n    }\r\n    void update(int s,int e,int val){\r\n      if(e<start || s>end){\r\n        return;\r\n      }\r\n      if(s<=start && e>=end){\r\n        value += val*(end-start+1);\r\n        lazy+=val;\r\n        return;\r\n      }\r\n      if(l == nullptr){\r\n        create();\r\n      }\r\n      propogate();\r\n      l->update(s,e,val);\r\n      r->update(s,e,val);\r\n      value = l->value + r->value;\r\n    }\r\n    int query(int s,int e){\r\n      if(s>end || e<start){\r\n        return 0;\r\n      }\r\n      if(s<=start && e>=end){\r\n        return value;\r\n      }\r\n      if(l==nullptr){\r\n        create();\r\n      }\r\n      propogate();\r\n      return l->query(s,e)+r->query(s,e);\r\n    }\r\n    void create(){\r\n      if(start!=end){\r\n        int mid = (start+end)/2;\r\n        l = new node(start,mid);\r\n        r = new node(mid+1,end);\r\n      }\r\n    }\r\n};\r\n\r\nvoid solve(){\r\n  int k;\r\n  cin>>n>>k;\r\n  node suern(0,n-1);\r\n  for(int i = 0;i<k;i++){\r\n    int a;\r\n    cin>>a;\r\n    if(a==1){\r\n      int start,end,val;\r\n      cin>>start>>end>>val;\r\n      suern.update(start-1,end-1,val);\r\n    }else{\r\n      int l,r;\r\n      cin>>l>>r;\r\n      cout<<suern.query(l-1,r-1)<<endl;\r\n    }\r\n  }\r\n} \r\n\r\n\r\n\r\nint32_t main() {\r\nios_base::sync_with_stdio(false);\r\ncin.tie(NULL);\r\ncout.tie(NULL);\r\n  int q =1;\r\n  while(q--){\r\n    solve();\r\n  }\r\n  return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "username": "yuhong",
        "id": 364322,
        "date": "2023-12-12 13:34:05",
        "code": "#include <bits/stdc++.h>\r\n#include<ext/pb_ds/assoc_container.hpp>\r\n#include<ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\ntemplate <typename T>\r\nusing ordered_set = tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\r\n#define endl '\\n'\r\n#define ll long long\r\n#define pb push_back\r\n#define vi vector<int>\r\n#define vll vector<long long>\r\n#define sz(x) (int)x.size()\r\n#define int long long\r\n#define float double\r\n#define all(x) x.begin(),x.end()\r\n#define pii pair<int,int>\r\n#define rep(i,a,b) for (ll i = a; i<b; i++)\r\n#define repo(i,a,b) for (int i = a; i>=b; i--)\r\n#define fi first\r\n#define se second\r\n//int decrow[4] = {-1,0,1,0};\r\n//int deccol[4] = {0,1,0,-1};\r\n//int dp[100001][100001];\r\n//int arr[100001];\r\nint dy[8] = {0,  0, 1, -1, 1, -1 , 1, -1};\r\nint dx[8] = {1, -1, 0,  0, 1, -1, -1,  1};\r\nconst int MAXN = 2e5 + 10;\r\nconst int MOD = 1e9+7;\r\nconst int INF = 1e18;\r\nint n,x,m;\r\nvector<pii> v;\r\nint total = 0;\r\nint ans = 0;\r\n//segment tree\r\nstruct node{\r\n    int start,end,value,lazy;\r\n    node *l, *r;\r\n    node(int s,int e): start(s),end(e){\r\n      l = nullptr, r = nullptr;\r\n      lazy = 0, value = 0;\r\n    }\r\n    void propogate(){\r\n      if(start==end){\r\n        return;\r\n      }\r\n      if(lazy!=0){\r\n        int mid = (start+end)/2;\r\n        l->value += lazy*(mid-start+1);\r\n        r->value += lazy*(end-mid);\r\n        l->lazy += lazy;\r\n        r->lazy += lazy;\r\n\r\n        lazy = 0;\r\n      }\r\n    }\r\n    void update(int s,int e,int val){\r\n      if(e<start || s>end){\r\n        return;\r\n      }\r\n      if(s<=start && e>=end){\r\n        value += val*(end-start+1);\r\n        lazy+=val;\r\n        return;\r\n      }\r\n      if(l == nullptr){\r\n        create();\r\n      }\r\n      propogate();\r\n      l->update(s,e,val);\r\n      r->update(s,e,val);\r\n      value = l->value + r->value;\r\n    }\r\n    int query(int s,int e){\r\n      if(s>end || e<start){\r\n        return 0;\r\n      }\r\n      if(s<=start && e>=end){\r\n        return value;\r\n      }\r\n      if(l==nullptr){\r\n        create();\r\n      }\r\n      propogate();\r\n      return l->query(s,e)+r->query(s,e);\r\n    }\r\n    void create(){\r\n      if(start!=end){\r\n        int mid = (start+end)/2;\r\n        l = new node(start,mid);\r\n        r = new node(mid+1,end);\r\n      }\r\n    }\r\n};\r\n\r\nvoid solve(){\r\n  int k;\r\n  cin>>n>>k;\r\n  node suern(0,n-1);\r\n  for(int i = 0;i<k;i++){\r\n    int a;\r\n    cin>>a;\r\n    if(a==1){\r\n      int start,end,val;\r\n      cin>>start>>end>>val;\r\n      suern.update(start-1,end-1,val);\r\n    }else{\r\n      int l,r;\r\n      cin>>l>>r;\r\n      cout<<suern.query(l-1,r-1)<<endl;\r\n    }\r\n  }\r\n} \r\n\r\n\r\n\r\nint32_t main() {\r\nios_base::sync_with_stdio(false);\r\ncin.tie(NULL);\r\ncout.tie(NULL);\r\n  int q =1;\r\n  while(q--){\r\n    solve();\r\n  }\r\n  return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "username": "bobthebill1",
        "id": 362396,
        "date": "2023-12-11 10:25:45",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define endl \"\\n\"\r\n#define FOR(i,a,n) for(int i=a;i<n;i++)\r\n#define f first\r\n#define se second\r\ntypedef pair<int, int> pi;\r\ntypedef pair<pi, int> pii;\r\n\r\nint N, Q, cmd, a, b,c;\r\n\r\nstruct node{\r\n\tint s,e,m, val,lazy;\r\n\tnode *l, *r;\r\n\t\r\n\tnode(int S, int E){\r\n\t\ts=S, e=E, m = (s+e)/2;\r\n\t\tval = 0;\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(s!=e){\r\n\t\t\tl=new node(s,m);\r\n\t\t\tr=new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\tvoid propagate(){\r\n\t\tif (l==nullptr) create();\r\n\t\tif(lazy==0) return;\r\n\t\t\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif (s!=e){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\t\r\n\t\r\n\tvoid update(int S, int E, int V){\r\n\t\tif (l==nullptr) create();\r\n\t\tif (s==S&&e==E) lazy+=V;\r\n\t\telse{\r\n\t\t\tif (E <= m) l->update(S,E,V);\r\n\t\t\telse if (m<S) r->update(S,E,V);\r\n\t\t\telse l->update(S,m,V), r->update(m+1,E,V);\r\n\t\t\t\r\n\t\t\tl->propagate(), r->propagate();\r\n\t\t\tval = l->val+r->val;\r\n\t\t}\r\n\t}\t\r\n\t\r\n\tint query(int S, int E){\r\n\t\tif (l==nullptr) create();\r\n\t\tpropagate();\r\n\t\t\r\n\t\tif(S==s&&E==e) return val;\r\n\t\telse if (E <=m) return l->query(S,E);\r\n\t\telse if (S>m) return r->query(S, E);\r\n\t\telse return l->query(S, m)+r->query(m+1, E);\r\n\t}\r\n\t\r\n}*root;\r\n\r\nint32_t main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\t\r\n\tcin >> N >> Q;\r\n\troot = new node(1,N);\r\n\tFOR(i,0,Q){\r\n\t\tcin >> cmd;\r\n\t\tif (cmd == 1){\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\troot->update(a,b,c);\r\n\t\t}\r\n\t\telse if (cmd == 2){\r\n\t\t\tcin >> a >> b;\r\n\t\t\tint A = root->query(a,b);\r\n\t\t\tcout << A << endl;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n"
    },
    {
        "username": "myoldaccountgone",
        "id": 361865,
        "date": "2023-12-10 23:23:32",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nstruct node {\r\n    node *left, *right;\r\n    ll S, E, val, lazy;\r\n    node(ll _s, ll _e) : S(_s), E(_e) {\r\n        left = right = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void prop(){\r\n        if(S == E) return;\r\n        ll M = (S + E) / 2;\r\n        if(left == nullptr){ // no children\r\n            left = new node(S, M);\r\n            right = new node(M + 1, E);\r\n        }\r\n        if(lazy != 0){\r\n            // need to add lazy to left and right children\r\n            left->val += lazy * (M - S + 1);\r\n            left->lazy += lazy;\r\n            right->val += lazy * (E - M);\r\n            right->lazy += lazy;\r\n            // reset lazy tag\r\n            lazy = 0;\r\n        }\r\n    }\r\n    ll qry(ll l, ll r) { // sum from index l to index r\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return 0;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            return val;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        return left->qry(l, r) + right->qry(l, r);\r\n    }\r\n    void upd(ll l, ll r, ll v) {\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            // update the value of the node and the lazy tag, do not recurse\r\n            val += v * (E - S + 1); // all E - S + 1 nodes has their value increased\r\n            lazy += v;\r\n            return;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        left->upd(l, r, v);\r\n        right->upd(l, r, v);\r\n        // update current node value\r\n        val = left->val + right->val;\r\n    }\r\n} *root;\r\n// range add, range sum, lazy creation lazy propagation segment tree\r\nint main(){\r\n\tll n;\r\n\tcin >> n;\r\n\troot=new node(0,n);\r\n\r\n\tll m;\r\n\tcin >> m;\r\n\tll op,x,y,a,b,c;\r\n\twhile (m--){\r\n\t\tcin >> op;\r\n\t\tif (op == 2){\r\n\t\t\tcin >> x >> y;\r\n\t\t\tcout << root->qry(x,y)<<\"\\n\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\troot->upd(a,b,c);\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n"
    },
    {
        "username": "jmuzhen",
        "id": 361764,
        "date": "2023-12-10 21:56:40",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node {\r\n    node *left, *right;\r\n    int S, E, val, lazy;\r\n    node(int _s, int _e) : S(_s), E(_e) {\r\n        left = right = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void prop(){\r\n        if(S == E) return;\r\n        int M = (S + E) / 2;\r\n        if(left == nullptr){ // no children\r\n            left = new node(S, M);\r\n            right = new node(M + 1, E);\r\n        }\r\n        if(lazy != 0){\r\n            // need to add lazy to left and right children\r\n            left->val += lazy * (M - S + 1);\r\n            left->lazy += lazy;\r\n            right->val += lazy * (E - M);\r\n            right->lazy += lazy;\r\n            // reset lazy tag\r\n            lazy = 0;\r\n        }\r\n    }\r\n    int qry(int l, int r) { // sum from index l to index r\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return 0;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            return val;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        return left->qry(l, r) + right->qry(l, r);\r\n    }\r\n    void upd(int l, int r, int v) {  // range add v to [l, r]\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            // update the value of the node and the lazy tag, do not recurse\r\n            val += v * (E - S + 1); // all E - S + 1 nodes has their value increased\r\n            lazy += v;\r\n            return;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        left->upd(l, r, v);\r\n        right->upd(l, r, v);\r\n        // update current node value\r\n        val = left->val + right->val;\r\n    }\r\n};\r\n\r\nsigned main() {\r\n    ios_base::sync_with_stdio(false); cin.tie(nullptr);\r\n    int n, q; cin >> n >> q;\r\n    node *root = new node(0, n - 1);\r\n    while (q--) {\r\n        int cmd; cin >> cmd;\r\n        if (cmd == 1) {\r\n            int l, r, v; cin >> l >> r >> v;\r\n            l--, r--;\r\n            root->upd(l, r, v);\r\n        }\r\n        else {\r\n            int l, r; cin >> l >> r;\r\n            l--, r--;\r\n            cout << root->qry(l, r) << endl;\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "vs358",
        "id": 361655,
        "date": "2023-12-10 18:52:09",
        "code": "#include <iostream>\r\n#include <vector> \r\n#include <queue>\r\n#include <algorithm>\r\n#include <unordered_set>\r\n#include <set>\r\n#include <string>\r\n#include <cstring>\r\n#include <climits>\r\n#include <cmath>\r\n//#define magic ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define FOR(i, s, e) for(int i = s; i < e; i++)\r\nusing namespace std;\r\n#define int long long\r\n#define ull unsigned long long\r\n#define mp make_pair\r\n#define pb push_back\r\n#define fi first\r\n#define se second\r\n#define INF 9223372036854775807\r\ntypedef pair<int, int> pi;\r\ntypedef pair<pi, int> pii;\r\n#define magic ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\nint N, Q;\r\n\r\nstruct node{\r\n\tint s, e, m;\r\n\tint val;\r\n\tint lazy;\r\n\tnode *l, *r;\r\n\r\n\tnode(int S, int E){\r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t\tval = 0;\r\n\t\tlazy = 0;\r\n\t}\r\n\r\n\tvoid create(){\r\n\t\tif(s != e){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid prop(){\r\n\t\tif(lazy == 0) return;\r\n\t\tval += lazy*(e-s+1);\r\n\r\n\t\tif(l == nullptr) create();\r\n\r\n\t\tif(s != e){\r\n\t\t\tr->lazy += lazy;\r\n\t\t\tl->lazy += lazy;\r\n\t\t}\r\n\r\n\t\tlazy = 0;\r\n\t}\r\n\r\n\tvoid upd(int S, int E, int V){\r\n\t\tif(s == S and e == E){\r\n\t\t\tlazy += V;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif(l == nullptr) create();\r\n\r\n\t\tif(E <= m){\r\n\t\t\tl->upd(S, E, V);\r\n\t\t} else if (S > m){\r\n\t\t\tr->upd(S, E, V);\r\n\t\t} else {\r\n\t\t\tl->upd(S, m, V);\r\n\t\t\tr->upd(m+1, E, V);\r\n\t\t}\r\n\t\tl->prop();\r\n\t\tr->prop();\r\n\r\n\t\tval = l->val + r->val;\r\n\t}\r\n\r\n\tint qry(int S, int E){\r\n\t\tprop();\r\n\t\tif(l == nullptr) create();\r\n\t\tif(s == S and e == E) return val;\r\n\t\telse if(E <= m) return l->qry(S, E);\r\n\t\telse if (S > m) return r->qry(S, E);\r\n\t\telse return l->qry(S, m) + r->qry(m+1, E);\r\n\t}\r\n\r\n} *root;\r\n\r\nsigned main(){\r\n\tmagic;\r\n\r\n\tcin >> N >> Q;\r\n\r\n\troot = new node(1, N+2);\r\n\r\n\tFOR(i, 0, Q){\r\n\t\tint t;\r\n\t\tcin >> t;\r\n\r\n\t\tif(t == 1){\r\n\t\t\tint x, y, z;\r\n\t\t\tcin >> x >> y >> z;\r\n\t\t\troot->upd(x, y, z);\r\n\t\t} else {\r\n\t\t\tint x, y;\r\n\t\t\tcin >> x >> y;\r\n\t\t\tcout << root->qry(x, y) << '\\n';\r\n\t\t}\r\n\t}\r\n\t\r\n}"
    },
    {
        "username": "TheGhostKing",
        "id": 361647,
        "date": "2023-12-10 18:40:35",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\n\r\n\r\nint main(){\r\n    ios::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    int n,q;\r\n    cin >> n >> q;\r\n    root = new node(0, n);\r\n    while (q--){\r\n        int flag;\r\n        cin >> flag;\r\n        if (flag == 1){\r\n            int l,r,k;\r\n            cin >> l >> r >> k;\r\n            root->add(l,r,k);\r\n        }\r\n        else{\r\n            int l,r;\r\n            cin >> l >> r;\r\n            cout << (root->range_sum(l,r)) << '\\n';\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "dzuizz",
        "id": 361214,
        "date": "2023-12-09 22:15:29",
        "code": "// Pointer Implementation of Segment Tree with Lazy Propagation and Super Lazy Nodes (Range Update, Range Sum Query)\r\n// https://codebreaker.xyz/problem/segmenttree2\r\n\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node {\r\n    node *lf, *rg;\r\n    int l, r, val, lazy;\r\n    node (int _l, int _r): l(_l), r(_r) {\r\n        lf = nullptr;\r\n        rg = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n\r\n    void prop() {\r\n        if (l == r) return;\r\n        if (lazy != 0) {\r\n            int mid = (l+r)/2;\r\n            lf->val += lazy * (mid-l+1);\r\n            lf->lazy += lazy;\r\n            rg->val += lazy * (r-mid);\r\n            rg->lazy += lazy;\r\n\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    int qry(int x, int y) {\r\n        if (r < x || l > y) return 0;\r\n        if (x <= l && r <= y) return val;\r\n        if (lf == nullptr) create();\r\n        prop();\r\n        return lf->qry(x, y) + rg->qry(x, y);\r\n    }\r\n\r\n    void upd(int x, int y, int v) {\r\n        if (r < x || l > y) return;\r\n        if (x <= l && r <= y) {\r\n            val += v * (r-l+1);\r\n            lazy += v;\r\n            return;\r\n        }\r\n        if (lf == nullptr) create();\r\n        prop();\r\n        lf->upd(x, y, v);\r\n        rg->upd(x, y, v);\r\n        val = lf->val+rg->val;\r\n    }\r\n\r\n    void create() {\r\n        if (l != r) {\r\n            int mid = (l+r)/2;\r\n            lf = new node(l, mid);\r\n            rg = new node(mid+1, r);\r\n        }\r\n    }\r\n};\r\n\r\nsigned main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\n    int n, q; cin >> n >> q;\r\n\r\n    node* root = new node(1, n);\r\n\r\n    while (q--) {\r\n        int t; cin >> t;\r\n\r\n        if (t == 1) {\r\n            int l, r, k; cin >> l >> r >> k;\r\n            root->upd(l, r, k);\r\n        } else {\r\n            int l, r; cin >> l >> r;\r\n            cout << root->qry(l, r) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "dzuizz",
        "id": 361158,
        "date": "2023-12-09 21:25:10",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct Node {\r\n    int val, lazy, l, r, lf, rg;\r\n    Node(): val(0), lazy(0), lf(-1), rg(-1) {}\r\n};\r\n\r\nconst int INF = 1e9;\r\nconst int M = 1e9 + 7;\r\nNode segTree[(int) 2e7];\r\nint cnt = 2;\r\n\r\nvoid propagate(int idx) {\r\n    if (segTree[idx].lazy) {\r\n        segTree[idx].val += (segTree[idx].r - segTree[idx].l + 1) * segTree[idx].lazy;\r\n        int mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n        \r\n        if (segTree[idx].lf == -1) {\r\n            segTree[idx].lf = cnt++;\r\n            \r\n            segTree[segTree[idx].lf].l = segTree[idx].l;\r\n            segTree[segTree[idx].lf].r = mid;\r\n        }\r\n        \r\n        if (segTree[idx].rg == -1) {\r\n            segTree[idx].rg = cnt++;\r\n\r\n            segTree[segTree[idx].rg].l = mid + 1;\r\n            segTree[segTree[idx].rg].r = segTree[idx].r;\r\n        }\r\n\r\n        segTree[segTree[idx].lf].lazy += segTree[idx].lazy;\r\n        segTree[segTree[idx].rg].lazy += segTree[idx].lazy;\r\n        segTree[idx].lazy = 0;\r\n    }\r\n}\r\n\r\nvoid update(int idx, int x, int y, int v) {\r\n    if (segTree[idx].l == x && segTree[idx].r == y) {\r\n        segTree[idx].lazy += v;\r\n        propagate(idx);\r\n        return;\r\n    }\r\n\r\n    int mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    if (x > mid) update(segTree[idx].rg, x, y, v);\r\n    else if (y <= mid) update(segTree[idx].lf, x, y, v);\r\n    else {\r\n        update(segTree[idx].lf, x, mid, v);\r\n        update(segTree[idx].rg, mid + 1, y, v);\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n    segTree[idx].val = segTree[segTree[idx].lf].val + segTree[segTree[idx].rg].val;\r\n}\r\n\r\nint query(int idx, int x, int y) {\r\n    propagate(idx);\r\n\r\n    if (segTree[idx].l == x && segTree[idx].r == y) return segTree[idx].val;\r\n    \r\n    int mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n\r\n    if (x > mid) return query(segTree[idx].rg, x, y);\r\n    else if (y <= mid) return query(segTree[idx].lf, x, y);\r\n    else return query(segTree[idx].lf, x, mid) + query(segTree[idx].rg, mid + 1, y);\r\n}\r\n\r\nsigned main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\n    int n, q; cin >> n >> q;\r\n\r\n    segTree[1].l = 1; segTree[1].r = n;\r\n\r\n    while (q--) {\r\n        int t; cin >> t;\r\n        \r\n        if (t == 1) {\r\n            int l, r, x; cin >> l >> r >> x;\r\n            update(1, l, r, x);\r\n        } else {\r\n            int l, r; cin >> l >> r;\r\n            cout << query(1, l, r) << '\\n';\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "yeetmaster",
        "id": 360913,
        "date": "2023-12-09 16:19:51",
        "code": "#include <bits/stdc++.h>\r\n#define int long long int\r\nusing namespace std;\r\n\r\nstruct node {\r\n    node *left, *right;\r\n    int S, E, val, lazy;\r\n\r\n    node(int _s, int _e) : S(_s), E(_e) {\r\n        left = nullptr;\r\n        right = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n\r\n    void prop() {\r\n        if(S == E) return;\r\n        if (lazy != 0) {\r\n            // need to add lazy to left and right children\r\n            int M = (S + E) / 2;\r\n            left->val += lazy * (M - S + 1);\r\n            left->lazy += lazy;\r\n            right->val += lazy * (E - M);\r\n            right->lazy += lazy;\r\n            // reset lazy tag\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    int qry(int l, int r) {\r\n        if (left == nullptr) create();\r\n        if (l > E || r < S) return 0;\r\n        if (l <= S && E <= r) return val;\r\n        prop();\r\n        return left->qry(l, r) + right->qry(l, r);\r\n    }\r\n\r\n    void rangeUpd(int l, int r, int v) {\r\n        if (left == nullptr) create();\r\n        if (l > E || r < S) {\r\n            return;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            val += v * (E - S + 1);\r\n            lazy += v;\r\n            return;\r\n        }\r\n        prop();\r\n        left->rangeUpd(l, r, v);\r\n        right->rangeUpd(l, r, v);\r\n        val = left->val + right->val;\r\n    }\r\n\r\n    void create() {\r\n        if (S != E) {\r\n            int M = (S + E)/2;\r\n            left = new node(S, M);\r\n            right = new node(M+1, E);\r\n        }\r\n    }\r\n} *root;\r\n\r\nint32_t main() {\r\n    int n, q; cin >> n >> q;\r\n    node* root = new node(1, n);\r\n\r\n    for (int i = 0; i < q; i++) {\r\n        int op; cin >> op;\r\n        if (op == 1) {\r\n            int l, r, k; cin >> l >> r >> k;\r\n            root->rangeUpd(l, r, k);\r\n        } else {\r\n            int l, r; cin >> l >> r;\r\n            int ans = root->qry(l, r);\r\n            cout << ans << '\\n';\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "pavement",
        "id": 360910,
        "date": "2023-12-09 16:19:19",
        "code": "#include <bits/stdc++.h>\r\n#define int long long int\r\nusing namespace std;\r\n\r\nstruct node {\r\n    node *left, *right;\r\n    int S, E, val, lazy;\r\n\r\n    node(int _s, int _e) : S(_s), E(_e) {\r\n        left = nullptr;\r\n        right = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n\r\n    void prop() {\r\n        if(S == E) return;\r\n        if (lazy != 0) {\r\n            // need to add lazy to left and right children\r\n            int M = (S + E) / 2;\r\n            left->val += lazy * (M - S + 1);\r\n            left->lazy += lazy;\r\n            right->val += lazy * (E - M);\r\n            right->lazy += lazy;\r\n            // reset lazy tag\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    int qry(int l, int r) {\r\n        if (left == nullptr) create();\r\n        if (l > E || r < S) return 0;\r\n        if (l <= S && E <= r) return val;\r\n        prop();\r\n        return left->qry(l, r) + right->qry(l, r);\r\n    }\r\n\r\n    void rangeUpd(int l, int r, int v) {\r\n        if (left == nullptr) create();\r\n        if (l > E || r < S) {\r\n            return;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            val += v * (E - S + 1);\r\n            lazy += v;\r\n            return;\r\n        }\r\n        prop();\r\n        left->rangeUpd(l, r, v);\r\n        right->rangeUpd(l, r, v);\r\n        val = left->val + right->val;\r\n    }\r\n\r\n    void create() {\r\n        if (S != E) {\r\n            int M = (S + E)/2;\r\n            left = new node(S, M);\r\n            right = new node(M+1, E);\r\n        }\r\n    }\r\n} *root;\r\n\r\nint32_t main() {\r\n    int n, q; cin >> n >> q;\r\n    node* root = new node(1, n);\r\n\r\n    for (int i = 0; i < q; i++) {\r\n        int op; cin >> op;\r\n        if (op == 1) {\r\n            int l, r, k; cin >> l >> r >> k;\r\n            root->rangeUpd(l, r, k);\r\n        } else {\r\n            int l, r; cin >> l >> r;\r\n            int ans = root->qry(l, r);\r\n            cout << ans << '\\n';\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "Kiameimon",
        "id": 360691,
        "date": "2023-12-09 15:32:30",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long \r\n#define pii pair<int,int>\r\n#define dbg(v)\\\r\n    cout << \"Line(\" << __LINE__ << \") -> \" << #v << \" = \" << (v) << endl;\r\n\r\nstruct node{\r\n\tnode *left, *right;\r\n\tint S, E, val, lazy;\r\n\tnode(int _s, int _e) : S(_s), E(_e){\r\n\t\t\tleft = right = nullptr;\r\n\t\t\tval = 0;\r\n\t\t\tlazy = 0;\r\n\t}\r\n\r\n\tvoid prop(){\r\n\t\tif(S == E) return;\r\n\t\tint M = (S+E) >> 1;\r\n\t\tif(left == nullptr){\r\n\t\t\tleft = new node(S, M);\r\n\t\t\tright = new node(M+1, E);\r\n\t\t}\r\n\t\tif(lazy != 0){\r\n\t\t\tint M = (S+E) >> 1;\r\n\t\t\tleft->val += lazy*(M-S+1);\r\n\t\t\tleft->lazy += lazy;\r\n\t\t\tright->val += lazy*(E-M);\r\n\t\t\tright->lazy += lazy;\r\n\t\t\tlazy = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tint qry(int l, int r){\r\n\t\tif (l > E || r < S) return 0;\r\n\t\tif(l <= S && E <= r) return val;\r\n\t\tprop();\r\n\t\treturn left->qry(l, r) + right->qry(l, r);\r\n\t}\r\n\t\r\n\tvoid upd(int l, int r, int v){\r\n\t\tif(l > E || r < S) return;\r\n\t\tif(l <= S && E <= r){\r\n\t\t\tval += v*(E-S+1);\r\n\t\t\tlazy += v;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tprop();\r\n\t\tleft->upd(l, r, v);\r\n\t\tright->upd(l, r, v);\r\n\t\tval = left->val + right->val;\r\n\t}\r\n};\r\n\r\n\r\nsigned main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(0);\r\n\t\r\n\tint n, tc; cin >> n >> tc;\r\n\tnode *st = new node(1, n);\r\n\twhile(tc--){\r\n\t\tint q; cin >> q;\r\n\t\tif(q == 1){\r\n\t\t\tint l, r, val; cin >> l >> r >> val;\r\n\t\t\tst->upd(l, r, val);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint l, r; cin >> l >> r;\r\n\t\t\tcout << st->qry(l, r) << \"\\n\";\r\n\t\t}\r\n\t}\t\r\n\t\r\n\treturn 0;\r\n}\r\n"
    },
    {
        "username": "kahchun",
        "id": 360660,
        "date": "2023-12-09 15:24:55",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define pque priority_queue\r\n#define dque deque\r\n#define que queue\r\n#define pipii pair<int, pair<int,int>>\r\n#define pii pair<int,int>\r\n#define mp make_pair\r\n#define pb push_back\r\n#define endl '\\n'\r\n#define MOD PLACEHOLDER\r\n#define INF 1e18 \r\n\r\nstruct node {\r\n    node *left, *right;\r\n    int S, E, val, lazy;\r\n    node(int _s, int _e) : S(_s), E(_e) {\r\n        left = right = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void prop(){\r\n        if(S == E) return;\r\n        int M = (S + E) / 2;\r\n        if(left == nullptr){ // no children\r\n            left = new node(S, M);\r\n            right = new node(M + 1, E);\r\n        }\r\n        if(lazy != 0){\r\n            // need to add lazy to left and right children\r\n            left->val += lazy * (M - S + 1);\r\n            left->lazy += lazy;\r\n            right->val += lazy * (E - M);\r\n            right->lazy += lazy;\r\n            // reset lazy tag\r\n            lazy = 0;\r\n        }\r\n    }\r\n    int qry(int l, int r) { // sum from index l to index r\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return 0;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            return val;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        return left->qry(l, r) + right->qry(l, r);\r\n    }\r\n    void upd(int l, int r, int v) {\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            // update the value of the node and the lazy tag, do not recurse\r\n            val += v * (E - S + 1); // all E - S + 1 nodes has their value increased\r\n            lazy += v;\r\n            return;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        left->upd(l, r, v);\r\n        right->upd(l, r, v);\r\n        // update current node value\r\n        val = left->val + right->val;\r\n    }\r\n} *root;\r\n\r\nmain(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tcout.tie(NULL);\r\n\t\r\n\tint N, Q;\r\n\tcin >> N >> Q;\r\n\t\r\n\troot= new node(1, N);\r\n\t\t\r\n\tfor (int i = 0; i < Q; i++){\r\n\t\tint op, a, b;\r\n\t\tcin >> op >> a >> b;\r\n\t\t\r\n\t\tif (op == 1){\r\n\t\t\tint k;\r\n\t\t\tcin >> k;\r\n\t\t\troot->upd(a, b, k);\r\n\t\t}\r\n\t\telse\r\n\t\t\tcout << root->qry(a, b) << endl;\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n"
    },
    {
        "username": "gelastropod",
        "id": 360656,
        "date": "2023-12-09 15:24:18",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node {\r\n    node* left, * right;\r\n    int S, E, val, lazy;\r\n    node(int _s, int _e) : S(_s), E(_e) {\r\n        left = right = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void prop() {\r\n        if (S == E) return;\r\n        int M = (S + E) / 2;\r\n        if (left == nullptr) { // no children\r\n            left = new node(S, M);\r\n            right = new node(M + 1, E);\r\n        }\r\n        if (lazy != 0) {\r\n            // need to add lazy to left and right children\r\n            left->val += lazy * (M - S + 1);\r\n            left->lazy += lazy;\r\n            right->val += lazy * (E - M);\r\n            right->lazy += lazy;\r\n            // reset lazy tag\r\n            lazy = 0;\r\n        }\r\n    }\r\n    int qry(int l, int r) { // sum from index l to index r\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return 0;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            return val;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        return left->qry(l, r) + right->qry(l, r);\r\n    }\r\n    void upd(int l, int r, int v) {\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            // update the value of the node and the lazy tag, do not recurse\r\n            val += v * (E - S + 1); // all E - S + 1 nodes has their value increased\r\n            lazy += v;\r\n            return;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        left->upd(l, r, v);\r\n        right->upd(l, r, v);\r\n        // update current node value\r\n        val = left->val + right->val;\r\n    }\r\n} *root;\r\n// range add, range sum, lazy creation lazy propagation segment tree\r\n\r\nsigned main()\r\n{\r\n    int N, Q, q, l, r, k;\r\n    cin >> N >> Q;\r\n    root = new node(1, N);\r\n    for (int i = 0; i < Q; i++)\r\n    {\r\n        cin >> q >> l >> r;\r\n        if (q == 1)\r\n        {\r\n            cin >> k;\r\n            root->upd(l, r, k);\r\n        }\r\n        else if (q == 2)\r\n        {\r\n            cout << root->qry(l, r) << \"\\n\";\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "pengzhehan62",
        "id": 360653,
        "date": "2023-12-09 15:23:51",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node {\r\n    node *left, *right;\r\n    int S, E, val, lazy;\r\n    node(int _s, int _e) : S(_s), E(_e) {\r\n        left = right = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void prop(){\r\n        if(S == E) return;\r\n        int M = (S + E) / 2;\r\n        if(left == nullptr){ // no children\r\n            left = new node(S, M);\r\n            right = new node(M + 1, E);\r\n        }\r\n        if(lazy != 0){\r\n            // need to add lazy to left and right children\r\n            left->val += lazy * (M - S + 1);\r\n            left->lazy += lazy;\r\n            right->val += lazy * (E - M);\r\n            right->lazy += lazy;\r\n            // reset lazy tag\r\n            lazy = 0;\r\n        }\r\n    }\r\n    int qry(int l, int r) { // sum from index l to index r\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return 0;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            return val;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        return left->qry(l, r) + right->qry(l, r);\r\n    }\r\n    void upd(int l, int r, int v) {\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            // update the value of the node and the lazy tag, do not recurse\r\n            val += v * (E - S + 1); // all E - S + 1 nodes has their value increased\r\n            lazy += v;\r\n            return;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        left->upd(l, r, v);\r\n        right->upd(l, r, v);\r\n        // update current node value\r\n        val = left->val + right->val;\r\n    }\r\n} *root;\r\n\r\n\r\nsigned main(){\r\n    int n,q;\r\n    cin>>n>>q;\r\n    root = new node (1,n);\r\n    for (int i{};i<q;++i){\r\n        int choice{};\r\n        cin>>choice;\r\n        if (choice == 1){\r\n            int a,b,v;\r\n            cin>>a>>b>>v;\r\n            root->upd(a,b,v);\r\n        }else{\r\n            int a,b;\r\n            cin>>a>>b;\r\n            cout<<root->qry(a,b)<<'\\n';\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "Cadenloi",
        "id": 360613,
        "date": "2023-12-09 15:11:11",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node {\r\n    node *left, *right;\r\n    int S, E, val, lazy;\r\n    node(int _s, int _e) : S(_s), E(_e) {\r\n        left = right = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void prop(){\r\n        if(S == E) return;\r\n        int M = (S + E) / 2;\r\n        if(left == nullptr){\r\n            left = new node(S, M);\r\n            right = new node(M + 1, E);\r\n        }\r\n        if(lazy != 0){\r\n            left->val += lazy * (M - S + 1);\r\n            left->lazy += lazy;\r\n            right->val += lazy * (E - M);\r\n            right->lazy += lazy;\r\n            lazy = 0;\r\n        }\r\n    }\r\n    int qry(int l, int r) {\r\n        if (l > E || r < S) {\r\n            return 0;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            return val;\r\n        }\r\n        prop();\r\n        return left->qry(l, r) + right->qry(l, r);\r\n    }\r\n    void upd(int l, int r, int v) {\r\n        if (l > E || r < S) {\r\n            return;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            val += v * (E - S + 1);\r\n            lazy += v;\r\n            return;\r\n        }\r\n        prop();\r\n        left->upd(l, r, v);\r\n        right->upd(l, r, v);\r\n        val = left->val + right->val;\r\n    }\r\n} *root;\r\n\r\nint32_t main(){\r\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\r\n\tint n, k; cin >> n >> k;\r\n\troot=new node(1,n);\r\n\tfor(int i = 0; i < k; i++){\r\n\t\tint x; cin >> x;\r\n\t\tif(x == 1){\r\n\t\t\tint l, r, k; cin >> l >> r >> k;\r\n\t\t\troot->upd(l,r,k);\r\n\t\t}else if(x == 2){\r\n\t\t\tint l, r; cin >> l >> r;\r\n\t\t\tcout << root->qry(l,r) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n\r\n"
    },
    {
        "username": "dzuizz",
        "id": 360553,
        "date": "2023-12-09 14:46:45",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct Node {\r\n    int val, lazy, l, r, lf, rg;\r\n    Node(): val(0), lazy(0), lf(-1), rg(-1) {}\r\n};\r\n\r\nconst int INF = 1e9;\r\nconst int M = 1e9 + 7;\r\nNode segTree[(int) 2e7];\r\nint cnt = 2;\r\n\r\nvoid propagate(int idx) {\r\n    if (segTree[idx].lazy) {\r\n        segTree[idx].val += (segTree[idx].r - segTree[idx].l + 1) * segTree[idx].lazy;\r\n        int mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n        \r\n        if (segTree[idx].lf == -1) {\r\n            segTree[idx].lf = cnt++;\r\n            \r\n            segTree[segTree[idx].lf].l = segTree[idx].l;\r\n            segTree[segTree[idx].lf].r = mid;\r\n        }\r\n        \r\n        if (segTree[idx].rg == -1) {\r\n            segTree[idx].rg = cnt++;\r\n\r\n            segTree[segTree[idx].rg].l = mid + 1;\r\n            segTree[segTree[idx].rg].r = segTree[idx].r;\r\n        }\r\n\r\n        segTree[segTree[idx].lf].lazy += segTree[idx].lazy;\r\n        segTree[segTree[idx].rg].lazy += segTree[idx].lazy;\r\n        segTree[idx].lazy = 0;\r\n    }\r\n}\r\n\r\nvoid update(int idx, int x, int y, int v) {\r\n    if (segTree[idx].l == x && segTree[idx].r == y) {\r\n        segTree[idx].lazy += v;\r\n        propagate(idx);\r\n        return;\r\n    }\r\n\r\n    int mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    if (x > mid) update(segTree[idx].rg, x, y, v);\r\n    else if (y <= mid) update(segTree[idx].lf, x, y, v);\r\n    else {\r\n        update(segTree[idx].lf, x, mid, v);\r\n        update(segTree[idx].rg, mid + 1, y, v);\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n    segTree[idx].val = segTree[segTree[idx].lf].val + segTree[segTree[idx].rg].val;\r\n}\r\n\r\nint query(int idx, int x, int y) {\r\n    propagate(idx);\r\n\r\n    if (segTree[idx].l == x && segTree[idx].r == y) return segTree[idx].val;\r\n    \r\n    int mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n\r\n    if (x > mid) return query(segTree[idx].rg, x, y);\r\n    else if (y <= mid) return query(segTree[idx].lf, x, y);\r\n    else return query(segTree[idx].lf, x, mid) + query(segTree[idx].rg, mid + 1, y);\r\n}\r\n\r\nsigned main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\n    int n, q; cin >> n >> q;\r\n\r\n    segTree[1].l = 1; segTree[1].r = n;\r\n\r\n    while (q--) {\r\n        int t; cin >> t;\r\n        \r\n        if (t == 1) {\r\n            int l, r, x; cin >> l >> r >> x;\r\n            update(1, l, r, x);\r\n        } else {\r\n            int l, r; cin >> l >> r;\r\n            cout << query(1, l, r) << '\\n';\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "itsLQ",
        "id": 359082,
        "date": "2023-12-08 23:05:45",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nint A[100000];\r\n\r\nstruct node {\r\n    node *lc, *rc;\r\n    int l, r, m, w;\r\n    long long v = 0, dv = 0;\r\n    \r\n    node(int S, int E) {\r\n        l = S;\r\n        r = E;\r\n        m = (l + r) / 2;\r\n        w = r - l + 1;\r\n        if (l != r) {\r\n            lc = NULL;\r\n            rc = NULL;\r\n        }\r\n    }\r\n    \r\n    long long query(int S, int E) {\r\n        if (l == S && r == E) return v + dv * w;\r\n        if (E <= m) {\r\n            if (lc == NULL) lc = new node(l, m);\r\n            return lc -> query(S, E) + dv * (E - S + 1);\r\n        }\r\n        if (S > m) {\r\n            if (rc == NULL) rc = new node(m + 1, r);\r\n            return rc -> query(S, E) + dv * (E - S + 1);\r\n        }\r\n        \r\n        if (lc == NULL) lc = new node(l, m);\r\n        if (rc == NULL) rc = new node(m + 1, r);\r\n        return lc -> query(S, m) + rc -> query(m + 1, E) + dv * (E - S + 1);\r\n    }\r\n    \r\n    void update(int S, int E, int D) {\r\n        if (lc == NULL) lc = new node(l, m);\r\n        if (rc == NULL) rc = new node(m + 1, r);\r\n\r\n        if (l == S && r == E) {\r\n            dv += D;\r\n            return;\r\n        }\r\n        else if (E <= m) lc -> update(S, E, D);\r\n        else if (S > m) rc -> update(S, E, D);\r\n        else {\r\n            lc -> update(S, m, D); \r\n            rc -> update(m + 1, E, D);\r\n        }\r\n        \r\n        v = lc -> v + rc -> v + lc -> dv * lc -> w + rc -> dv * rc -> w;\r\n    }\r\n} *root;\r\n\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    \r\n    int N, Q, a, b, c, T; cin >> N >> Q;\r\n    root = new node(1, N);\r\n    \r\n    for (int i = 0; i < Q; i++) {\r\n        cin >> T >> a >> b;\r\n        if (T == 1) {\r\n            cin >> c;\r\n            root -> update(a, b, c);\r\n        } else {\r\n            cout << root -> query(a, b) << endl;\r\n        }\r\n    }\r\n\t\r\n\treturn 0;\r\n}"
    },
    {
        "username": "TheRaptor",
        "id": 359074,
        "date": "2023-12-08 22:58:51",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node {\r\n    node *left, *right;\r\n    int S, E, val, lazy;\r\n    node(int _s, int _e) : S(_s), E(_e) {\r\n        left = right = nullptr;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void prop(){\r\n        if(S == E) return;\r\n        int M = (S + E) / 2;\r\n        if(left == nullptr){ // no children\r\n            left = new node(S, M);\r\n            right = new node(M + 1, E);\r\n        }\r\n        if(lazy != 0){\r\n            // need to add lazy to left and right children\r\n            left->val += lazy * (M - S + 1);\r\n            left->lazy += lazy;\r\n            right->val += lazy * (E - M);\r\n            right->lazy += lazy;\r\n            // reset lazy tag\r\n            lazy = 0;\r\n        }\r\n    }\r\n    int qry(int l, int r) { // sum from index l to index r\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return 0;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            return val;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        return left->qry(l, r) + right->qry(l, r);\r\n    }\r\n    void upd(int l, int r, int v) {\r\n        if (l > E || r < S) {\r\n            // current node is completely outside of [l, r]\r\n            return;\r\n        }\r\n        if (l <= S && E <= r) {\r\n            // current node is completely covered by [l, r]\r\n            // update the value of the node and the lazy tag, do not recurse\r\n            val += v * (E - S + 1); // all E - S + 1 nodes has their value increased\r\n            lazy += v;\r\n            return;\r\n        }\r\n        // remember to propagate\r\n        prop();\r\n        // recurse to both children\r\n        left->upd(l, r, v);\r\n        right->upd(l, r, v);\r\n        // update current node value\r\n        val = left->val + right->val;\r\n    }\r\n} *root;\r\n\r\nint32_t main(){\r\n\tios_base::sync_with_stdio(false);cin.tie(0);\r\n\troot=new node(1,1e9);\r\n\tint n,q;\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; i++){\r\n\t\tint aa,b,c;\r\n\t\tcin >> aa >> b >> c;\r\n\t\tif(aa==1){\r\n\t\t\tint d;\r\n\t\t\tcin >> d;\r\n\t\t\troot->upd(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << root->qry(b,c) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "TheRaptor",
        "id": 359069,
        "date": "2023-12-08 22:51:48",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node {\r\n\tnode *left, *right;\r\n\tint S, E, val, lazy;\r\n\tnode(int _s, int _e) : S(_s), E(_e) {\r\n\t\tleft = right = nullptr;\r\n\t\tval = 0;\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid prop(){\r\n\t\tif(S == E) return;\r\n\t\tint M = (S + E) / 2;\r\n\t\tif(left == nullptr){\r\n\t\t\tleft = new node(S, M);\r\n\t\t\tright = new node(M + 1, E);\r\n\t\t}\r\n\t\tif(lazy != 0){\r\n\t\t\t// need to add lazy to left and right children\r\n\t\t\tleft->val += lazy * (M - S + 1);\r\n\t\t\tleft->lazy += lazy;\r\n\t\t\tright->val += lazy * (E - M);\r\n\t\t\tright->lazy += lazy;\r\n\t\t\t// reset lazy tag\r\n\t\t\tlazy = 0;\r\n\t\t}\r\n\t}\r\n\tint qry(int l, int r) { // sum from index l to index r\r\n\t\tif (l > E || r < S) {\r\n\t\t\t// current node is completely outside of [l, r]\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (l <= S && E <= r) {\r\n\t\t\t// current node is completely covered by [l, r]\r\n\t\t\treturn val;\r\n\t\t}\r\n\t\t// remember to propagate\r\n\t\tprop();\r\n\t\t// recurse to both children\r\n\t\treturn left->qry(l, r) + right->qry(l, r);\r\n\t}\r\n\tvoid upd(int l, int r, int v) {\r\n\t\tif (l > E || r < S) {\r\n\t\t\t// current node is completely outside of [l, r]\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (l <= S && E <= r) {\r\n\t\t\t// current node is completely covered by [l, r]\r\n\t\t\t// update the value of the node and the lazy tag, do not recurse\r\n\t\t\tval += v * (E - S + 1); // all E - S + 1 nodes has their value increased\r\n\t\t\tlazy += v;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// remember to propagate\r\n\t\tprop();\r\n\t\t// recurse to both children\r\n\t\tleft->upd(l, r, v);\r\n\t\tright->upd(l, r, v);\r\n\t\t// update current node value\r\n\t\tval = left->val + right->val;\r\n\t}\r\n} *root;\r\n\r\nint32_t main(){\r\n\tios_base::sync_with_stdio(false);cin.tie(0);\r\n\troot=new node(1,1e9);\r\n\tint n,q;\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; i++){\r\n\t\tint aa,b,c;\r\n\t\tcin >> aa >> b >> c;\r\n\t\tif(aa==1){\r\n\t\t\tint d;\r\n\t\t\tcin >> d;\r\n\t\t\troot->upd(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << root->qry(b,c) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "dacashew",
        "id": 358567,
        "date": "2023-12-08 11:40:52",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define test cout<<\"test\"<<endl\r\n#define endl \"\\n\"\r\n#define exit return 0\r\n#define iloop(n) for(int i=0;i<n;i++)\r\n#define jloop(n) for(int j=0;j<n;j++)\r\n#define kloop(n) for(int k=0;k<n;k++)\r\n#define pb push_back\r\n#define pf push_front\r\n#define makepair(a,b) {a,b}\r\n#define coutpair(p) cout<<p.first<<\" \"<<p.second<<endl;\r\n#define hashmap unordered_map\r\n#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\nint n;\r\nhashmap<int,int> fw;\r\nhashmap<int,int> fw2;\r\nvoid update(int x,int y,int v){\r\n\tfor(int i=x;i<=n;i+=i&-i){\r\n\t\tfw[i]+=v;\r\n\t\tfw2[i]-=v*(x-1);\r\n\t}\r\n\tfor(int i=y+1;i<=n;i+=i&-i){\r\n\t\tfw[i]-=v;\r\n\t\tfw2[i]+=v*y;\r\n\t}\r\n}\r\nint sum(int x){\r\n\tint s=0;\r\n\tfor(int i=x;i>0;i-=i&-i){\r\n\t\ts+=fw[i]*x+fw2[i];\r\n\t}\r\n\treturn s;\r\n}\r\nint range_sum(int x,int y){\r\n\treturn sum(y)-sum(x-1);\r\n}\r\nvoid printfw(){\r\n\tiloop(n){\r\n\t\tcout<<range_sum(i+1,i+1)<<' ';\r\n\t}\r\n\tcout<<endl;\r\n}\r\nsigned main(){\r\n\tfastio\r\n\tcin>>n;\r\n\tint m;\r\n\tcin>>m;\r\n\tiloop(m){\r\n\t\tint a;\r\n\t\tcin>>a;\r\n\t\tif(a==2){\r\n\t\t\tint x,y;\r\n\t\t\tcin>>x>>y;\r\n\t\t\tcout<<range_sum(x,y)<<endl;\r\n\t\t} else{\r\n\t\t\tint x,y,v;\r\n\t\t\tcin>>x>>y>>v;\r\n\t\t\tupdate(x,y,v);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n"
    },
    {
        "username": "Pan",
        "id": 358361,
        "date": "2023-12-07 21:52:56",
        "code": "#include <bits/stdc++.h>\r\ntypedef long long ll;\r\nusing namespace std;\r\n\r\nstruct node{\r\n    int s, e, m; //range is [s,e], m is the middle point\r\n    ll val; //sum of [s,e]\r\n    ll lazy; //lazy tag of [s,e]\r\n    node *l, *r; //create two children l and r, where l is [s,m] and [m+1,e]\r\n    node (int S, int E){ //constructor called node\r\n       s = S, e = E, m = (s+e)/2;\r\n       val = 0; //initially all values are 0\r\n       lazy = 0; //lazy tag of 0 will mean there is no update (sentinel value)\r\n       l=r=nullptr;\r\n\r\n\t}\r\n\tvoid create()\r\n\t{\r\n\t\tif(s != e && l==nullptr){ //node is not yet a leaf, so create two children\r\n\t\t     l = new node(s, m); //create left child\r\n             r = new node(m+1, e); //create right child\r\n\t\t }\r\n\t}\r\n \r\n    void propogate(){\r\n       if (lazy==0) return; //nothing happens\r\n       create();\r\n       val+=lazy*(e-s+1); //(e-s+1) is the length of the range\r\n       if (s != e){ //not a leaf, send lazy tags to children\r\n           l->lazy+=lazy;\r\n           r->lazy+=lazy;\r\n       }\r\n       lazy=0; //set our lazy tag value back to the sentinel\r\n    }\r\n    void update(int S, int E, ll V){ //increment [S,E] by V\r\n       if(s==S && e==E) lazy += V; //update covers range, update lazy tag\r\n       else{ //go we have to go deeper\r\n\t\t   create();\r\n           if(E <= m) l->update(S, E, V); //[S,E] is in the left child\r\n           else if (m < S) r->update(S, E, V); //[S,E] is in the right child\r\n           else l->update(S, m, V),r->update(m+1, E, V);\r\n           l->propogate(),r->propogate();\r\n           //remember to propogate your children before update yourself\r\n           val = l->val + r->val; //update the range sum\r\n       }\r\n    }\r\n    ll query(int S, int E){\r\n       propogate(); //remember to propogate\r\n       if(s == S && e == E) return val; //case 1\r\n       create();\r\n       if(E <= m) return l->query(S, E); //case 2, recurse to left child\r\n       else if(S >= m+1) return r->query(S, E); //case 3, recurse to right child\r\n       else return l->query(S, m) + r->query(m+1, E); //case 4, split the query range, recurse to both childs\r\n}\r\n} *root;\r\n\r\nint main()\r\n{\r\n\tll n,q,t, l, r,k;\r\n\t\r\n\tcin >> n >> q;\r\n\troot = new node(1,n);\r\n\twhile (q--)\r\n\t{\r\n\t\tcin >> t;\r\n\t\tif (t==1)\r\n\t\t{\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\troot-> update(l,r,k);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root-> query(l,r) << endl;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\treturn 0;\r\n}"
    },
    {
        "username": "a",
        "id": 357744,
        "date": "2023-12-06 21:17:19",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n//must initialise pointers to NULL or else will not equal to null pointer\r\n//node containing N may exist when node for N iteself may not\r\n//for update value ven if not reached update nodes, must still assign parent's lazy to child nodes\r\n//must have two values bc after pass lazy on, parent node still retains original value\r\n//even if node was never the full range, if full rang eis in node shld still alter\r\n//start to end and upstart to upend mixup -_- (literally like the fifth time...)\r\n#define int long long\r\n\r\nstruct Node\r\n{\r\n\tint start, end, lazy = 0, value = 0;\r\n\tNode *left = NULL, *right = NULL;\r\n\t\r\n\tNode (int s, int e)\r\n\t{\r\n\t\tstart = s; end = e;\r\n\t\t//cout << \"created node \" << s << \" \" << e << '\\n';\r\n\t}\r\n\t\r\n\tvoid update(int upstart, int upend, int val)\r\n\t{\r\n \t\tvalue += (val * (upend - upstart + 1));\r\n\t\tif (start != end)\r\n\t\t{\r\n\t\t\tif (left == nullptr)\r\n\t\t\t{\r\n\t\t\t\tleft = new Node(start, (start + end)/2);\r\n\t\t\t\tright = new Node ((start + end)/2 + 1, end);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((upstart == start) && (upend == end))\r\n\t\t{\r\n\t\t\tif (start != end)\r\n\t\t\t{\r\n\t\t\t\t(left -> lazy) += val;\r\n\t\t\t\t(right -> lazy) += val;\r\n\t\t\t}\t\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (upstart <= ((start + end) / 2))\r\n\t\t{\r\n\t\t\tleft -> update(upstart, min(upend,(start + end) / 2), val);\r\n\t\t}\r\n\t\tif (upend > ((start + end) / 2))\r\n\t\t{\r\n\t\t\tright -> update(max(upstart, (start + end) / 2 + 1), upend, val);\r\n\t\t}\r\n\t}\r\n\t\r\n\tint query(int qstart, int qend)\r\n\t{\r\n\t\tvalue += (lazy * (end - start + 1));\r\n\t\t//cout << \"from \" << start << \" to \" << end << \" value is \" << value << \"\\n\";\r\n\t\tif (start != end)\r\n\t\t{\r\n\t\t\tif (left == nullptr)\r\n\t\t\t{\r\n\t\t\t\tleft = new Node(start, (end + start)/2);\r\n\t\t\t\tright = new Node ((start + end) /2 + 1, end);\r\n\t\t\t}\r\n\t\t\t(left -> lazy) += lazy;\r\n\t\t\t(right -> lazy) += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t\tif ((qstart == start) && (qend == end))\r\n\t\t{\r\n\t\t\t//cout << \"returning \" << value << \" from \" << start << \" \" << end << \"\\n\";\r\n\t\t\treturn value;\r\n\t\t}\r\n\t\t\r\n\t\tint ans = 0;\r\n\t\tif (qstart <= ((start + end) / 2))\r\n\t\t{\r\n\t\t\tans += left -> query(qstart, min(qend, (start + end) / 2));\r\n\t\t}\r\n\t\tif (qend > ((start + end) / 2))\r\n\t\t{\r\n\t\t\tans += right -> query(max(qstart, (start +end)/ 2 + 1), qend);\r\n\t\t}\r\n\t\t//cout << \"returning \" << ans << \" from \" << start << \" \" << end << \"\\n\";\r\n\t\treturn ans;\r\n\t}\r\n}*root;\r\n\r\nsigned main()\r\n{\r\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\r\n\t//cout << \"made it to the start!\\n\";\r\n\tint N,Q, type, start, end, increment, ans;\r\n\tcin >> N >> Q;\r\n\t\r\n\troot = new Node(1,N);\r\n\t\r\n\tfor (int a = 0; a < Q; a++)\r\n\t{\r\n\t\tcin >> type;\r\n\t\tif (--type)\r\n\t\t{\r\n\t\t\t//cout << \"query \" << a << \"\\n\";\r\n\t\t\tcin >> start >> end;\r\n\t\t\tans = root -> query(start,end);\r\n\t\t\tcout << ans << \"\\n\";\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t//cout << \"update \" << a << \"\\n\";\r\n\t\t\tcin >> start >> end >> increment;\r\n\t\t\troot -> update(start,end,increment);\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "bz",
        "id": 356789,
        "date": "2023-12-06 14:10:14",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\n\r\n#define ll long long\r\n#define pll pair<ll, ll>\r\n#define coutpair(p) cout << p.first << \" \" << p.second << \"\\n\"\r\n#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n\r\nint main(){\r\n    ios_base::sync_with_stdio(0); \r\n    cin.tie(0); \r\n    cout.tie(0);\r\n\r\n    ll n, q, t, l, r, k; cin >> n >> q;\r\n    root = new node(0, 1000000000);\r\n    for (int i=0; i<q; i++){\r\n        cin >> t;\r\n        if (t == 1){\r\n            cin >> l >> r >> k;\r\n            root->add(l, r, k);\r\n        }\r\n        else{\r\n            cin >> l >> r;\r\n            cout << root->range_sum(l, r) << \"\\n\";\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}"
    },
    {
        "username": "PaNic",
        "id": 355591,
        "date": "2023-12-06 03:49:05",
        "code": "#include <cstdio>\r\n#include <queue>\r\nusing namespace std;\r\n\r\nstruct node {\r\n\tnode *lc, *rc;\r\n\tlong long sum;\r\n\tint increment;\r\n\tnode() : lc(nullptr), rc(nullptr), sum(0), increment(0) {}\r\n\tvoid down(int l, int r) {\r\n\t\tif (!lc) lc = new node();\r\n\t\tif (!rc) rc = new node();\r\n\t\tif (!increment) return;\r\n\t\tlc->increment += increment;\r\n\t\trc->increment += increment;\r\n\t\tsum += (long long) increment * (r - l);\r\n\t\tincrement = 0;\r\n\t}\r\n\tvoid up() {\r\n\t\tsum = lc->sum + rc->sum;\r\n\t}\r\n\tvoid upd(int x, int y, int v, int l, int r) {\r\n\t\tif (x <= l && r <= y) {\r\n\t\t\tincrement += v;\r\n\t\t\tdown(l, r);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tdown(l, r);\r\n\t\tif (r <= x || y <= l)\r\n\t\t\treturn;\r\n\t\tlc->upd(x, y, v, l, l + r >> 1);\r\n\t\trc->upd(x, y, v, l + r >> 1, r);\r\n\t\tup();\r\n\t}\r\n\tlong long qry(int x, int y, int l, int r) {\r\n\t\tif (r <= x || y <= l)\r\n\t\t\treturn 0;\r\n\t\tdown(l, r);\r\n\t\tif (x <= l && r <= y)\r\n\t\t\treturn sum;\r\n\t\treturn lc->qry(x, y, l, l + r >> 1) +\r\n\t\t\trc->qry(x, y, l + r >> 1, r);\r\n\t}\r\n};\r\nint main() {\r\n\tint n, q;\r\n\tscanf(\"%d%d\", &n, &q);\r\n\tnode segtree;\r\n\twhile (q--) {\r\n\t\tint t;\r\n\t\tscanf(\"%d\", &t);\r\n\t\tif (t == 1) {\r\n\t\t\tint l, r, k;\r\n\t\t\tscanf(\"%d%d%d\", &l, &r, &k);\r\n\t\t\t--l;\r\n\t\t\tsegtree.upd(l, r, k, 0, n);\r\n\t\t} else if (t == 2) {\r\n\t\t\tint l, r;\r\n\t\t\tscanf(\"%d%d\", &l, &r);\r\n\t\t\t--l;\r\n\t\t\tprintf(\"%lld\\n\", segtree.qry(l, r, 0, n));\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "Kiameimon",
        "id": 355588,
        "date": "2023-12-06 03:43:09",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n#define pii pair<int,int>\r\n#define elif else if\r\n\r\nstruct FenwickTree{\r\n\tunordered_map<int,int> fwt; int n;\r\n\t\r\n\tFenwickTree(int n){\r\n\t\tthis->n = n+1;\r\n\t}\r\n\tvoid update(int pos, int val){\r\n\t\tfor(;pos < n; pos += pos & -pos)\r\n\t\t\tfwt[pos] += val;\r\n\t}\r\n\tint sum(int ind){\r\n\t\tint ret = 0;\r\n\t\tfor(;ind > 0; ind -= ind & -ind)\r\n\t\t\tret += fwt[ind];\r\n\t\treturn ret;\r\n\t}\r\n\tint query(int l, int r){\r\n\t\treturn sum(r)-sum(l-1);\r\n\t}\r\n};\r\n\r\nsigned main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(0);\r\n\t\r\n\tint n, tc; cin >> n >> tc;\r\n\tFenwickTree fwt1(n);\r\n\tFenwickTree fwt2(n);\r\n\t\r\n\twhile(tc--){\r\n\t\tint q; cin >> q;\r\n\t\tif(q == 1){\r\n\t\t\tint l, r, val; cin >> l >> r >> val;\r\n\t\t\tfwt1.update(l, val); fwt1.update(r+1, -val);\r\n\t\t\tfwt2.update(l, -(l-1)*val); fwt2.update(r+1, r*val);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint l, r; cin >> l >> r;\r\n\t\t\tcout << fwt1.query(1,r)*r+fwt2.query(1,r)-fwt1.query(1,l-1)*(l-1)-fwt2.query(1,l-1) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn 0;\r\n}\r\n"
    },
    {
        "username": "bz",
        "id": 355390,
        "date": "2023-12-05 22:10:48",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\n\r\n#define ll long long\r\n#define pll pair<ll, ll>\r\n#define coutpair(p) cout << p.first << \" \" << p.second << \"\\n\"\r\n\r\nint main(){\r\n    ios_base::sync_with_stdio(0); \r\n    cin.tie(0); \r\n    cout.tie(0);\r\n\r\n    ll n, q, t, l, r, k; cin >> n >> q;\r\n    root = new node(0, 1000000000);\r\n    for (int i=0; i<q; i++){\r\n        cin >> t;\r\n        if (t == 1){\r\n            cin >> l >> r >> k;\r\n            root->add(l, r, k);\r\n        }\r\n        else{\r\n            cin >> l >> r;\r\n            cout << root->range_sum(l, r) << \"\\n\";\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}"
    },
    {
        "username": "user123",
        "id": 353733,
        "date": "2023-12-04 14:34:24",
        "code": "// livin' for the hope of it all\r\n\r\n#include <iostream>\r\n#include <cassert>\r\nusing namespace std;\r\n\r\n#define int long long\r\nconst int N=100013;\r\nint n, m;\r\n\r\nstruct node\r\n{\r\n#define lv lptr->v\r\n#define rv rptr->v\r\n#define llazy lptr->lazy\r\n#define rlazy rptr->lazy\r\n    \r\n    int l, r, mid;\r\n    int v, lazy;\r\n    node *lptr, *rptr;\r\n    \r\n    node(int L, int R)\r\n    {\r\n        l=L; r=R; mid=(l+r)>>1;\r\n        v=lazy=0;\r\n\t\tlptr=rptr=nullptr;\r\n    }\r\n\tvoid build()\r\n\t{\r\n\t\tif (lptr==nullptr) lptr=new node(l, mid);\r\n\t\tif (rptr==nullptr) rptr=new node(mid+1, r);\r\n\t}\r\n    void update(int pos, int val)\r\n    {\r\n        if (l==r)\r\n        {\r\n            assert(l==pos);\r\n            v=val;\r\n            return;\r\n        }\r\n\t\tbuild();\r\n        pushdown();\r\n        if (pos<=mid) lptr->update(pos, val);\r\n        else rptr->update(pos, val);\r\n        v=lv+rv;\r\n    }\r\n    void update(int x, int y, int val)\r\n    {\r\n        if (x==l && r==y)\r\n        {\r\n            lazy+=val;\r\n            v+=val*(r-l+1);\r\n            return;\r\n        }\r\n\t\tbuild();\r\n        pushdown();\r\n        if (y<=mid) lptr->update(x, y, val);\r\n        else if (x>=mid+1) rptr->update(x, y, val);\r\n        else\r\n        {\r\n            lptr->update(x, mid, val);\r\n            rptr->update(mid+1, y, val);\r\n        }\r\n        v=lv+rv;\r\n    }\r\n    int query(int pos)\r\n    {\r\n        if (l==r)\r\n        {\r\n            assert(l==pos);\r\n            return v;\r\n        }\r\n\t\tbuild();\r\n        pushdown();\r\n        if (pos<=mid) return lptr->query(pos);\r\n        else return rptr->query(pos);\r\n    }\r\n    int query(int x, int y)\r\n    {\r\n        if (x==l && r==y) return v;\r\n\t\tbuild();\r\n        pushdown();\r\n        if (y<=mid) return lptr->query(x, y);\r\n        else if (x>=mid+1) return rptr->query(x, y);\r\n        else return lptr->query(x, mid) + rptr->query(mid+1, y);\r\n    }\r\n    void pushdown()\r\n    {\r\n        if (lazy==0) return;\r\n        llazy+=lazy;\r\n        lv+=lazy*(mid-l+1);\r\n        rlazy+=lazy;\r\n        rv+=lazy*(r-mid);\r\n        lazy=0;\r\n    }\r\n} *segtree;\r\n\r\nsigned main()\r\n{\r\n    cin>>n>>m;\r\n    segtree=new node(0, n-1);\r\n    \r\n    while (m--)\r\n    {\r\n        int t; cin>>t;\r\n        if (t==1)\r\n        {\r\n            int x, y, val; cin>>x>>y>>val; x--; y--;\r\n            segtree->update(x, y, val);\r\n        }\r\n        else\r\n        {\r\n            int x, y; cin>>x>>y; x--; y--;\r\n            cout<<segtree->query(x, y)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "eulerleonhardfan",
        "id": 350744,
        "date": "2023-12-01 20:06:46",
        "code": "//Yixiang is a trivial problem in China\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long \r\n#define debug(x) cerr << #x << \" is \" << x << \"\\n\";\r\n#define test cout << \"test\\n\";\r\n#define hehe ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\nstruct node {\r\n\tint S, E;\r\n\tint val = 0, lazy = 0;\r\n\tnode *left = NULL, *right = NULL;\r\n\tnode (int s, int e) {\r\n\t\tS = s;\r\n\t\tE = e;\r\n\t\tval = 0;\r\n\t}\r\n\tvoid create() {\r\n\t\tint M = (S+E)/2;\r\n\t\tif (S != E) {\r\n\t\t\tleft = new node(S, M);\r\n\t\t\tright = new node(M+1, E);\r\n\t\t}\r\n\t}\r\n\tvoid propagate() {\r\n\t\tif (left == NULL or right == NULL) create();\r\n\t\tif (lazy == 0) return;\r\n\t\tval += lazy*(E-S+1);\r\n\t\tif (S != E) {\r\n\t\t\tleft -> lazy += lazy;\r\n\t\t\tright -> lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid update(int us, int ue, int v) {\r\n\t\tint M = (S+E)/2;\r\n\t\tpropagate();\r\n\t\tif (S == us and E == ue) {\r\n\t\t\tlazy += v;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (ue <= M) left -> update(us, ue, v);\r\n\t\telse if (us >= M+1) right -> update(us, ue, v);\t\r\n\t\telse {\r\n\t\t\tleft -> update(us, M, v);\r\n\t\t\tright -> update(M+1, ue, v);\r\n\t\t}\r\n\t\tleft -> propagate();\r\n\t\tright -> propagate();\r\n\t\tval = left -> val + right -> val;\r\n\t}\t\r\n\tint query(int qs, int qe) {\r\n\t\tint M = (S+E)/2;\r\n\t\tpropagate();\r\n\t\tif (S == qs and E == qe) return val; \r\n\t\tif (qe <= M) return left -> query(qs, qe);\r\n\t\tif (qs >= M+1) return right -> query(qs, qe);\r\n\t\telse return left -> query(qs, M) + right -> query(M+1, qe);\r\n\t}\r\n} *root;\r\nint32_t main() {\r\n\tint n, q;\r\n\tcin >> n >> q;\r\n\troot = new node(0, n+5);\r\n\twhile (q--) {\r\n\t\tint op; cin >> op;\r\n\t\tif (op == 1) {\r\n\t\t\tint l, r, k;\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\troot -> update(l, r, k);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root -> query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "Tyx2019",
        "id": 350606,
        "date": "2023-12-01 16:36:10",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nstruct node{\r\n  int S,E,M,V,ladd;\r\n  node *l,*r;\r\n  node(int s,int e){\r\n    S=s;\r\n    E=e;\r\n    M=(S+E)>>1;\r\n    V=0;\r\n    l=r=NULL;\r\n    ladd=0;\r\n  }\r\n  void makenodes(){\r\n    if(!l) l=new node(S,M);\r\n    if(!r) r=new node(M+1,E);\r\n  }\r\n  void update(int s,int e,int k){\r\n\r\n    makenodes();\r\n    if(ladd){\r\n      V+=(E-S+1)*ladd;\r\n      l->ladd+=ladd;\r\n      r->ladd+=ladd;\r\n      ladd=0;\r\n    }\r\n    if(s==S&&e==E){\r\n      V+=k*(E-S+1);\r\n      l->ladd+=k;\r\n      r->ladd+=k;\r\n      return;\r\n    }\r\n    else if(s>M){\r\n      r->update(s,e,k);\r\n      l->update(S, M, 0);\r\n    }\r\n    else if(e<=M) {l->update(s,e,k); r->update(M+1, E, 0);}\r\n    else{\r\n      l->update(s,M,k);\r\n      r->update(M+1,e,k);\r\n    }\r\n    V=l->V+r->V;\r\n  }\r\n  int qry(int s,int e){\r\n    makenodes();\r\n    if(ladd){\r\n      V+=(E-S+1)*ladd;\r\n      l->ladd+=ladd;\r\n      r->ladd+=ladd;\r\n      ladd=0;\r\n    }\r\n    if(s<=S&&e>=E){\r\n      return V;\r\n    }\r\n    else if(s>M){\r\n      return r->qry(s,e);\r\n    }\r\n    else if(e<=M) return l->qry(s,e);\r\n    else{\r\n      return l->qry(s,M) + r->qry(M+1,e);\r\n    }\r\n  }\r\n}*seggs;\r\n\r\nsigned main(){\r\n  int N,Q;\r\n  cin >> N >> Q;\r\n  seggs=new node(0,N+5);\r\n  for(int i=0;i<Q;i++){\r\n\r\n    int op;\r\n    cin >> op;\r\n    if(op==1){\r\n      int x,y,z;\r\n      cin >> x >> y >> z;\r\n      seggs->update(x,y,z);\r\n    }\r\n    else{\r\n      int x,y;\r\n      cin >> x >> y;\r\n      cout << seggs->qry(x,y) << \"\\n\";\r\n    }\r\n  }\r\n}\r\n"
    },
    {
        "username": "back2square1",
        "id": 348673,
        "date": "2023-11-28 22:16:51",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define pi pair<int,int>\r\n#define vi vector<int>\r\n#define si set<int>\r\n#define mi multiset<int>\r\n#define usi unordered_set<int>\r\n#define dqi deque<int>\r\n#define pqi priority_queue<int>\r\n#define rpqi priority_queue< int, vector<int>, greater<int> >\r\n#define sci static_cast<int>\r\n#define sz(_a) sci(_a.size())\r\n#define all(_a) begin((_a)), end((_a))\r\n#define als(_a,_n) _a, _a+N\r\n#define als1(_a,_n) _a+1, _a+N+1\r\n#define pb push_back\r\n#define pf push_front\r\n#define fs first\r\n#define sc second\r\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define input(_n) cin>>_n\r\n#define input2(_n1,_n2) cin>>_n1>>_n2\r\n#define input3(_n1,_n2,_n3) cin>>_n1>>_n2>>_n3\r\n#define printst(_a) cout<<(_a)<<'\\n'\r\n#define printnm(_a) cout<<(#_a)<<' '<<(_a)<<'\\n'\r\n#define printnl cout << '\\n'\r\n#define lsb(_a) (_a & (-_a))\r\n#define median(_a,_n) (_a[_n/2]+a[(_n-1)/2])/2;\r\n#define fri(_n) for (int i=0; i<_n; ++i)\r\n#define fri1(_n) for (int i=1; i<=_n; ++i)\r\n#define fr(_i,_n) for (int _i=0; _i<_n; ++_i)\r\n#define fr1(_i,_n) for (int _i=1; _i<=_n; ++_i)\r\n#define e0(_s) (*(begin(_s)))\r\n#define e1(_s) (*(next(begin(_s),1)))\r\n#define ele(_s,_n) (*(next(begin(_s),n)))\r\n#define min3(_a,_b,_c) min(_a,min(_b,_c))\r\n#define max3(_a,_b,_c) max(_a,max(_b,_c))\r\n#define setmax(_a,_n) _a = max(_a,_n)\r\n#define setmin(_a,_n) _a = min(_a,_n)\r\nusing namespace std;\r\n\r\n\r\nstruct Node {\r\n  int start, end, mid;\r\n  int val; \r\n  int lazy; // for lazy propagation\r\n  \r\n  Node *l, *r; \r\n\r\n  Node (int S, int E) { // constructor\r\n    start = S; end = E; mid = (start+end) >> 1;\r\n    val = 0; \r\n    lazy = 0; // initialise value to 0\r\n\r\n    \r\n  }\r\n\t\r\n  void create () {\r\n\tif (start != end) { \r\n      l = new Node (start, mid);\r\n      r = new Node (mid+1, end);\r\n    }  \r\n  }\r\n\r\n  // *the propagate function runs in O(1)*\r\n  void propagate () {\r\n\t \r\n\tif (l == nullptr) create();\r\n\t  \r\n    // if lazy == 0, there is nothing to propagate\r\n    if (lazy == 0) return; \r\n    // add the value to val\r\n    val += lazy * (end-start+1);\r\n    if (start != end) {\r\n      // if this is not a leaf node\r\n      // then send the lazy tag to the children\r\n      l->lazy += lazy;\r\n      r->lazy += lazy;\r\n    }\r\n    lazy = 0; // reset the lazy value\r\n  }\r\n\r\n  void update (int S, int E, int V) { \r\n\tif (l == nullptr) create();\r\n\t  \r\n    // increment [S,E] by V\r\n    \r\n    // if update covers the range already\r\n    if (S == start and E == end) lazy += V;\r\n    \r\n    else {\r\n      if (E <= mid) l->update(S, E, V);\r\n      else if (S > mid) r->update(S, E, V);\r\n      else l->update(S, mid, V), r->update(mid+1, E, V);\r\n\r\n      l->propagate(), r->propagate();\r\n      val = l->val + r->val;\r\n    }\r\n  }\r\n\r\n  int query (int S, int E) { \r\n\tif (l == nullptr) create();\r\n\r\n    propagate(); // propagate before query\r\n    \r\n    if (S == start and E == end) return val;\r\n    else if (E <= mid) return l->query(S, E);\r\n    else if (S > mid) return r->query(S, E);\r\n    else return l->query(S, mid) + r->query(mid+1, E);\r\n  }\r\n}; \r\n\r\nint Q, N; \r\n\r\nNode *root = new Node (1, 1e9+5);\r\n\r\nsigned main() {\r\n  fastio;\r\n  cin >> N >> Q;\r\n  \r\n  for (int i=0; i<Q; ++i) {\r\n    int t, a, b; cin >> t >> a >> b;\r\n    if (t==1) {int c; cin >> c; root->update(a,b,c);}\r\n    else cout << root->query(a,b) << '\\n';\r\n  }\r\n\r\n  return 0;\r\n}\r\n"
    },
    {
        "username": "dacashew",
        "id": 347008,
        "date": "2023-11-27 09:06:48",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define test cout<<\"test\"<<endl\r\n#define endl \"\\n\"\r\n#define exit return 0\r\n#define iloop(n) for(int i=0;i<n;i++)\r\n#define jloop(n) for(int j=0;j<n;j++)\r\n#define kloop(n) for(int k=0;k<n;k++)\r\n#define pb push_back\r\n#define pf push_front\r\n#define makepair(a,b) {a,b}\r\n#define coutpair(p) cout<<p.first<<\" \"<<p.second<<endl;\r\n#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\nstruct node{\r\n\tint s,e;\r\n\tint val;\r\n\tnode *l=NULL,*r=NULL;\r\n\tint lazy=0;\r\n\tnode(int S,int E){\r\n\t\ts=S;\r\n\t\te=E;\r\n\t\tval=0;\r\n\t}\r\n\tvoid prop(){\r\n\t\tif(l==NULL){\r\n\t\t\tcreate();\r\n\t\t}\r\n\t\tif(lazy==0){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(s!=e){\r\n\t\t\tint mid=(s+e)/2;\r\n\t\t\tl=new node(s,mid);\r\n\t\t\tr=new node(mid+1,e);\r\n\t\t}\r\n\t}\r\n\tvoid update(int S,int E,int V){\r\n\t\tprop();\r\n\t\tif(s==S and e==E){\r\n\t\t\tlazy+=V;\r\n\t\t} else{\r\n\t\t\tint mid=(s+e)/2;\r\n\t\t\tif(E<=mid){\r\n\t\t\t\tl->update(S,E,V);\r\n\t\t\t} else if(mid<S){\r\n\t\t\t\tr->update(S,E,V);\r\n\t\t\t} else{\r\n\t\t\t\tl->update(S,mid,V);\r\n\t\t\t\tr->update(mid+1,E,V);\r\n\t\t\t}\r\n\t\t\tl->prop();\r\n\t\t\tr->prop();\r\n\t\t\tval=l->val+r->val;\r\n\t\t}\r\n\t}\r\n\tint query(int S,int E){\r\n\t\tprop();\r\n\t\tif(s==S and e==E){\r\n\t\t\treturn val;\r\n\t\t} else{\r\n\t\t\tint mid=(s+e)/2;\r\n\t\t\tif(E<=mid){\r\n\t\t\t\treturn l->query(S,E);\r\n\t\t\t} else if(mid<S){\r\n\t\t\t\treturn r->query(S,E);\r\n\t\t\t} else{\r\n\t\t\t\treturn l->query(S,mid)+r->query(mid+1,E);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n} *root;\r\n\r\nsigned main(){\r\n\tfastio\r\n\tint n,k;\r\n\tcin>>n>>k;\r\n\troot=new node(0,n-1);\r\n\tiloop(k){\r\n\t\tint a;\r\n\t\tcin>>a;\r\n\t\tif(a==1){\r\n\t\t\tint x,y,z;\r\n\t\t\tcin>>x>>y>>z;\r\n\t\t\troot->update(x-1,y-1,z);\r\n\t\t} else{\r\n\t\t\tint x,y;\r\n\t\t\tcin>>x>>y;\r\n\t\t\tcout<<root->query(x-1,y-1)<<endl;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n"
    },
    {
        "username": "dacashew",
        "id": 346851,
        "date": "2023-11-26 21:03:54",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define test cout<<\"test\"<<endl\r\n#define endl \"\\n\"\r\n#define exit return 0\r\n#define iloop(n) for(int i=0;i<n;i++)\r\n#define jloop(n) for(int j=0;j<n;j++)\r\n#define kloop(n) for(int k=0;k<n;k++)\r\n#define pb push_back\r\n#define pf push_front\r\n#define makepair(a,b) {a,b}\r\n#define coutpair(p) cout<<p.first<<\" \"<<p.second<<endl;\r\n#define fastio ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\nstruct node{\r\n\tint s,e;\r\n\tint val;\r\n\tnode *l=NULL,*r=NULL;\r\n\tint lazy=0;\r\n\tnode(int S,int E){\r\n\t\ts=S;\r\n\t\te=E;\r\n\t\tval=0;\r\n\t}\r\n\tvoid prop(){\r\n\t\tif(l==NULL){\r\n\t\t\tcreate();\r\n\t\t}\r\n\t\tif(lazy==0){\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(s!=e){\r\n\t\t\tint mid=(s+e)/2;\r\n\t\t\tl=new node(s,mid);\r\n\t\t\tr=new node(mid+1,e);\r\n\t\t}\r\n\t}\r\n\tvoid update(int S,int E,int V){\r\n\t\tif(l==NULL){\r\n\t\t\tcreate();\r\n\t\t}\r\n\t\tprop();\r\n\t\tif(s==S and e==E){\r\n\t\t\tlazy+=V;\r\n\t\t} else{\r\n\t\t\tint mid=(s+e)/2;\r\n\t\t\tif(E<=mid){\r\n\t\t\t\tl->update(S,E,V);\r\n\t\t\t} else if(mid<S){\r\n\t\t\t\tr->update(S,E,V);\r\n\t\t\t} else{\r\n\t\t\t\tl->update(S,mid,V);\r\n\t\t\t\tr->update(mid+1,E,V);\r\n\t\t\t}\r\n\t\t\tl->prop();\r\n\t\t\tr->prop();\r\n\t\t\tval=l->val+r->val;\r\n\t\t}\r\n\t}\r\n\tint query(int S,int E){\r\n\t\tif(l==NULL){\r\n\t\t\tcreate();\r\n\t\t}\r\n\t\tprop();\r\n\t\tif(s==S and e==E){\r\n\t\t\treturn val;\r\n\t\t} else{\r\n\t\t\tint mid=(s+e)/2;\r\n\t\t\tif(E<=mid){\r\n\t\t\t\treturn l->query(S,E);\r\n\t\t\t} else if(mid<S){\r\n\t\t\t\treturn r->query(S,E);\r\n\t\t\t} else{\r\n\t\t\t\treturn l->query(S,mid)+r->query(mid+1,E);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n} *root;\r\nsigned main(){\r\n\tfastio\r\n\tint n,k;\r\n\tcin>>n>>k;\r\n\troot=new node(0,n-1);\r\n\tiloop(k){\r\n\t\tint a;\r\n\t\tcin>>a;\r\n\t\tif(a==1){\r\n\t\t\tint x,y,z;\r\n\t\t\tcin>>x>>y>>z;\r\n\t\t\troot->update(x-1,y-1,z);\r\n\t\t} else{\r\n\t\t\tint x,y;\r\n\t\t\tcin>>x>>y;\r\n\t\t\tcout<<root->query(x-1,y-1)<<endl;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n"
    },
    {
        "username": "Jinxuan",
        "id": 343819,
        "date": "2023-11-22 20:18:38",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define f first\r\n#define s second\r\n#define lb lower_bound\r\n#define ub upper_bound\r\n#define pb push_back\r\n#define mp make_pair\r\ntypedef pair<int, int> pii;\r\ntypedef pair<pii, int> piii;\r\ntypedef pair<int, pii> ipii;\r\n\r\nstruct node{\r\n\tint s, e, m; //range is [s,e], m is the middle point \r\n\tint val; //sum of [s,e]\r\n\tint lazy;\r\n\tnode *l, *r; //create two children 1 and r, where 1 is [s,m] and [m+1, e]\r\n\t\r\n\tnode (int S, int E){ //constructor called node\r\n\ts = S, e = E, m = (s+e)/2;\r\n\tval = 0; //initially all values are O\r\n\tlazy = 0;\r\n\t\t\r\n\t}\r\n\t\r\n\tvoid create() {\r\n\t\tif(s != e){//node is not yet a leaf, so create two children\r\n\t\t\tl = new node(s, m); //create left child\r\n\t\t\tr = new node (m+1, e); //create right child\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid propagate() {\r\n\t\tif (lazy == 0) return; //do nothing\r\n\t\tval += lazy * (e - s + 1); //size of segment\r\n\t\tif (s!=e) { //have child, send to child\r\n\t\t\tif(l == nullptr) create();\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\t\r\n\tvoid update(int S, int E, int V){ //add V to all S~E\r\n\t\tif (s == S && e == E) lazy += V; //node is leaf, update value;\r\n\t\telse{ //go down to find the leaf\r\n\t\t\tif(l == nullptr) create(); //lazily create children\r\n\t\t\t\r\n\t\t\tif (E <= m) l->update(S, E, V); //case 2, recurse to left child \r\n\t\t\telse if(S >= m+1) r->update(S, E, V); //case 3, recurse to right child \r\n\t\t\telse l->update(S, m, V), r->update(m+1, E, V); //case 4, split the query range, recurse to both childs\r\n\t\t\t\r\n\t\t\tl->propagate(); r->propagate(); //remember to propogate your children before update yourself\r\n\t\t\tval = l->val + r->val; //update the range sum\r\n\t\t}\r\n\t}\r\n\r\n\tint query (int S, int E){ //Range query\r\n\t\tif(l == nullptr) create(); //lazily create children\r\n\t\tpropagate();\r\n\t\tif (s == S && e == E) return val; //case 1\r\n\t\telse if (E <= m) return l->query(S, E); //case 2, recurse to left child \r\n\t\telse if(S >= m+1) return r->query(S, E); //case 3, recurse to right child \r\n\t\telse return l->query(S, m) + r->query(m+1, E); //case 4, split the query range, recurse to both childs\r\n\t}\r\n} *root;\r\n\r\nint32_t main() {\r\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\tint n, q, input, a, b, k; cin >> n >> q;\r\n\troot = new node(1, n);\r\n\tfor (int x = 0; x< q; x++) {\r\n\t\tcin >> input;\r\n\t\tif (input == 1) {\r\n\t\t\tcin >> a >> b >> k;\r\n\t\t\troot -> update(a, b, k);\r\n\t\t} else {\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << root -> query(a, b) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\treturn(0);\r\n}"
    },
    {
        "username": "Craftless",
        "id": 343816,
        "date": "2023-11-22 20:14:06",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define f first\r\n#define s second\r\n#define lb lower_bound\r\n#define ub upper_bound\r\n#define pb push_back\r\n#define mp make_pair\r\ntypedef pair<int, int> pii;\r\ntypedef pair<pii, int> piii;\r\ntypedef pair<int, pii> ipii;\r\n\r\n//RURQ segtree + lazy propagation\r\nstruct node{\r\n    int s, e, m; //range is [s,e], m is the middle point \r\n    int val; //sum of [s,e]\r\n    int lazy;\r\n    node *l, *r; //create two children 1 and r, where 1 is [s,m] and [m+1, e]\r\n    \r\n    node (int S, int E){ //constructor called node\r\n    s = S, e = E, m = (s+e)/2;\r\n    val = 0; //initially all values are O\r\n    lazy = 0;\r\n        \r\n    }\r\n    \r\n    void create() {\r\n        if(s != e){//node is not yet a leaf, so create two children\r\n            l = new node(s, m); //create left child\r\n            r = new node (m+1, e); //create right child\r\n        }\r\n    }\r\n    \r\n    void propagate() {\r\n\t\tif(l == nullptr) create();\r\n        if (lazy == 0) return; //do nothing\r\n        val += lazy * (e - s + 1); //size of segment\r\n        if (s!=e) { //have child, send to child\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n    \r\n    void update(int S, int E, int V){ //add V to all S~E\r\n        if (s == S && e == E) lazy += V; //node is leaf, update value;\r\n        else{ //go down to find the leaf\r\n            if(l == nullptr) create(); //lazily create children\r\n            \r\n            if (E <= m) l->update(S, E, V); //case 2, recurse to left child \r\n            else if(S >= m+1) r->update(S, E, V); //case 3, recurse to right child \r\n            else l->update(S, m, V), r->update(m+1, E, V); //case 4, split the query range, recurse to both childs\r\n            \r\n            l->propagate(); r->propagate(); //remember to propogate your children before update yourself\r\n            val = l->val + r->val; //update the range sum\r\n        }\r\n    }\r\n\r\n    int query (int S, int E){ //Range query\r\n        if(l == nullptr) create(); //lazily create children\r\n        propagate();\r\n        if (s == S && e == E) return val; //case 1\r\n        else if (E <= m) return l->query(S, E); //case 2, recurse to left child \r\n        else if(S >= m+1) return r->query(S, E); //case 3, recurse to right child \r\n        else return l->query(S, m) + r->query(m+1, E); //case 4, split the query range, recurse to both childs\r\n    }\r\n} *root;\r\n\r\nint32_t main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n    int n, q, input, a, b, k; cin >> n >> q;\r\n    root = new node(1, n);\r\n    for (int x = 0; x< q; x++) {\r\n        cin >> input;\r\n        if (input == 1) {\r\n            cin >> a >> b >> k;\r\n            root -> update(a, b, k);\r\n        } else {\r\n            cin >> a >> b;\r\n            cout << root -> query(a, b) << \"\\n\";\r\n        }\r\n    }\r\n    return(0);\r\n}\r\n"
    },
    {
        "username": "blackscreen1",
        "id": 341730,
        "date": "2023-11-20 20:08:51",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nstruct node{\r\n  int S,E,M,V,ladd;\r\n  node *l,*r;\r\n  node(int s,int e){\r\n    S=s;\r\n    E=e;\r\n    M=(S+E)>>1;\r\n    V=0;\r\n    l=r=NULL;\r\n    ladd=0;\r\n  }\r\n  void makenodes(){\r\n    if(!l) l=new node(S,M);\r\n    if(!r) r=new node(M+1,E);\r\n  }\r\n  void update(int s,int e,int k){\r\n\r\n    makenodes();\r\n    if(ladd){\r\n      V+=(E-S+1)*ladd;\r\n      l->ladd+=ladd;\r\n      r->ladd+=ladd;\r\n      ladd=0;\r\n    }\r\n    if(s==S&&e==E){\r\n      V+=k*(E-S+1);\r\n      l->ladd+=k;\r\n      r->ladd+=k;\r\n      return;\r\n    }\r\n    else if(s>M){\r\n      r->update(s,e,k);\r\n      l->update(S, M, 0);\r\n    }\r\n    else if(e<=M) {l->update(s,e,k); r->update(M+1, E, 0);}\r\n    else{\r\n      l->update(s,M,k);\r\n      r->update(M+1,e,k);\r\n    }\r\n    V=l->V+r->V;\r\n  }\r\n  int qry(int s,int e){\r\n    makenodes();\r\n    if(ladd){\r\n      V+=(E-S+1)*ladd;\r\n      l->ladd+=ladd;\r\n      r->ladd+=ladd;\r\n      ladd=0;\r\n    }\r\n    if(s<=S&&e>=E){\r\n      return V;\r\n    }\r\n    else if(s>M){\r\n      return r->qry(s,e);\r\n    }\r\n    else if(e<=M) return l->qry(s,e);\r\n    else{\r\n      return l->qry(s,M) + r->qry(M+1,e);\r\n    }\r\n  }\r\n}*seggs;\r\n\r\nsigned main(){\r\n  int N,Q;\r\n  cin >> N >> Q;\r\n  seggs=new node(0,N+5);\r\n  for(int i=0;i<Q;i++){\r\n\r\n    int op;\r\n    cin >> op;\r\n    if(op==1){\r\n      int x,y,z;\r\n      cin >> x >> y >> z;\r\n      seggs->update(x,y,z);\r\n    }\r\n    else{\r\n      int x,y;\r\n      cin >> x >> y;\r\n      cout << seggs->qry(x,y) << \"\\n\";\r\n    }\r\n  }\r\n}\r\n"
    },
    {
        "username": "ARock",
        "id": 341586,
        "date": "2023-11-20 15:55:41",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define INF LONG_LONG_MAX\r\n#define fasttt ios_base:sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\nstruct node {\r\n    int s, e, m, val, lazy;\r\n    node *l, *r;\r\n    \r\n    node (int S, int E) {\r\n        s = S, e = E, m = (s+e)/2, lazy = 0;\r\n        val = 0;\r\n    }\r\n    \r\n    void create() {\r\n        if (s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n    \r\n    void propogate() {\r\n\t\tif (l == nullptr) create();\r\n        if (lazy == 0) return;\r\n        val += lazy*(e-s+1);\r\n        if (s != e) {\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n    \r\n    void update(int S, int E, int V) {\r\n        if (l == nullptr) create();\r\n        if (s == S && e == E) lazy += V;\r\n        else {\r\n            if (E <= m) l->update(S, E, V);\r\n            else if (S > m) r->update(S, E, V);\r\n            else l->update(S, m, V), r->update(m+1, E, V);\r\n        }\r\n        \r\n        if (s != e) {\r\n            l->propogate(), r->propogate();\r\n            val = l->val + r->val;\r\n        }\r\n    }\r\n    \r\n    int query(int S, int E) {\r\n        if (l == nullptr) create();\r\n        propogate();\r\n        \r\n        if (s == S && e == E) return val;\r\n        if (E <= m) return l->query(S, E);\r\n        if (S > m) return r->query(S, E);\r\n        \r\n        return l->query(S, m) + r->query(m+1, E);\r\n    }\r\n} *root;\r\n\r\nint32_t main() {\r\n    int N, Q; cin >> N >> Q;\r\n    root = new node(1, N);\r\n    for (int i = 0; i < Q; i++) {\r\n        int inst; cin >> inst;\r\n        if (inst == 1) {\r\n            int l, r, k; cin >> l >> r >> k;\r\n            root->update(l, r, k);\r\n        } else {\r\n            int l, r; cin >> l >> r;\r\n            cout << root->query(l, r) << \"\\n\";\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "Elnathan",
        "id": 337557,
        "date": "2023-11-16 18:39:43",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint32_t main() {\r\n    ios_base::sync_with_stdio(false); cin.tie(NULL);\r\n    int n, q, qi, l, r, k;\r\n    cin >> n >> q;\r\n    root = new node(0, n);\r\n    for (int i = 0; i < q; i++) {\r\n        cin >> qi;\r\n        if (qi == 1) {\r\n            cin >> l >> r >> k;\r\n            root -> add(l, r, k);\r\n        }\r\n        else {\r\n            cin >> l >> r;\r\n            cout << root -> range_sum(l, r) << '\\n';\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "Hhw48",
        "id": 337550,
        "date": "2023-11-16 18:30:26",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define ll long long\r\n#define ull unsigned long long int\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint32_t main(){\r\nios_base::sync_with_stdio(0);\r\ncin.tie(0);\r\nint n,q;\r\ncin>>n>>q;\r\nroot=new node(0,n);\r\nfor(int i=0;i<q;i++){\r\n    int x,l,r,k;\r\n    cin>>x;\r\n    if(x==1){\r\n      cin>>l>>r>>k;\r\n      root->add(l,r,k);  \r\n    }\r\n    else{\r\n        cin>>l>>r;\r\n        cout<<root->range_sum(l, r)<<'\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "PlayVoltz",
        "id": 311472,
        "date": "2023-09-30 22:05:53",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node{\r\n\tint s, e, m, val, lazy;\r\n\tnode *l, *r;\r\n\tvoid create(){\r\n\t\tif (l==nullptr){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\tvoid propagate(){\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif (s!=e){\r\n\t\t\tcreate();\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\tnode(int S, int E){\r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t\tval=lazy=0;\r\n\t\tl=r=nullptr;\r\n\t}\r\n\tvoid up(int left, int right, int v){\r\n\t\tpropagate();\r\n\t\tif (s==left && e==right)lazy+=v;\r\n\t\telse{\r\n\t\t\tcreate();\r\n\t\t\tif (right<=m)l->up(left, right, v);\r\n\t\t\telse if (left>m)r->up(left, right, v);\r\n\t\t\telse l->up(left, m, v), r->up(m+1, right, v);\r\n\t\t\tr->propagate(), l->propagate();\r\n\t\t\tval=l->val+r->val;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\tint query(int left, int right){\r\n\t\tpropagate();\r\n\t\tif (s==left && e==right)return val;\r\n\t\tcreate();\r\n\t\tif (right<=m)return l->query(left, right);\r\n\t\telse if (left>m)return r->query(left, right);\r\n\t\telse return l->query(left, m)+r->query(m+1, right);\r\n\t}\r\n}*st;\r\n\r\nint32_t main(){\r\n\tint n, q, a, b, c, d;\r\n\tcin>>n>>q;\r\n\tst = new node(1, n);\r\n\twhile (q--){\r\n\t\tcin>>a;\r\n\t\tif (a==1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\tst->up(b, c, d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<st->query(b, c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "hariaakash646",
        "id": 309410,
        "date": "2023-09-17 22:30:32",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define scd(t) scanf(\"%d\", &t)\r\n#define scld(t) scanf(\"%ld\", &t)\r\n#define sclld(t) scanf(\"%lld\", &t)\r\n#define scc(t) scanf(\"%c\", &t)\r\n#define scs(t) scanf(\"%s\", t)\r\n#define scf(t) scanf(\"%f\", &t)\r\n#define sclf(t) scanf(\"%lf\", &t)\r\n#define forr(i, j, k) for (int i = j; i < k; i++)\r\n#define frange(i, j) forr(i, 0, j)\r\n#define all(cont) cont.begin(), cont.end()\r\n#define mp make_pair\r\n#define pb push_back\r\n#define f first\r\n#define s second\r\ntypedef long int li;\r\ntypedef unsigned long int uli;\r\ntypedef long long int lli;\r\ntypedef unsigned long long int ulli;\r\ntypedef pair<int, int> pii;\r\ntypedef vector<int> vi;\r\ntypedef vector<bool> vb;\r\ntypedef vector<lli> vll;\r\ntypedef vector<string> vs;\r\ntypedef vector<pii> vii;\r\ntypedef vector<vi> vvi;\r\ntypedef map<int, int> mpii;\r\ntypedef set<int> seti;\r\ntypedef multiset<int> mseti;\r\ntypedef long double ld;\r\n\r\nvoid usaco()\r\n{\r\n    freopen(\"input.in\", \"r\", stdin);\r\n//    freopen(\"problem.out\", \"w\", stdout);\r\n}\r\n\r\ntemplate <class T>\r\nstruct LazySegTree\r\n{\r\n    struct Node {\r\n        T val=0;\r\n        T lazy = 0;\r\n        int lc=-1, rc=-1;\r\n        int lr, rr;\r\n    };\r\n    int size = 1, n;\r\n    vector<Node> segtree;\r\n\r\n    T def1; // Assign a value\r\n    int id;\r\n    void init(int l, T d1)\r\n    {\r\n        n = l;\r\n        def1 = d1;\r\n\r\n        while (size < n)\r\n            size *= 2;\r\n\r\n        Node tmp;\r\n        tmp.lr = 0;\r\n        tmp.rr = size-1;\r\n        segtree.assign(64*2e5+1, tmp);\r\n        id = 1;\r\n    }\r\n\r\n    T operation(T x, T y)\r\n    {\r\n        return x + y;\r\n    }\r\n\r\n    void recalculate(int x)\r\n    {\r\n        segtree[x].val = 0;\r\n        if(segtree[x].lc != -1) segtree[x].val += segtree[segtree[x].lc].val;\r\n        if(segtree[x].rc != -1) segtree[x].val += segtree[segtree[x].rc].val;\r\n    }\r\n\r\n    void propagate(int x, int l, int r)\r\n    {\r\n        segtree[x].val += (r-l+1) * segtree[x].lazy;\r\n        if (l < r)\r\n        {\r\n            int mid = (l + r)/2;\r\n            if(segtree[x].lc == -1) {\r\n                segtree[x].lc = id++;\r\n                segtree[segtree[x].lc].lr = l;\r\n                segtree[segtree[x].lc].rr = mid;\r\n            }\r\n            if(segtree[x].rc == -1) {\r\n                segtree[x].rc = id++;\r\n                segtree[segtree[x].rc].lr = mid+1;\r\n                segtree[segtree[x].rc].rr = r;\r\n            }\r\n            segtree[segtree[x].lc].lazy += segtree[x].lazy;\r\n            segtree[segtree[x].rc].lazy += segtree[x].lazy;\r\n        }\r\n        segtree[x].lazy = 0;\r\n    }\r\n\r\n    void update(int x, int l, int r, int lx, int rx, T val)\r\n    {\r\n        propagate(x, l, r);\r\n        if (lx <= l && r <= rx)\r\n        {\r\n            segtree[x].lazy += val;\r\n            return;\r\n        }\r\n        int mid = (l + r) / 2;\r\n        if (lx <= mid)\r\n        {\r\n            if(segtree[x].lc == -1) {\r\n                segtree[x].lc = id++;\r\n                segtree[segtree[x].lc].lr = l;\r\n                segtree[segtree[x].lc].rr = mid;\r\n            }\r\n            update(segtree[x].lc, l, mid, lx, rx, val);\r\n            \r\n        }\r\n        if (rx >= mid + 1)\r\n        {\r\n            if(segtree[x].rc == -1) {\r\n                segtree[x].rc = id++;\r\n                segtree[segtree[x].rc].lr = mid+1;\r\n                segtree[segtree[x].rc].rr = r;\r\n            }\r\n            update(segtree[x].rc, mid + 1, r, lx, rx, val);\r\n        }\r\n        if(segtree[x].lc != -1)\r\n            propagate(segtree[x].lc, l, mid);\r\n        if(segtree[x].rc != -1) {\r\n            propagate(segtree[x].rc, mid + 1, r);\r\n        }\r\n        recalculate(x);\r\n    }\r\n\r\n    void update(int lx, int rx, T val)\r\n    {\r\n        update(0, 0, size - 1, lx, rx, val);\r\n    }\r\n\r\n    T query(int x, int l, int r, int lx, int rx)\r\n    {\r\n        if (lx > r || rx < l)\r\n        {\r\n            return def1;\r\n        }\r\n        propagate(x, l, r);\r\n        if (lx <= l && r <= rx)\r\n        {\r\n            return segtree[x].val;\r\n        }\r\n        int mid = (l + r) / 2;\r\n        if(segtree[x].lc == -1) {\r\n            segtree[x].lc = id++;\r\n            segtree[segtree[x].lc].lr = l;\r\n            segtree[segtree[x].lc].rr = mid;\r\n        }\r\n        if(segtree[x].rc == -1) {\r\n            segtree[x].rc = id++;\r\n            segtree[segtree[x].rc].lr = mid+1;\r\n            segtree[segtree[x].rc].rr = r;\r\n        }\r\n        T v1 = query(segtree[x].lc, l, mid, lx, rx);\r\n        T v2 = query(segtree[x].rc, mid + 1, r, lx, rx);\r\n        return operation(v1, v2);\r\n    }\r\n\r\n    T query(int lx, int rx)\r\n    {\r\n        return query(0, 0, size - 1, lx, rx);\r\n    }\r\n};\r\n\r\nint main() {\r\n    // usaco();\r\n    int n, q;\r\n    scd(n);\r\n    scd(q);\r\n    LazySegTree<lli> segtree;\r\n    segtree.init(n, 0);\r\n\r\n    frange(_, q) {\r\n        int t;\r\n        scd(t);\r\n        int l, r;\r\n        scd(l);\r\n        scd(r);\r\n        l--;\r\n        r--;\r\n        if(t == 1) {\r\n            lli v;\r\n            sclld(v);\r\n            segtree.update(l, r, v);\r\n        }\r\n        else {\r\n            printf(\"%lld\\n\", segtree.query(l, r));\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "user123",
        "id": 309181,
        "date": "2023-09-16 23:52:44",
        "code": "#include <iostream>\r\n#include <unordered_map>\r\n#pragma GCC target (\"avx2\")\r\n#pragma GCC optimization (\"O3\")\r\n#pragma GCC optimization (\"unroll-loops\")\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nconst int N=100013;\r\nint n, m;\r\n\r\nstruct fwtree\r\n{\r\n    unordered_map<int, ll> fwtree1, fwtree2;\r\n\r\n    ll lowbit(ll x) { return x&-x; }\r\n    void update(unordered_map<int, ll> &fwtree, int pos, ll x)\r\n    {\r\n        while (pos<=n)\r\n        {\r\n            fwtree[pos]+=x;\r\n            pos+=lowbit(pos);\r\n        }\r\n    }\r\n    ll sum(unordered_map<int, ll> &fwtree, int pos)\r\n    {\r\n        ll ans=0;\r\n        while (pos)\r\n        {\r\n            ans+=fwtree[pos];\r\n            pos-=lowbit(pos);\r\n        }\r\n        return ans;\r\n    }\r\n    ll query(int x)\r\n    {\r\n        return (x+1)*sum(fwtree1, x)-sum(fwtree2, x);\r\n    }\r\n    void update_r(int l, int r, ll x)\r\n    {\r\n        update(fwtree1, l, x);\r\n        update(fwtree1, r+1, -x);\r\n        update(fwtree2, l, l*x);\r\n        update(fwtree2, r+1, -(r+1)*x);\r\n    }\r\n} *root;\r\n\r\nint main()\r\n{\r\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n    cin>>n>>m;\r\n    root=new fwtree;\r\n    while (m--)\r\n    {\r\n        int t; cin>>t;\r\n        if (t==1)\r\n        {\r\n            int l, r; ll x; cin>>l>>r>>x;\r\n            root->update_r(l, r, x);\r\n        }\r\n        else\r\n        {\r\n            int l, r; cin>>l>>r;\r\n            cout<<root->query(r)-root->query(l-1)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "thisusernameistaken",
        "id": 308884,
        "date": "2023-09-15 15:23:55",
        "code": "#include <iostream>\r\n#include <unordered_map>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nconst int N=100013;\r\nint n, m;\r\n\r\nstruct fwtree\r\n{\r\n    unordered_map<int, ll> fwtree1, fwtree2;\r\n\r\n    ll lowbit(ll x) { return x&-x; }\r\n    void update(unordered_map<int, ll> &fwtree, int pos, ll x)\r\n    {\r\n        while (pos<=n)\r\n        {\r\n            fwtree[pos]+=x;\r\n            pos+=lowbit(pos);\r\n        }\r\n    }\r\n    ll sum(unordered_map<int, ll> &fwtree, int pos)\r\n    {\r\n        ll ans=0;\r\n        while (pos)\r\n        {\r\n            ans+=fwtree[pos];\r\n            pos-=lowbit(pos);\r\n        }\r\n        return ans;\r\n    }\r\n    ll query(int x)\r\n    {\r\n        return (x+1)*sum(fwtree1, x)-sum(fwtree2, x);\r\n    }\r\n    void update_r(int l, int r, ll x)\r\n    {\r\n        update(fwtree1, l, x);\r\n        update(fwtree1, r+1, -x);\r\n        update(fwtree2, l, l*x);\r\n        update(fwtree2, r+1, -(r+1)*x);\r\n    }\r\n} *root;\r\n\r\nint main()\r\n{\r\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n    cin>>n>>m;\r\n    root=new fwtree;\r\n    while (m--)\r\n    {\r\n        int t; cin>>t;\r\n        if (t==1)\r\n        {\r\n            int l, r; ll x; cin>>l>>r>>x;\r\n            root->update_r(l, r, x);\r\n        }\r\n        else\r\n        {\r\n            int l, r; cin>>l>>r;\r\n            cout<<root->query(r)-root->query(l-1)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "user123",
        "id": 307421,
        "date": "2023-09-09 21:07:39",
        "code": "#include <iostream>\r\n#include <unordered_map>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nconst int N=100013;\r\nint n, m;\r\n\r\nstruct fwtree\r\n{\r\n    unordered_map<int, ll> fwtree1, fwtree2;\r\n\r\n    ll lowbit(ll x) { return x&-x; }\r\n    void update(unordered_map<int, ll> &fwtree, int pos, ll x)\r\n    {\r\n        while (pos<=n)\r\n        {\r\n            fwtree[pos]+=x;\r\n            pos+=lowbit(pos);\r\n        }\r\n    }\r\n    ll sum(unordered_map<int, ll> &fwtree, int pos)\r\n    {\r\n        ll ans=0;\r\n        while (pos)\r\n        {\r\n            ans+=fwtree[pos];\r\n            pos-=lowbit(pos);\r\n        }\r\n        return ans;\r\n    }\r\n    ll query(int x)\r\n    {\r\n        return (x+1)*sum(fwtree1, x)-sum(fwtree2, x);\r\n    }\r\n    void update_r(int l, int r, ll x)\r\n    {\r\n        update(fwtree1, l, x);\r\n        update(fwtree1, r+1, -x);\r\n        update(fwtree2, l, l*x);\r\n        update(fwtree2, r+1, -(r+1)*x);\r\n    }\r\n} *root;\r\n\r\nint main()\r\n{\r\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n    cin>>n>>m;\r\n    root=new fwtree;\r\n    while (m--)\r\n    {\r\n        int t; cin>>t;\r\n        if (t==1)\r\n        {\r\n            int l, r; ll x; cin>>l>>r>>x;\r\n            root->update_r(l, r, x);\r\n        }\r\n        else\r\n        {\r\n            int l, r; cin>>l>>r;\r\n            cout<<root->query(r)-root->query(l-1)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "PlayVoltz",
        "id": 306071,
        "date": "2023-09-04 23:25:28",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<ll, ll> pll;\r\ntypedef vector<ll> vll;\r\ntypedef vector<pll> vpll;\r\ntypedef vector<string> vs;\r\ntypedef vector<bool> vb;\r\ntypedef map<ll, ll> mll;\r\ntypedef set<ll> sll;\r\ntypedef queue<ll> qll;\r\ntypedef queue<pll> qpll;\r\n\r\n#define all(x) x.begin(), x.end()\r\n#define sz(x) (ll) x.size()\r\n#define fr front()\r\n#define bk back()\r\n#define pb push_back\r\n#define pf push_front\r\n#define fi first\r\n#define se second\r\n#define FOR(i, a, b, inc) for (ll i = a; i < b; i += inc)\r\n#define RFOR(i, a, b, inc) for (ll i = b - 1; i >= a; i -= inc)\r\n#define REP(i, a) FOR(i, 0, a, 1)\r\n#define RREP(i, a) RFOR(i, 0, a, 1)\r\n#define each(a, x) for (auto& a: x)\r\n\r\nstruct Node {\r\n    ll val, lazy, l, r, lf, rg;\r\n    Node(): val(0), lazy(0), lf(-1), rg(-1) {}\r\n};\r\n\r\nconst ll INF = 1e9;\r\nconst ll M = 1e9 + 7;\r\nNode segTree[(ll) 2e7];\r\nll cnt = 2;\r\n\r\nvoid propagate(ll idx) {\r\n    if (segTree[idx].lazy) {\r\n        segTree[idx].val += (segTree[idx].r - segTree[idx].l + 1) * segTree[idx].lazy;\r\n        ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n        \r\n        if (segTree[idx].lf == -1) {\r\n            segTree[idx].lf = cnt++;\r\n            segTree[segTree[idx].lf].l = segTree[idx].l;\r\n            segTree[segTree[idx].lf].r = mid;\r\n        }\r\n        \r\n        if (segTree[idx].rg == -1) {\r\n            segTree[idx].rg = cnt++;\r\n\r\n            segTree[segTree[idx].rg].l = mid + 1;\r\n            segTree[segTree[idx].rg].r = segTree[idx].r;\r\n        }\r\n\r\n        segTree[segTree[idx].lf].lazy += segTree[idx].lazy;\r\n        segTree[segTree[idx].rg].lazy += segTree[idx].lazy;\r\n        segTree[idx].lazy = 0;\r\n    }\r\n}\r\n\r\nvoid update(ll idx, ll x, ll y, ll v) {\r\n    if (segTree[idx].l == x && segTree[idx].r == y) {\r\n        segTree[idx].lazy += v;\r\n        propagate(idx);\r\n        return;\r\n    }\r\n\r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    if (x > mid) update(segTree[idx].rg, x, y, v);\r\n    else if (y <= mid) update(segTree[idx].lf, x, y, v);\r\n    else {\r\n        update(segTree[idx].lf, x, mid, v);\r\n        update(segTree[idx].rg, mid + 1, y, v);\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n    segTree[idx].val = segTree[segTree[idx].lf].val + segTree[segTree[idx].rg].val;\r\n}\r\n\r\nll query(ll idx, ll x, ll y) {\r\n    propagate(idx);\r\n\r\n    if (segTree[idx].l == x && segTree[idx].r == y) return segTree[idx].val;\r\n    \r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n\r\n    if (x > mid) return query(segTree[idx].rg, x, y);\r\n    else if (y <= mid) return query(segTree[idx].lf, x, y);\r\n    else return query(segTree[idx].lf, x, mid) + query(segTree[idx].rg, mid + 1, y);\r\n}\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\n    ll n, q; cin >> n >> q;\r\n\r\n    segTree[1].l = 1; segTree[1].r = n;//(ll) 1e9;\r\n\r\n    while (q--) {\r\n        ll t; cin >> t;\r\n        \r\n        if (t == 1) {\r\n            ll l, r, x; cin >> l >> r >> x;\r\n            update(1, l, r, x);\r\n        } else {\r\n            ll l, r; cin >> l >> r;\r\n            cout << query(1, l, r) << endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "wakandaaa",
        "id": 305047,
        "date": "2023-09-02 18:14:15",
        "code": "#include<bits/stdc++.h>\r\n// #define int long long\r\nusing namespace std;\r\n\r\nconst int N = 1e6 + 5;\r\nconst int MOD = 1e9 + 7; // 998244353\r\nconst int inf = INT_MAX; // LLONG_MAX\r\nconst int LOG = 25; // LOG + 1\r\n\r\ntemplate<class T> bool minimize(T &a, T b) { return a > b ? (a = b, true) : false; }\r\ntemplate<class T> bool maximize(T &a, T b) { return a < b ? (a = b, true) : false; }\r\ntemplate<class T> bool add(T &a, T b) { a += b; while (a > MOD) a -= MOD; return true; }\r\n\r\nstruct DynamicSegmentTree {\r\n    struct Node {\r\n        long long value, lazy;\r\n        Node *Left, *Right;\r\n        Node() {\r\n            value = lazy = 0;\r\n            Left = Right = NULL;\r\n        }\r\n        void NewChild() {\r\n            if (Left == NULL) Left = new Node();\r\n            if (Right == NULL) Right = new Node();\r\n        }\r\n    };\r\n    int n;\r\n    Node *root;\r\n    void init(int _n) {\r\n        n = _n;\r\n        root = new Node();\r\n    }\r\n    void down(Node *i, int L, int R) {\r\n        int M = (L + R) >> 1;\r\n        i->Left->value += 1LL * i->lazy * (M - L + 1);\r\n        i->Right->value += 1LL * i->lazy * (R - M);\r\n        i->Left->lazy += i->lazy;\r\n        i->Right->lazy += i->lazy;\r\n        i->lazy = 0;\r\n    }\r\n    void update(Node *i, int L, int R, int l, int r, int c) {\r\n        if (r < L || l > R) return;\r\n        if (l <= L && R <= r) {\r\n            i->lazy += c;\r\n            i->value += 1LL * c * (R - L + 1);\r\n            return;\r\n        }\r\n        i->NewChild();\r\n        down(i, L, R);\r\n        int M = (L + R) >> 1;\r\n        update(i->Left, L, M, l, r, c);\r\n        update(i->Right, M + 1, R, l, r, c);\r\n        i->value = i->Left->value + i->Right->value;\r\n    }\r\n    long long get(Node *i, int L, int R, int l, int r) {\r\n        if (r < L || l > R) return 0;\r\n        if (l <= L && R <= r) return i->value;\r\n        i->NewChild();\r\n        down(i, L, R);\r\n        int M = (L + R) >> 1;\r\n        return get(i->Left, L, M, l, r) + get(i->Right, M + 1, R, l, r);\r\n    }\r\n    void update(int l, int r, int c) {\r\n        update(root, 1, n, l, r, c);\r\n    }\r\n    long long get(int l, int r) {\r\n        return get(root, 1, n, l, r);\r\n    }\r\n};\r\n\r\nsigned main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(0);\r\n\r\n    int n; cin >> n;\r\n    DynamicSegmentTree T;\r\n    T.init(n);\r\n\r\n    int q; cin >> q;\r\n    while (q--) {\r\n        int type, u, v; cin >> type >> u >> v;\r\n        if (type == 1) {\r\n            int c; cin >> c;\r\n            T.update(u, v, c);\r\n        }\r\n        else cout << T.get(u, v) << '\\n';\r\n    }\r\n\r\n    return 0;\r\n}\r\n// I'm thinking out loud!\r\n"
    },
    {
        "username": "user123",
        "id": 298965,
        "date": "2023-08-12 20:25:50",
        "code": "#include <iostream>\r\n#include <unordered_map>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nint n, m;\r\nunordered_map<int, ll> fwtree1, fwtree2;\r\n\r\nll lowbit(ll x)\r\n{\r\n    return x&-x;\r\n}\r\nvoid update(unordered_map<int, ll> &fwtree, int pos, ll x)\r\n{\r\n    while (pos<=n)\r\n    {\r\n        fwtree[pos]+=x;\r\n        pos+=lowbit(pos);\r\n    }\r\n}\r\nll sum(unordered_map<int, ll> &fwtree, int x)\r\n{\r\n    ll ans=0;\r\n    while (x>0)\r\n    {\r\n        ans+=fwtree[x];\r\n        x-=lowbit(x);\r\n    }\r\n    return ans;\r\n}\r\nll query(int x)\r\n{\r\n    return (x+1)*sum(fwtree1, x)-sum(fwtree2, x);\r\n}\r\nvoid modify(int l, int r, ll x)\r\n{\r\n    update(fwtree1, l, x);\r\n    update(fwtree1, r+1, -x);\r\n    update(fwtree2, l, l*x);\r\n    update(fwtree2, r+1, -(r+1)*x);\r\n}\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\r\n    cin>>n>>m;\r\n    while (m--)\r\n    {\r\n        int t;\r\n        cin>>t;\r\n        if (t==1)\r\n        {\r\n            int l, r; ll x;\r\n            cin>>l>>r>>x;\r\n            modify(l, r, x);\r\n        }\r\n        else\r\n        {\r\n            int l, r;\r\n            cin>>l>>r;\r\n            cout<<query(r)-query(l-1)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "nothing",
        "id": 298623,
        "date": "2023-08-11 22:36:24",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nstruct Node {\r\n\tNode() : left_(nullptr), right_(nullptr), val_(0), lazy_(0) {}\r\n\tll val_;\r\n\tll lazy_;\r\n\tNode* left_;\r\n\tNode* right_;\r\n};\r\n\r\n// curNode \r\nvoid pushDown(Node* curNode, ll leftChildNum, ll rightChildNum) {\r\n\tif (curNode->left_ == nullptr) curNode->left_ = new Node;\r\n\tif (curNode->right_ == nullptr) curNode->right_ = new Node;\r\n\r\n\tif (curNode->lazy_ == 0) return;\r\n\r\n\tcurNode->left_->val_ += (ll)curNode->lazy_ * leftChildNum;\r\n\tcurNode->left_->lazy_ += curNode->lazy_;  // 09-17 = ----> += \r\n\r\n\tcurNode->right_->val_ += (ll)curNode->lazy_ * rightChildNum;\r\n\tcurNode->right_->lazy_ += curNode->lazy_;  // 09-17 = ----> += \r\n\r\n\tcurNode->lazy_ = 0;\r\n\r\n\t//  \r\n\t// \r\n}\r\n\r\n//  \r\nvoid pushUp(Node* curNode) {\r\n\tcurNode->val_ = curNode->left_->val_ + curNode->right_->val_;\r\n}\r\n\r\n// \r\nvoid upDate(Node* curNode, ll curLeft, ll curRight, ll upDateLeft, ll upDateRight, int addVal) {\r\n\tif (upDateLeft <= curLeft && upDateRight >= curRight) {\r\n\t\t// [upDateLeft, upDateRight]  [curLeft, curRight] \r\n\t\t// \r\n\t\t// \r\n\t\tcurNode->val_ += (ll)addVal * (curRight - curLeft + 1);\r\n\t\tcurNode->lazy_ += addVal;\r\n\t\treturn;\r\n\t}\r\n\r\n\t// \r\n\t// pushDown\r\n\tint mid = (curLeft + curRight) / 2;\r\n\tpushDown(curNode, mid - curLeft + 1, curRight - mid);\r\n\r\n\t// [curLeft, curRight]\r\n\tif (upDateLeft <= mid) {\r\n\t\tupDate(curNode->left_, curLeft, mid, upDateLeft, upDateRight, addVal);\r\n\t}\r\n\tif (upDateRight > mid) {\r\n\t\tupDate(curNode->right_, mid + 1, curRight, upDateLeft, upDateRight, addVal);\r\n\t}\r\n\r\n\t// \r\n\tpushUp(curNode);\r\n}\r\n\r\n\r\n// \r\nll query(Node* curNode, ll curLeft, ll curRight, ll queryLeft, ll queryRight) {\r\n\tif (queryLeft <= curLeft && queryRight >= curRight) {\r\n\t\treturn curNode->val_;\r\n\t}\r\n\t//  \r\n\tll mid = (curLeft + curRight) / 2;\r\n\tpushDown(curNode, mid - curLeft + 1, curRight - mid);\r\n\r\n\tll curSum = 0;\r\n\tif (queryLeft <= mid) curSum += query(curNode->left_, curLeft, mid, queryLeft, queryRight);\r\n\tif (queryRight > mid) curSum += query(curNode->right_, mid + 1, curRight, queryLeft, queryRight);\r\n\r\n\treturn curSum;\r\n}\r\n\r\nint main()\r\n{\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\r\n\tll N;\r\n\tint Q;\r\n\tcin >> N >> Q;\r\n\r\n\tNode* root = new Node();\r\n\r\n\tint type;\r\n\tll l, r;\r\n\tint k;\r\n\t//long long ans;\r\n\tfor (int i = 0; i < Q; i++)\r\n\t{\r\n\t\tcin >> type >> l >> r;\r\n\r\n\t\tif (type == 1)\r\n\t\t{\r\n\t\t\tcin >> k;\r\n\r\n\t\t\t//for (int j = l - 1; j <= r - 1; j++)\r\n\t\t\tupDate(root, 0, N-1, l - 1, r - 1, k);\r\n\t\t}\r\n\t\telse if (type == 2)\r\n\t\t{\r\n\r\n\t\t\tcout << query(root, 0, N-1, l - 1, r - 1) << endl;\r\n\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\treturn 0;\r\n}\r\n"
    },
    {
        "username": "TheRaptor",
        "id": 298255,
        "date": "2023-08-10 21:38:11",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nunordered_map<int,long long> B1,B2;\r\nint N;\r\n\r\nvoid update(unordered_map<int,long long> &FT, int x, long long v){\r\n\tfor(; x<=N; x+=x&-x){\r\n\t\tFT[x] += v;\r\n\t}\r\n}\r\n\r\nlong long query(unordered_map<int,long long> &FT, int x){\r\n\tlong long ret = 0;\r\n\tfor(; x; x-=x&-x){\r\n\t\tret += FT[x];\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nvoid range_update(int x, int y, long long v){\r\n\tupdate(B1, x, v);\r\n\tupdate(B1, y+1, -v);\r\n\tupdate(B2, x, (long long)v*(x-1));\r\n\tupdate(B2, y+1, (long long)-v*y);\r\n}\r\n\r\nlong long prefix_query(int x){\r\n\treturn (long long)query(B1, x)*x - query(B2, x);\r\n}\r\n\r\nlong long range_query(int x, int y){\r\n\treturn prefix_query(y) - prefix_query(x-1);\r\n}\r\n\r\nint32_t main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n    int q;\r\n    cin >> N >> q;\r\n    for(int i=0; i<q; i++){\r\n\t\tint cmd;\r\n\t\tcin >> cmd;\r\n\t\tif(cmd==1){\r\n\t\t\tint a,b;\r\n\t\t\tlong long c;\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\trange_update(a,b,c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint a,b;\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << range_query(a,b) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "Ok",
        "id": 294402,
        "date": "2023-07-26 10:27:43",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nint N,Q,h2,h3,h4;\r\nlong long int h;\r\nlong long int lst[100100];\r\n\r\nstruct node{\r\n    int s,e,m,child;\r\n    long long int v;\r\n    long long int lazy;\r\n\r\n    node *l, *r;\r\n\r\n    node(int S, int E){\r\n        lazy = 0;\r\n        s = S;\r\n        e = E;\r\n        m = (S + E)/2;\r\n        child = 0;\r\n        v = 0;\r\n    }\r\n\r\n    void update(int S ,int E, int h1){\r\n        if(S <= s && E >= e){\r\n            lazy = lazy + h1;\r\n            return;\r\n        }\r\n        v = 0;\r\n        if(S <= m){\r\n            if(child == 0){\r\n                l = new node(s,m);\r\n                r = new node(m+1,e);\r\n                child = 1;\r\n            }\r\n\r\n            l -> update(S,E,h1);\r\n        }\r\n        if(E > m){\r\n            if(child == 0){\r\n                l = new node(s,m);\r\n                r = new node(m+1,e);\r\n                child = 1;\r\n            }\r\n            r -> update(S,E,h1);\r\n        }\r\n\r\n        v = v + l -> lazy  * (l -> e - l -> s + 1);\r\n        v = v + r -> lazy  * (r -> e - r -> s + 1);\r\n        v = l -> v + r -> v + v;\r\n        return;\r\n    }\r\n\r\n    long long int query(int S, int E){\r\n        long long int V = 0;\r\n        if(S <= s && E >= e){\r\n            V = v + lazy * (e - s + 1);\r\n            return V;\r\n        }\r\n\r\n        if(child == 0){\r\n            return 0 + lazy  * (min(E,e) - max(S,s) + 1);\r\n        }\r\n\r\n        if(S <= m){\r\n            V = V + l -> query(S, E);\r\n        }\r\n        if(E > m){\r\n            V = V + r -> query(S, E);\r\n        }\r\n\r\n        if(min(E,e) - max(S,s) + 1 < 0){\r\n            return V;\r\n        }\r\n        else{\r\n            return V + lazy  * (min(E,e) - max(S,s) + 1);\r\n        }\r\n    }\r\n\r\n}*root;\r\n\r\nint main(){\r\n    scanf(\" %d\",&N);\r\n    root = new node(1,N);\r\n\r\n    scanf(\" %d\",&Q);\r\n\t\r\n\tmap<int,int> mep;\r\n\r\n    for(int i = 0; i < Q; i++){\r\n        scanf(\" %d\",&h2);\r\n        if(h2 == 2){\r\n            scanf(\" %d\",&h2);\r\n            scanf(\" %d\",&h3);\r\n\t\t\tmep[h2] = h3;\r\n            printf(\"%lld\\n\",root -> query(h2,h3));\r\n        }\r\n        else{\r\n            scanf(\" %d\",&h2);\r\n            scanf(\" %d\",&h3);\r\n            scanf(\" %d\",&h4);\r\n            root -> update(h2,h3,h4);\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n"
    },
    {
        "username": "ChickenCoder",
        "id": 291506,
        "date": "2023-07-16 14:29:21",
        "code": "#include <iostream>\r\nusing namespace std;\r\n\r\nstruct node{\r\n\tlong long val, add;\r\n\tnode* l = nullptr;\r\n\tnode* r = nullptr;\r\n};\r\n\r\nnode start;\r\n\r\nvoid assign(long long val, long long add, node* &ptr){\r\n\tptr = new node;\r\n\tptr -> val = val;\r\n\tptr -> add = add;\r\n}\r\n\r\nvoid create(node& idx, int nl, int nr){\r\n\tint mid = (nl + nr)/2;\r\n\r\n\tif (idx.l == nullptr) assign(0, 0, idx.l);\r\n\tidx.l->val += (mid+1-nl)*idx.add;\r\n\tidx.l->add += idx.add;\r\n\r\n\tif (idx.r == nullptr) assign(0, 0, idx.r);\r\n\tidx.r->val += (nr-mid)*idx.add;\r\n\tidx.r->add += idx.add;\r\n\r\n\tidx.add = 0;\r\n}\r\n\r\nvoid update(node& idx, int nl, int nr, int ql, int qr, long long val){\r\n\tif (nl > qr || nr < ql) return;\r\n\r\n\tif (ql <= nl && qr >= nr){\r\n\t\tidx.val += (nr-nl+1)*val;\r\n\t\tidx.add += val;\r\n\t\treturn;\r\n\t}\r\n\r\n\tint mid = (nl + nr)/2;\r\n\tcreate(idx, nl, nr);\r\n\r\n\t\r\n\tupdate(*idx.l, nl, mid, ql, qr, val);\r\n\tupdate(*idx.r, mid+1, nr, ql, qr, val);\r\n\r\n\tidx.val = idx.l->val + idx.r->val;\r\n}\r\n\r\nlong long find_sum(node &idx, int nl, int nr, int ql, int qr){\r\n\tif (nl > qr || nr < ql) return 0;\r\n\tif (ql <= nl && qr >= nr) return idx.val;\r\n\r\n\tint mid = (nl + nr)/2;\r\n\r\n\tcreate(idx, nl, nr);\r\n\r\n\r\n\treturn find_sum(*idx.l, nl, mid, ql, qr) + find_sum(*idx.r, mid+1, nr, ql, qr);\r\n}\r\n\r\n\r\n\r\nint main(){\t\r\n\tstart.val = start.add = 0;\r\n\r\n\tint n, q;\r\n\tcin >> n >> q;\r\n\r\n\tfor (int i = 0; i < q; i++){\r\n\t\tint t; cin >> t;\r\n\t\tif (t == 1){\r\n\t\t\tint l, r, k;\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\tupdate(start, 0, n-1, l-1, r-1, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << find_sum(start, 0, n-1, l-1, r-1) << endl;\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "cri",
        "id": 285596,
        "date": "2023-06-27 07:12:50",
        "code": "#include <iostream>\r\nusing namespace std;\r\n#define int long long\r\n\r\nint N, Q;\r\n\r\nstruct node{\r\n    int s, e, m, val, lz;\r\n    node *l, *r;\r\n\r\n    node(int s1, int e1){\r\n        s = s1, e = e1, m = (int)(s + e)/2, val = 0, lz = 0;\r\n        l = nullptr, r = nullptr;\r\n    }\r\n\r\n    void upd(int le, int ri, int incre){\r\n        if(le <= s && ri >= e) lz += incre;\r\n        else{\r\n            val += (ri - le + 1) * incre;\r\n            if(ri <= m){\r\n                if(l == nullptr) l = new node(s, m);\r\n                l->upd(le, ri, incre);\r\n            } else if(le > m){\r\n                if(r == nullptr) r = new node(m + 1, e);\r\n                r->upd(le, ri, incre);\r\n            } else {\r\n                if(l == nullptr) l = new node(s, m);\r\n                l->upd(le, m, incre);\r\n                if(r == nullptr) r = new node(m + 1, e);\r\n                r->upd(m + 1, ri, incre);\r\n            }\r\n        }\r\n    }\r\n\r\n    int q(int x, int y){\r\n        propo();\r\n        if(x <= s && y >= e) return val;\r\n        else if(y <= m){\r\n            if(l == nullptr) l = new node(s, m);\r\n            return l->q(x, y);\r\n        } else if(x > m){\r\n            if(r == nullptr) r = new node(m + 1, e);\r\n            return r->q(x, y);\r\n        } else{\r\n            if(l == nullptr) l = new node(s, m);\r\n            if(r == nullptr) r = new node(m + 1, e);\r\n            return l->q(x, m) + r->q(m + 1, y);\r\n        }\r\n    }\r\n\r\n    void propo(){\r\n        if(!lz) return;\r\n        val += (e - s + 1) * lz;\r\n        if(l == nullptr) l = new node(s, m);\r\n        if(r == nullptr) r = new node(m + 1, e);\r\n        l->lz += lz; r->lz += lz;\r\n        lz = 0;\r\n    }\r\n} *root;\r\n\r\nsigned main(){\r\n    cin >> N >> Q;\r\n\r\n    root = new node(1, N);\r\n    \r\n    while(Q--){\r\n        int t; cin >> t;\r\n        if(t == 1){\r\n            int l, r, k; cin >> l >> r >> k;\r\n            root->upd(l, r, k);\r\n        } else {\r\n            int x, y; cin >> x >> y;\r\n            cout << root->q(x, y) << \"\\n\";\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "IWKR",
        "id": 282226,
        "date": "2023-06-15 21:07:59",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n    int s,m,e,v=0,lazy=0;\r\n    node *l, *r;\r\n    node(int S, int E){\r\n        e=E,s=S,m=(s+e)>>1;\r\n        l=NULL;r=NULL;\r\n    }\r\n    void create(){\r\n        if(e==s)return;\r\n        l= new node(s,m);\r\n        r= new node(m+1,e);\r\n    }\r\n    void prop(){\r\n        if(lazy==0)return;\r\n        v+=lazy*(e-s+1);\r\n        if(s!=e){\r\n            if(l==NULL)create();\r\n            l->lazy = l->lazy + lazy;\r\n            r->lazy = r->lazy + lazy;\r\n        }\r\n        lazy=0;\r\n    }\r\n    void add(int S, int E, int V){\r\n        //cout<<S<<' '<<E<<endl;\r\n        if(s==S&&e==E){lazy+=V; return;}\r\n        if(l==NULL)create();\r\n        if(E<=m)l->add(S,E,V);\r\n        else if(S>m)r->add(S,E,V);\r\n        else{\r\n            l->add(S,m,V);\r\n            r-> add(m+1,E,V);\r\n        } \r\n        l->prop();r->prop();\r\n        v=l->v+r->v;\r\n    }\r\n    int sum(int S, int E){\r\n        //cout<<s<<' '<<e<<endl;cout.flush();\r\n        prop();\r\n        if(s==S&&e==E)return v;\r\n        if(E<=m)return (l==NULL) ? 0 : l->sum(S,E);\r\n        else if(S>m)return (r==NULL) ? 0 : r->sum(S,E);\r\n        else return ((l==NULL) ? 0 : l->sum(S,m)) + ((r==NULL) ? 0 : r->sum(m+1,E));\r\n    }\r\n} *root;\r\nint t,a,b,c,n,q;\r\nsigned main(){\r\n    cin>>n>>q;\r\n    root=new node(0,n+2);\r\n    while(q--){\r\n        cin>>t>>a>>b;\r\n        //cout<<t<<endl;cout.flush();\r\n        if(t==1){\r\n            cin>>c;\r\n            root->add(a,b,c);\r\n        }else{\r\n            cout<<root->sum(a,b)<<endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "IWKR",
        "id": 282223,
        "date": "2023-06-15 20:59:44",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n    int s,m,e,v=0,lazy=0;\r\n    node *l, *r;\r\n    node(int S, int E){\r\n        e=E,s=S,m=(s+e)>>1;\r\n        l=NULL;r=NULL;\r\n    }\r\n    void create(){\r\n        if(e==s)return;\r\n        l= new node(s,m);\r\n        r= new node(m+1,e);\r\n    }\r\n    void prop(){\r\n        if(lazy==0)return;\r\n        v+=lazy*(e-s+1);\r\n        if(s!=e){\r\n            if(l==NULL)create();\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0;\r\n    }\r\n    void add(int S, int E, int V){\r\n        //cout<<S<<' '<<E<<endl;\r\n        if(s==S&&e==E){lazy+=V; return;}\r\n        if(l==NULL)create();\r\n        if(E<=m)l->add(S,E,V);\r\n        else if(S>m)r->add(S,E,V);\r\n        else{\r\n            l->add(S,m,V);\r\n            r-> add(m+1,E,V);\r\n        } \r\n        l->prop();r->prop();\r\n        v=l->v+r->v;\r\n    }\r\n    int sum(int S, int E){\r\n        //cout<<s<<' '<<e<<endl;cout.flush();\r\n        prop();\r\n        if(s==S&&e==E)return v;\r\n        if(E<=m)return (l==NULL) ? 0 : l->sum(S,E);\r\n        else if(S>m)return (r==NULL) ? 0 : r->sum(S,E);\r\n        else return ((l==NULL) ? 0 : l->sum(S,m)) + ((r==NULL) ? 0 : r->sum(m+1,E));\r\n    }\r\n} *root;\r\nint t,a,b,c,n,q;\r\nsigned main(){\r\n    cin>>n>>q;\r\n    root=new node(0,n+2);\r\n    while(q--){\r\n        cin>>t>>a>>b;\r\n        //cout<<t<<endl;cout.flush();\r\n        if(t==1){\r\n            cin>>c;\r\n            root->add(a,b,c);\r\n        }else{\r\n            cout<<root->sum(a,b)<<endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "IWKR",
        "id": 282222,
        "date": "2023-06-15 20:58:43",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n    int s,m,e,v=0,lazy=0;\r\n    node *l, *r;\r\n    node(int S, int E){\r\n        e=E,s=S,m=(s+e)>>1;\r\n        l=nullptr;r=nullptr;\r\n    }\r\n    void create(){\r\n        if(e==s)return;\r\n        l= new node(s,m);\r\n        r= new node(m+1,e);\r\n    }\r\n    void prop(){\r\n        if(lazy==0)return;\r\n        v+=lazy*(e-s+1);\r\n        if(s!=e){\r\n            if(l==nullptr)create();\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0;\r\n    }\r\n    void add(int S, int E, int V){\r\n        //cout<<S<<' '<<E<<endl;\r\n        if(s==S&&e==E){lazy+=V; return;}\r\n        if(l==nullptr)create();\r\n        if(E<=m)l->add(S,E,V);\r\n        else if(S>m)r->add(S,E,V);\r\n        else{\r\n            l->add(S,m,V);\r\n            r-> add(m+1,E,V);\r\n        } \r\n        l->prop();r->prop();\r\n        v=l->v+r->v;\r\n    }\r\n    int sum(int S, int E){\r\n        //cout<<s<<' '<<e<<endl;cout.flush();\r\n        prop();\r\n        if(s==S&&e==E)return v;\r\n        if(E<=m)return (l==nullptr) ? 0 : l->sum(S,E);\r\n        else if(S>m)return (r==nullptr) ? 0 : r->sum(S,E);\r\n        else return ((l==nullptr) ? 0 : l->sum(S,m)) + ((r==nullptr) ? 0 : r->sum(m+1,E));\r\n    }\r\n} *root;\r\nint t,a,b,c,n,q;\r\nsigned main(){\r\n    cin>>n>>q;\r\n    root=new node(0,n+2);\r\n    while(q--){\r\n        cin>>t>>a>>b;\r\n        //cout<<t<<endl;cout.flush();\r\n        if(t==1){\r\n            cin>>c;\r\n            root->add(a,b,c);\r\n        }else{\r\n            cout<<root->sum(a,b)<<endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "IWKR",
        "id": 282218,
        "date": "2023-06-15 20:50:06",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n    int s,m,e,v=0,lazy=0;\r\n    node *l, *r;\r\n    node(int S, int E){\r\n        e=E,s=S,m=(s+e)>>1;\r\n        l=nullptr;r=nullptr;\r\n    }\r\n    void create(){\r\n        if(e==s)return;\r\n        l= new node(s,m);\r\n        r= new node(m+1,e);\r\n    }\r\n    void prop(){\r\n        if(lazy==0)return;\r\n        v+=lazy*(e-s+1);\r\n        if(s!=e){\r\n            if(l==nullptr)create();\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0;\r\n    }\r\n    void add(int S, int E, int V){\r\n        //cout<<S<<' '<<E<<endl;\r\n        if(s==S&&e==E){lazy+=V; return;}\r\n        if(l==nullptr)create();\r\n        if(E<=m)l->add(S,E,V);\r\n        else if(S>m)r->add(S,E,V);\r\n        else{\r\n            l->add(S,m,V);\r\n            r-> add(m+1,E,V);\r\n        } \r\n        l->prop();r->prop();\r\n        v=l->v+r->v;\r\n    }\r\n    int sum(int S, int E){\r\n        //cout<<s<<' '<<e<<endl;cout.flush();\r\n        prop();\r\n        if(s==S&&e==E)return v;\r\n        if(E<=m)return (l==nullptr) ? 0 : l->sum(S,E);\r\n        else if(S>m)return (r==nullptr) ? 0 : r->sum(S,E);\r\n        else return ((l==nullptr) ? 0 : l->sum(S,m)) + ((r==nullptr) ? 0 : r->sum(m+1,E));\r\n    }\r\n} *root;\r\nint t,a,b,c,n,q;\r\nsigned main(){\r\n    cin>>n>>q;\r\n    root=new node(0,n+2);\r\n    while(q--){\r\n        cin>>t>>a>>b;\r\n        //cout<<t<<endl;cout.flush();\r\n        if(t==1){\r\n            cin>>c;\r\n            root->add(a,b,c);\r\n        }else{\r\n            cout<<root->sum(a,b)<<endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "elainagrey",
        "id": 273574,
        "date": "2023-05-20 00:22:01",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n    int s,m,e,v=0,lazy=0;\r\n    node *l, *r;\r\n    node(int S, int E){\r\n        e=E,s=S,m=(s+e)>>1;\r\n        l=nullptr;r=nullptr;\r\n    }\r\n    void create(){\r\n        if(e==s)return;\r\n        l= new node(s,m);\r\n        r= new node(m+1,e);\r\n    }\r\n    void prop(){\r\n        if(lazy==0)return;\r\n        v+=lazy*(e-s+1);\r\n        if(s!=e){\r\n            if(l==nullptr)create();\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0;\r\n    }\r\n    void add(int S, int E, int V){\r\n        //cout<<S<<' '<<E<<endl;\r\n        if(s==S&&e==E){lazy+=V; return;}\r\n        if(l==nullptr)create();\r\n        if(E<=m)l->add(S,E,V);\r\n        else if(S>m)r->add(S,E,V);\r\n        else{\r\n            l->add(S,m,V);\r\n            r-> add(m+1,E,V);\r\n        } \r\n        l->prop();r->prop();\r\n        v=l->v+r->v;\r\n    }\r\n    int sum(int S, int E){\r\n        //cout<<s<<' '<<e<<endl;cout.flush();\r\n        prop();\r\n        if(s==S&&e==E)return v;\r\n        if(E<=m)return (l==nullptr) ? 0 : l->sum(S,E);\r\n        else if(S>m)return (r==nullptr) ? 0 : r->sum(S,E);\r\n        else return ((l==nullptr) ? 0 : l->sum(S,m)) + ((r==nullptr) ? 0 : r->sum(m+1,E));\r\n    }\r\n} *root;\r\nint t,a,b,c,n,q;\r\nsigned main(){\r\n    cin>>n>>q;\r\n    root=new node(0,n+2);\r\n    while(q--){\r\n        cin>>t>>a>>b;\r\n        //cout<<t<<endl;cout.flush();\r\n        if(t==1){\r\n            cin>>c;\r\n            root->add(a,b,c);\r\n        }else{\r\n            cout<<root->sum(a,b)<<endl;\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "yuhong",
        "id": 255958,
        "date": "2023-03-31 15:38:39",
        "code": "#include <algorithm>\r\n#include <iostream>\r\n#include <cstring>\r\n#include <climits>\r\n#include <cstdio>\r\n#include <cmath>\r\n#include <unordered_map>\r\n#include <vector>\r\n#include <stack>\r\n#include <deque>\r\n#include <queue>\r\n#include <map>\r\n#include <set>\r\n#include <iomanip>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<ll, ll> pll;\r\ntypedef vector<ll> vll;\r\ntypedef vector<pll> vpll;\r\ntypedef vector<string> vs;\r\ntypedef vector<bool> vb;\r\ntypedef map<ll, ll> mll;\r\ntypedef set<ll> sll;\r\ntypedef queue<ll> qll;\r\ntypedef queue<pll> qpll;\r\n#define int long long\r\n#define all(x) x.begin(), x.end()\r\n#define sz(x) (ll) x.size()\r\n#define fr front()\r\n#define bk back()\r\n#define pb push_back\r\n#define pf push_front\r\n#define fi first\r\n#define se second\r\n#define FOR(i, a, b, inc) for (ll i = a; i < b; i += inc)\r\n#define RFOR(i, a, b, inc) for (ll i = b - 1; i >= a; i -= inc)\r\n#define REP(i, a) FOR(i, 0, a, 1)\r\n#define RREP(i, a) RFOR(i, 0, a, 1)\r\n#define each(a, x) for (auto& a: x)\r\n//Dynamic Segment Tree\r\nstruct Node {\r\n    int val, lazy, l, r, lf, rg;\r\n    Node(): val(0), lazy(0), lf(-1), rg(-1) {}\r\n};\r\n\r\nNode segTree[(int) 2e7];\r\nint cnt = 2;\r\n\r\nvoid propagate(int idx) {\r\n    if (segTree[idx].lazy) {\r\n        segTree[idx].val += (segTree[idx].r - segTree[idx].l + 1) * segTree[idx].lazy;\r\n        int mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n        \r\n        if (segTree[idx].lf == -1) {\r\n            segTree[idx].lf = cnt++;\r\n            segTree[segTree[idx].lf].l = segTree[idx].l;\r\n            segTree[segTree[idx].lf].r = mid;\r\n        }\r\n        \r\n        if (segTree[idx].rg == -1) {\r\n            segTree[idx].rg = cnt++;\r\n\r\n            segTree[segTree[idx].rg].l = mid + 1;\r\n            segTree[segTree[idx].rg].r = segTree[idx].r;\r\n        }\r\n\r\n        segTree[segTree[idx].lf].lazy += segTree[idx].lazy;\r\n        segTree[segTree[idx].rg].lazy += segTree[idx].lazy;\r\n        segTree[idx].lazy = 0;\r\n    }\r\n}\r\n\r\nvoid update(int idx, int x, int y, int v) {\r\n    if (segTree[idx].l == x && segTree[idx].r == y) {\r\n        segTree[idx].lazy += v;\r\n        propagate(idx);\r\n        return;\r\n    }\r\n\r\n    int mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    if (x > mid) update(segTree[idx].rg, x, y, v);\r\n    else if (y <= mid) update(segTree[idx].lf, x, y, v);\r\n    else {\r\n        update(segTree[idx].lf, x, mid, v);\r\n        update(segTree[idx].rg, mid + 1, y, v);\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n    segTree[idx].val = segTree[segTree[idx].lf].val + segTree[segTree[idx].rg].val;\r\n}\r\n\r\nint query(int idx, int x, int y) {\r\n    propagate(idx);\r\n\r\n    if (segTree[idx].l == x && segTree[idx].r == y) return segTree[idx].val;\r\n    \r\n    int mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n\r\n    if (x > mid) return query(segTree[idx].rg, x, y);\r\n    else if (y <= mid) return query(segTree[idx].lf, x, y);\r\n    else return query(segTree[idx].lf, x, mid) + query(segTree[idx].rg, mid + 1, y);\r\n}\r\n/* End: Dynamic Segment Tree */\r\n\r\nint32_t main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n    int n ,q;\r\n    cin>>n>>q;\r\n    segTree[1].l =1, segTree[1].r = n;\r\n    while(q--){\r\n        int t;cin>>t;\r\n        if(t ==1){\r\n            int l,r,v;\r\n            cin>>l>>r>>v;\r\n            update(1,l,r,v);\r\n        }else{\r\n            int l,r;\r\n            cin>>l>>r;\r\n            cout<<query(1,l,r)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "yuhong",
        "id": 254908,
        "date": "2023-03-31 01:02:02",
        "code": "#include <algorithm>\r\n#include <iostream>\r\n#include <cstring>\r\n#include <climits>\r\n#include <cstdio>\r\n#include <cmath>\r\n#include <unordered_map>\r\n#include <vector>\r\n#include <stack>\r\n#include <deque>\r\n#include <queue>\r\n#include <map>\r\n#include <set>\r\n#include <iomanip>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<ll, ll> pll;\r\ntypedef vector<ll> vll;\r\ntypedef vector<pll> vpll;\r\ntypedef vector<string> vs;\r\ntypedef vector<bool> vb;\r\ntypedef map<ll, ll> mll;\r\ntypedef set<ll> sll;\r\ntypedef queue<ll> qll;\r\ntypedef queue<pll> qpll;\r\n\r\n#define all(x) x.begin(), x.end()\r\n#define sz(x) (ll) x.size()\r\n#define fr front()\r\n#define bk back()\r\n#define pb push_back\r\n#define pf push_front\r\n#define fi first\r\n#define se second\r\n#define FOR(i, a, b, inc) for (ll i = a; i < b; i += inc)\r\n#define RFOR(i, a, b, inc) for (ll i = b - 1; i >= a; i -= inc)\r\n#define REP(i, a) FOR(i, 0, a, 1)\r\n#define RREP(i, a) RFOR(i, 0, a, 1)\r\n#define each(a, x) for (auto& a: x)\r\n\r\nstruct Node {\r\n    ll val, lazy, l, r, lf, rg;\r\n    Node(): val(0), lazy(0), lf(-1), rg(-1) {}\r\n};\r\n\r\nconst ll INF = 1e9;\r\nconst ll M = 1e9 + 7;\r\nNode segTree[(ll) 2e7];\r\nll cnt = 2;\r\n\r\nvoid propagate(ll idx) {\r\n    if (segTree[idx].lazy) {\r\n        segTree[idx].val += (segTree[idx].r - segTree[idx].l + 1) * segTree[idx].lazy;\r\n        ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n        \r\n        if (segTree[idx].lf == -1) {\r\n            segTree[idx].lf = cnt++;\r\n            segTree[segTree[idx].lf].l = segTree[idx].l;\r\n            segTree[segTree[idx].lf].r = mid;\r\n        }\r\n        \r\n        if (segTree[idx].rg == -1) {\r\n            segTree[idx].rg = cnt++;\r\n\r\n            segTree[segTree[idx].rg].l = mid + 1;\r\n            segTree[segTree[idx].rg].r = segTree[idx].r;\r\n        }\r\n\r\n        segTree[segTree[idx].lf].lazy += segTree[idx].lazy;\r\n        segTree[segTree[idx].rg].lazy += segTree[idx].lazy;\r\n        segTree[idx].lazy = 0;\r\n    }\r\n}\r\n\r\nvoid update(ll idx, ll x, ll y, ll v) {\r\n    if (segTree[idx].l == x && segTree[idx].r == y) {\r\n        segTree[idx].lazy += v;\r\n        propagate(idx);\r\n        return;\r\n    }\r\n\r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    if (x > mid) update(segTree[idx].rg, x, y, v);\r\n    else if (y <= mid) update(segTree[idx].lf, x, y, v);\r\n    else {\r\n        update(segTree[idx].lf, x, mid, v);\r\n        update(segTree[idx].rg, mid + 1, y, v);\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n    segTree[idx].val = segTree[segTree[idx].lf].val + segTree[segTree[idx].rg].val;\r\n}\r\n\r\nll query(ll idx, ll x, ll y) {\r\n    propagate(idx);\r\n\r\n    if (segTree[idx].l == x && segTree[idx].r == y) return segTree[idx].val;\r\n    \r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n\r\n    if (x > mid) return query(segTree[idx].rg, x, y);\r\n    else if (y <= mid) return query(segTree[idx].lf, x, y);\r\n    else return query(segTree[idx].lf, x, mid) + query(segTree[idx].rg, mid + 1, y);\r\n}\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\n    ll n, q; cin >> n >> q;\r\n\r\n    segTree[1].l = 1; segTree[1].r = n;//(ll) 1e9;\r\n\r\n    while (q--) {\r\n        ll t; cin >> t;\r\n        \r\n        if (t == 1) {\r\n            ll l, r, x; cin >> l >> r >> x;\r\n            update(1, l, r, x);\r\n        } else {\r\n            ll l, r; cin >> l >> r;\r\n            cout << query(1, l, r) << endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "dsyz",
        "id": 253363,
        "date": "2023-03-25 23:54:58",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\n#define MAXN (10005)\r\nstruct node{\r\n  ll s,e,m,val,lazy;\r\n  node *l,*r;\r\n  node(ll S,ll E){\r\n    s = S;\r\n    e = E;\r\n    m = (s + e) >> 1;\r\n    val = 0;\r\n    lazy = 0;\r\n  }\r\n  void create(){\r\n    if(l == nullptr && s != e){\r\n      l = new node(s,m);\r\n      r = new node(m + 1,e);\r\n    }\r\n  }\r\n  void propagate(){\r\n    create();\r\n    if(lazy == 0){\r\n      return;\r\n    }\r\n    val += lazy * (e - s + 1);\r\n    if(s != e){\r\n      l->lazy += lazy;\r\n      r->lazy += lazy;\r\n    }\r\n    lazy = 0;\r\n  }\r\n  void update(ll S,ll E,ll v){\r\n    if(s == S && e == E) lazy += v;\r\n    else{\r\n      create();\r\n      if(E <= m) l->update(S,E,v);\r\n      else if(S > m) r->update(S,E,v);\r\n      else l->update(S,m,v),r->update(m + 1,E,v);\r\n      l->propagate(),r->propagate();\r\n      val = l->val + r->val;\r\n    }\r\n  }\r\n  long long query(ll S,ll E){\r\n    create();\r\n    propagate();\r\n    if(s == S && e == E) return val;\r\n    else if(S > m) return r->query(S,E);\r\n    else if(E <= m) return l->query(S,E);\r\n    else return l->query(S,m) + r-> query(m + 1,E);\r\n  }\r\n} *root;\r\nint main() {\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  ll N,Q;\r\n  cin>>N>>Q;\r\n  root = new node(0,N + 1);\r\n  for(ll i = 0;i < Q;i++){\r\n    ll a;\r\n    cin>>a;\r\n    if(a == 1){\r\n      ll L,R,k;\r\n      cin>>L>>R>>k;\r\n      root -> update(L - 1,R - 1,k);\r\n    }else if(a == 2){\r\n      ll L,R;\r\n      cin>>L>>R;\r\n      cout<<root -> query(L - 1,R - 1)<<'\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "dsyz",
        "id": 253360,
        "date": "2023-03-25 23:54:31",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\n#define MAXN (10005)\r\nstruct node{\r\n  ll s,e,m,val,lazy;\r\n  node *l = nullptr, *r = nullptr;\r\n  node(ll S,ll E){\r\n    s = S;\r\n    e = E;\r\n    m = (s + e) >> 1;\r\n    val = 0;\r\n    lazy = 0;\r\n  }\r\n  void create(){\r\n    if(l == nullptr && s != e){\r\n      l = new node(s,m);\r\n      r = new node(m + 1,e);\r\n    }\r\n  }\r\n  void propagate(){\r\n    create();\r\n    if(lazy == 0){\r\n      return;\r\n    }\r\n    val += lazy * (e - s + 1);\r\n    if(s != e){\r\n      l->lazy += lazy;\r\n      r->lazy += lazy;\r\n    }\r\n    lazy = 0;\r\n  }\r\n  void update(ll S,ll E,ll v){\r\n    if(s == S && e == E) lazy += v;\r\n    else{\r\n      create();\r\n      if(E <= m) l->update(S,E,v);\r\n      else if(S > m) r->update(S,E,v);\r\n      else l->update(S,m,v),r->update(m + 1,E,v);\r\n      l->propagate(),r->propagate();\r\n      val = l->val + r->val;\r\n    }\r\n  }\r\n  long long query(ll S,ll E){\r\n    create();\r\n    propagate();\r\n    if(s == S && e == E) return val;\r\n    else if(S > m) return r->query(S,E);\r\n    else if(E <= m) return l->query(S,E);\r\n    else return l->query(S,m) + r-> query(m + 1,E);\r\n  }\r\n} *root;\r\nint main() {\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  ll N,Q;\r\n  cin>>N>>Q;\r\n  root = new node(0,N + 1);\r\n  for(ll i = 0;i < Q;i++){\r\n    ll a;\r\n    cin>>a;\r\n    if(a == 1){\r\n      ll L,R,k;\r\n      cin>>L>>R>>k;\r\n      root -> update(L - 1,R - 1,k);\r\n    }else if(a == 2){\r\n      ll L,R;\r\n      cin>>L>>R;\r\n      cout<<root -> query(L - 1,R - 1)<<'\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "yuhong",
        "id": 250140,
        "date": "2023-03-17 03:38:37",
        "code": "#include <algorithm>\r\n#include <iostream>\r\n#include <cstring>\r\n#include <climits>\r\n#include <cstdio>\r\n#include <cmath>\r\n#include <unordered_map>\r\n#include <vector>\r\n#include <stack>\r\n#include <deque>\r\n#include <queue>\r\n#include <map>\r\n#include <set>\r\n#include <iomanip>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<ll, ll> pll;\r\ntypedef vector<ll> vll;\r\ntypedef vector<pll> vpll;\r\ntypedef vector<string> vs;\r\ntypedef vector<bool> vb;\r\ntypedef map<ll, ll> mll;\r\ntypedef set<ll> sll;\r\ntypedef queue<ll> qll;\r\ntypedef queue<pll> qpll;\r\n\r\n#define all(x) x.begin(), x.end()\r\n#define sz(x) (ll) x.size()\r\n#define fr front()\r\n#define bk back()\r\n#define pb push_back\r\n#define pf push_front\r\n#define fi first\r\n#define se second\r\n#define FOR(i, a, b, inc) for (ll i = a; i < b; i += inc)\r\n#define RFOR(i, a, b, inc) for (ll i = b - 1; i >= a; i -= inc)\r\n#define REP(i, a) FOR(i, 0, a, 1)\r\n#define RREP(i, a) RFOR(i, 0, a, 1)\r\n#define each(a, x) for (auto& a: x)\r\n\r\nstruct Node {\r\n    ll val, lazy, l, r, lf, rg;\r\n    Node(): val(0), lazy(0), lf(-1), rg(-1) {}\r\n};\r\n\r\nconst ll INF = 1e9;\r\nconst ll M = 1e9 + 7;\r\nNode segTree[(ll) 2e7];\r\nll cnt = 2;\r\n\r\nvoid propagate(ll idx) {\r\n    if (segTree[idx].lazy) {\r\n        segTree[idx].val += (segTree[idx].r - segTree[idx].l + 1) * segTree[idx].lazy;\r\n        ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n        \r\n        if (segTree[idx].lf == -1) {\r\n            segTree[idx].lf = cnt++;\r\n            segTree[segTree[idx].lf].l = segTree[idx].l;\r\n            segTree[segTree[idx].lf].r = mid;\r\n        }\r\n        \r\n        if (segTree[idx].rg == -1) {\r\n            segTree[idx].rg = cnt++;\r\n\r\n            segTree[segTree[idx].rg].l = mid + 1;\r\n            segTree[segTree[idx].rg].r = segTree[idx].r;\r\n        }\r\n\r\n        segTree[segTree[idx].lf].lazy += segTree[idx].lazy;\r\n        segTree[segTree[idx].rg].lazy += segTree[idx].lazy;\r\n        segTree[idx].lazy = 0;\r\n    }\r\n}\r\n\r\nvoid update(ll idx, ll x, ll y, ll v) {\r\n    if (segTree[idx].l == x && segTree[idx].r == y) {\r\n        segTree[idx].lazy += v;\r\n        propagate(idx);\r\n        return;\r\n    }\r\n\r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    if (x > mid) update(segTree[idx].rg, x, y, v);\r\n    else if (y <= mid) update(segTree[idx].lf, x, y, v);\r\n    else {\r\n        update(segTree[idx].lf, x, mid, v);\r\n        update(segTree[idx].rg, mid + 1, y, v);\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n    segTree[idx].val = segTree[segTree[idx].lf].val + segTree[segTree[idx].rg].val;\r\n}\r\n\r\nll query(ll idx, ll x, ll y) {\r\n    propagate(idx);\r\n\r\n    if (segTree[idx].l == x && segTree[idx].r == y) return segTree[idx].val;\r\n    \r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n\r\n    if (x > mid) return query(segTree[idx].rg, x, y);\r\n    else if (y <= mid) return query(segTree[idx].lf, x, y);\r\n    else return query(segTree[idx].lf, x, mid) + query(segTree[idx].rg, mid + 1, y);\r\n}\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\n    ll n, q; cin >> n >> q;\r\n\r\n    segTree[1].l = 1; segTree[1].r = n;//(ll) 1e9;\r\n\r\n    while (q--) {\r\n        ll t; cin >> t;\r\n        \r\n        if (t == 1) {\r\n            ll l, r, x; cin >> l >> r >> x;\r\n            update(1, l, r, x);\r\n        } else {\r\n            ll l, r; cin >> l >> r;\r\n            cout << query(1, l, r) << endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "Tracxr",
        "id": 249874,
        "date": "2023-03-16 19:58:40",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<ll, ll> pll;\r\ntypedef vector<ll> vll;\r\ntypedef vector<pll> vpll;\r\ntypedef vector<string> vs;\r\ntypedef vector<bool> vb;\r\ntypedef map<ll, ll> mll;\r\ntypedef set<ll> sll;\r\ntypedef queue<ll> qll;\r\ntypedef queue<pll> qpll;\r\n\r\n#define all(x) x.begin(), x.end()\r\n#define sz(x) (ll) x.size()\r\n#define fr front()\r\n#define bk back()\r\n#define pb push_back\r\n#define pf push_front\r\n#define fi first\r\n#define se second\r\n#define FOR(i, a, b, inc) for (ll i = a; i < b; i += inc)\r\n#define RFOR(i, a, b, inc) for (ll i = b - 1; i >= a; i -= inc)\r\n#define REP(i, a) FOR(i, 0, a, 1)\r\n#define RREP(i, a) RFOR(i, 0, a, 1)\r\n#define each(a, x) for (auto& a: x)\r\n\r\nstruct Node {\r\n    ll val, lazy, l, r, lf, rg;\r\n    Node(): val(0), lazy(0), lf(-1), rg(-1) {}\r\n};\r\n\r\nconst ll INF = 1e9;\r\nconst ll M = 1e9 + 7;\r\nNode segTree[(ll) 2e7];\r\nll cnt = 2;\r\n\r\nvoid propagate(ll idx) {\r\n    if (segTree[idx].lazy) {\r\n        segTree[idx].val += (segTree[idx].r - segTree[idx].l + 1) * segTree[idx].lazy;\r\n        ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n        \r\n        if (segTree[idx].lf == -1) {\r\n            segTree[idx].lf = cnt++;\r\n            segTree[segTree[idx].lf].l = segTree[idx].l;\r\n            segTree[segTree[idx].lf].r = mid;\r\n        }\r\n        \r\n        if (segTree[idx].rg == -1) {\r\n            segTree[idx].rg = cnt++;\r\n\r\n            segTree[segTree[idx].rg].l = mid + 1;\r\n            segTree[segTree[idx].rg].r = segTree[idx].r;\r\n        }\r\n\r\n        segTree[segTree[idx].lf].lazy += segTree[idx].lazy;\r\n        segTree[segTree[idx].rg].lazy += segTree[idx].lazy;\r\n        segTree[idx].lazy = 0;\r\n    }\r\n}\r\n\r\nvoid update(ll idx, ll x, ll y, ll v) {\r\n    if (segTree[idx].l == x && segTree[idx].r == y) {\r\n        segTree[idx].lazy += v;\r\n        propagate(idx);\r\n        return;\r\n    }\r\n\r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    if (x > mid) update(segTree[idx].rg, x, y, v);\r\n    else if (y <= mid) update(segTree[idx].lf, x, y, v);\r\n    else {\r\n        update(segTree[idx].lf, x, mid, v);\r\n        update(segTree[idx].rg, mid + 1, y, v);\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n    segTree[idx].val = segTree[segTree[idx].lf].val + segTree[segTree[idx].rg].val;\r\n}\r\n\r\nll query(ll idx, ll x, ll y) {\r\n    propagate(idx);\r\n\r\n    if (segTree[idx].l == x && segTree[idx].r == y) return segTree[idx].val;\r\n    \r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n\r\n    if (x > mid) return query(segTree[idx].rg, x, y);\r\n    else if (y <= mid) return query(segTree[idx].lf, x, y);\r\n    else return query(segTree[idx].lf, x, mid) + query(segTree[idx].rg, mid + 1, y);\r\n}\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\n    ll n, q; cin >> n >> q;\r\n\r\n    segTree[1].l = 1; segTree[1].r = n;//(ll) 1e9;\r\n\r\n    while (q--) {\r\n        ll t; cin >> t;\r\n        \r\n        if (t == 1) {\r\n            ll l, r, x; cin >> l >> r >> x;\r\n            update(1, l, r, x);\r\n        } else {\r\n            ll l, r; cin >> l >> r;\r\n            cout << query(1, l, r) << endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "elainagrey",
        "id": 243159,
        "date": "2023-02-28 17:51:24",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define f first\r\n#define s second\r\nint n,q,a,b,c,d;\r\nstruct node{\r\n    int s,e,m,val,lazy;\r\n    node *l,*r;\r\n    node(int S, int E){\r\n        s=S, e=E,m=(s+e)/2;\r\n        val=0;lazy=0;\r\n        l=nullptr; r=nullptr;\r\n    }\r\n    void create(){\r\n        if(s!=e){\r\n            l=new node(s,m);\r\n            r=new node(m+1,e);\r\n        }\r\n    }\r\n    void prop(){\r\n        if(lazy==0)return;\r\n        val=val+lazy*(e-s+1);\r\n        if(s!=e){if(l==nullptr)create();l->lazy+=lazy,r->lazy+=lazy;}\r\n        lazy=0;\r\n    }\r\n    void upd(int S, int E, int V){\r\n        if(l==nullptr)create();\r\n        if(s==S && e==E)lazy+=V;\r\n        else{\r\n            if(E<=m)l->upd(S,E,V);\r\n            else if(S>m)r->upd(S,E,V);\r\n            else{\r\n                l->upd(S,m,V);\r\n                r->upd(m+1,E,V);\r\n            }\r\n            l->prop();r->prop();\r\n            val=l->val+r->val;\r\n        }\r\n    }\r\n    int qry(int S, int E){\r\n        if(l==nullptr)create();\r\n        prop();\r\n        if(s==S&&e==E)return val;\r\n        if(E<=m)return l->qry(S,E);\r\n        else if(S>m)return r->qry(S,E);\r\n        else{\r\n            return l->qry(S,m)+r->qry(m+1,E);\r\n        }\r\n    }\r\n}*root;\r\nsigned main(){\r\n    ios_base::sync_with_stdio(false);cin.tie(0);\r\n    cin>>n>>q;\r\n    root=new node(0,1e9);\r\n    while(q--){\r\n        cin>>a>>b>>c;\r\n        if(a==2){\r\n            cout<<root->qry(b,c)<<endl;\r\n        }else{\r\n            cin>>d;\r\n            root->upd(b,c,d);\r\n        }\r\n    }\r\n\r\n}"
    },
    {
        "username": "hpesoj",
        "id": 243156,
        "date": "2023-02-28 17:44:42",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define f first\r\n#define s second\r\nint n,q,a,b,c,d;\r\nstruct node{\r\n    int s,e,m,val,lazy;\r\n    node *l,*r;\r\n    node(int S, int E){\r\n        s=S, e=E,m=(s+e)/2;\r\n        val=0;lazy=0;\r\n        l=nullptr; r=nullptr;\r\n    }\r\n    void create(){\r\n        if(s!=e and l == nullptr){\r\n            l=new node(s,m);\r\n            r=new node(m+1,e);\r\n        }\r\n    }\r\n    void prop(){\r\n        if(lazy==0)return;\r\n        val=val+lazy*(e-s+1);\r\n        if(s!=e){create();l->lazy+=lazy,r->lazy+=lazy;}\r\n        lazy=0;\r\n    }\r\n    void upd(int S, int E, int V){\r\n        if(l==nullptr)create();\r\n        if(s==S && e==E)lazy+=V;\r\n        else{\r\n            if(E<=m)l->upd(S,E,V);\r\n            else if(S>m)r->upd(S,E,V);\r\n            else{\r\n                l->upd(S,m,V);\r\n                r->upd(m+1,E,V);\r\n            }\r\n            l->prop();r->prop();\r\n            val=l->val+r->val;\r\n        }\r\n    }\r\n    int qry(int S, int E){\r\n        if(l==nullptr)create();\r\n        prop();\r\n        if(s==S&&e==E)return val;\r\n        if(E<=m)return l->qry(S,E);\r\n        else if(S>m)return r->qry(S,E);\r\n        else{\r\n            return l->qry(S,m)+r->qry(m+1,E);\r\n        }\r\n    }\r\n}*root;\r\nsigned main(){\r\n    ios_base::sync_with_stdio(false);cin.tie(0);\r\n    cin>>n>>q;\r\n    root=new node(0,1e9);\r\n    while(q--){\r\n        cin>>a>>b>>c;\r\n        if(a==2){\r\n            cout<<root->qry(b,c)<<endl;\r\n        }else{\r\n            cin>>d;\r\n            root->upd(b,c,d);\r\n        }\r\n    }\r\n\r\n}"
    },
    {
        "username": "Potatodef",
        "id": 234690,
        "date": "2023-02-12 14:55:38",
        "code": "#include <algorithm>\r\n#include <iostream>\r\n#include <cstring>\r\n#include <climits>\r\n#include <cstdio>\r\n#include <cmath>\r\n#include <unordered_map>\r\n#include <vector>\r\n#include <stack>\r\n#include <deque>\r\n#include <queue>\r\n#include <map>\r\n#include <set>\r\n#include <iomanip>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<ll, ll> pll;\r\ntypedef vector<ll> vll;\r\ntypedef vector<pll> vpll;\r\ntypedef vector<string> vs;\r\ntypedef vector<bool> vb;\r\ntypedef map<ll, ll> mll;\r\ntypedef set<ll> sll;\r\ntypedef queue<ll> qll;\r\ntypedef queue<pll> qpll;\r\n\r\n#define all(x) x.begin(), x.end()\r\n#define sz(x) (ll) x.size()\r\n#define fr front()\r\n#define bk back()\r\n#define pb push_back\r\n#define pf push_front\r\n#define fi first\r\n#define se second\r\n#define FOR(i, a, b, inc) for (ll i = a; i < b; i += inc)\r\n#define RFOR(i, a, b, inc) for (ll i = b - 1; i >= a; i -= inc)\r\n#define REP(i, a) FOR(i, 0, a, 1)\r\n#define RREP(i, a) RFOR(i, 0, a, 1)\r\n#define each(a, x) for (auto& a: x)\r\n\r\nstruct Node {\r\n    ll val, lazy, l, r, lf, rg;\r\n    Node(): val(0), lazy(0), lf(-1), rg(-1) {}\r\n};\r\n\r\nconst ll INF = 1e9;\r\nconst ll M = 1e9 + 7;\r\nNode segTree[(ll) 2e7];\r\nll cnt = 2;\r\n\r\nvoid propagate(ll idx) {\r\n    if (segTree[idx].lazy) {\r\n        segTree[idx].val += (segTree[idx].r - segTree[idx].l + 1) * segTree[idx].lazy;\r\n        ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n        \r\n        if (segTree[idx].lf == -1) {\r\n            segTree[idx].lf = cnt++;\r\n            segTree[segTree[idx].lf].l = segTree[idx].l;\r\n            segTree[segTree[idx].lf].r = mid;\r\n        }\r\n        \r\n        if (segTree[idx].rg == -1) {\r\n            segTree[idx].rg = cnt++;\r\n\r\n            segTree[segTree[idx].rg].l = mid + 1;\r\n            segTree[segTree[idx].rg].r = segTree[idx].r;\r\n        }\r\n\r\n        segTree[segTree[idx].lf].lazy += segTree[idx].lazy;\r\n        segTree[segTree[idx].rg].lazy += segTree[idx].lazy;\r\n        segTree[idx].lazy = 0;\r\n    }\r\n}\r\n\r\nvoid update(ll idx, ll x, ll y, ll v) {\r\n    if (segTree[idx].l == x && segTree[idx].r == y) {\r\n        segTree[idx].lazy += v;\r\n        propagate(idx);\r\n        return;\r\n    }\r\n\r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    if (x > mid) update(segTree[idx].rg, x, y, v);\r\n    else if (y <= mid) update(segTree[idx].lf, x, y, v);\r\n    else {\r\n        update(segTree[idx].lf, x, mid, v);\r\n        update(segTree[idx].rg, mid + 1, y, v);\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n    segTree[idx].val = segTree[segTree[idx].lf].val + segTree[segTree[idx].rg].val;\r\n}\r\n\r\nll query(ll idx, ll x, ll y) {\r\n    propagate(idx);\r\n\r\n    if (segTree[idx].l == x && segTree[idx].r == y) return segTree[idx].val;\r\n    \r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n\r\n    if (x > mid) return query(segTree[idx].rg, x, y);\r\n    else if (y <= mid) return query(segTree[idx].lf, x, y);\r\n    else return query(segTree[idx].lf, x, mid) + query(segTree[idx].rg, mid + 1, y);\r\n}\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\n    ll n, q; cin >> n >> q;\r\n\r\n    segTree[1].l = 1; segTree[1].r = n;//(ll) 1e9;\r\n\r\n    while (q--) {\r\n        ll t; cin >> t;\r\n        \r\n        if (t == 1) {\r\n            ll l, r, x; cin >> l >> r >> x;\r\n            update(1, l, r, x);\r\n        } else {\r\n            ll l, r; cin >> l >> r;\r\n            cout << query(1, l, r) << endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "feilinlp",
        "id": 234505,
        "date": "2023-02-11 23:39:24",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef pair<ll,ll> ii;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\n\r\nll n,q,k,a,b,v;\r\nint main(){\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(0);\r\n    cin>>n>>q;\r\n    root = new node(0, 1100000000);\r\n    while(q--){\r\n        cin>>k;\r\n        if(k==1){\r\n            cin>>a>>b>>v;\r\n            root->add(a, b, v);\r\n        }else{\r\n            cin>>a>>b;\r\n            cout<<root->range_sum(a, b)<<endl;\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "caffeine",
        "id": 229167,
        "date": "2023-01-31 19:34:19",
        "code": "#include <iostream>\r\n#define int long long\r\nusing namespace std;\r\n\r\nstruct node{\r\n    int s,e,m;\r\n    int val,lazy;\r\n    node *l,*r;\r\n\r\n    node(int S,int E){//node constructor\r\n        s=S,e=E,m=(s+e)/2;\r\n        val=0;\r\n        lazy=0;\r\n    }\r\n\r\n    void create(){\r\n        if(s!=e){\r\n            l=new node(s,m);\r\n            r=new node(m+1,e);\r\n        }\r\n    }\r\n\r\n    void propagate(){\r\n        if(lazy==0)return;\r\n        val+=lazy*(e-s+1);//(e-s+1) is length of range\r\n        if(s!=e){//node is not a leaf; send lazy tag to children\r\n            if(l==nullptr)create();\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0;//propagation done, set lazy tag to 0\r\n    }\r\n\r\n    void update(int S,int E,int V){//increment [S,E] by V\r\n        if(s==S&&e==E)lazy+=V;//update covers range, update lazy tag\r\n        else {\r\n            if(l==nullptr)create();\r\n            if(E<=m)l->update(S,E,V);//recurse left, [S,E] is in left child\r\n            else if(m<S)r->update(S,E,V);//recurse right,, [S,E] is in right child\r\n            else l->update(S,m,V),r->update(m+1,E,V);\r\n            l->propagate(),r->propagate();//propagate before updating yourself\r\n            val=l->val+r->val;//update function\r\n        }\r\n    }\r\n\r\n    int query(int S,int E){\r\n        propagate();\r\n        if(s==S&&e==E)return val;//current range exactly matches query range\r\n        else {\r\n            if(l==nullptr)create();\r\n            if(E<=m)return l->query(S,E); //current range on left of query range\r\n            else if (S>=m+1)return r->query(S,E); //current range on right of query range\r\n            else return l->query(S,m)+r->query(m+1,E); //current range spans query range, split query range into two\r\n        }\r\n    }\r\n} *root;\r\n\r\nint32_t main(){\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n    ios_base::sync_with_stdio(false);\r\n    int n,q;\r\n    cin>>n>>q;\r\n    root=new node(1,n);\r\n    for(int i=0;i<q;i++){\r\n        int a,b,c,d;\r\n        cin>>a>>b>>c;\r\n        if(a==1){\r\n            cin>>d;\r\n            root->update(b,c,d);\r\n        }\r\n        else cout<<root->query(b,c)<<\"\\n\";\r\n    }\r\n}"
    },
    {
        "username": "IWKR",
        "id": 228282,
        "date": "2023-01-29 12:31:35",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node {\r\n\tint val, lazy; // sum of [s, e]\r\n\tnode *l, *r; // create 2 children l and r, where l is [s, m] and [m + 1, e]\r\n\tnode(): val(0), l(NULL), r(NULL), lazy(0) {}\r\n\t\r\n\tint value(int s, int e) { // constructor called node\r\n\t\tval = val + (lazy * (e - s + 1));\r\n\t\tif (s == e) {\r\n\t\t\tlazy = 0;\r\n\t\t\treturn val;\r\n\t\t}\r\n\t\tif (l == NULL) {\r\n\t\t\tl = new node();\r\n\t\t}\r\n\t\tl -> lazy += lazy;\r\n\t\tif (r == NULL) {\r\n\t\t\tr = new node();\r\n\t\t}\r\n\t\tr -> lazy += lazy;\r\n\t\tlazy = 0;\r\n\t\treturn val;\r\n\t}\r\n\t\r\n\tvoid update(int s, int e, int x, int y, int v) { // change the X-th element to be value V\r\n\t\tint m = (s + e) / 2;\r\n\t\tif (s == x && e == y) {\r\n\t\t\tlazy = lazy + v; // node is leaf, update value\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (y <= m) {\r\n\t\t\tif (l == NULL) {\r\n\t\t\t\tl = new node();\r\n\t\t\t}\r\n\t\t\tl -> update(s, m, x, y, v);\r\n\t\t} else if (x > m) {\r\n\t\t\tif (r == NULL) {\r\n\t\t\t\tr = new node();\r\n\t\t\t}\r\n\t\t\tr -> update(m + 1, e, x, y, v);\r\n\t\t} else {\r\n\t\t\tif (l == NULL) {\r\n\t\t\t\tl = new node();\r\n\t\t\t}\r\n\t\t\tif (r == NULL) {\r\n\t\t\t\tr = new node();\r\n\t\t\t}\r\n\t\t\tl -> update(s, m, x, m, v);\r\n\t\t\tr -> update(m + 1, e, m + 1, y, v);\r\n\t\t}\r\n\t\tval = (l == NULL ? 0 : l -> value(s, m)) + (r == NULL ? 0 : r -> value(m + 1, e));\r\n\t}\r\n\t\r\n\tint query(int S, int E, int x, int y) {\r\n\t\tvalue(S, E);\r\n\t\tif (S == x && E == y) {\r\n\t\t\treturn val; // case 1\r\n\t\t}\r\n\t\tint m = (S + E) / 2;\r\n\t\tif (x > m) {\r\n\t\t\treturn (r == NULL) ? 0 : r -> query(m + 1, E, x, y); // case 2, recurse to left child\r\n\t\t}\r\n\t\tif (y <= m) {\r\n\t\t\treturn (l == NULL) ? 0 : l -> query(S, m, x, y); // case 3, recurse to right child\r\n\t\t}\r\n\t\tif (l == NULL && r != NULL) {\r\n\t\t\treturn r -> query(m + 1, E, m + 1, y);\r\n\t\t}\r\n\t\tif (l != NULL && r == NULL) {\r\n\t\t\treturn l -> query(S, m, x, m);\r\n\t\t}\r\n\t\tif (l != NULL && r != NULL) {\r\n\t\t\treturn l -> query(S, m, x, m) + r -> query(m + 1, E, m + 1, y);\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n} *root;\r\n\r\nint32_t main() {\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tcout.tie(NULL);\r\n\tint n, q;\r\n\tcin >> n >> q;\r\n\troot = new node();\r\n\tfor (int i = 0; i < q; i++) {\r\n\t\tint a;\r\n\t\tcin >> a;\r\n\t\tif (a == 1) {\r\n\t\t\tint b, c, d;\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\troot -> update(1, n, b, c, d);\r\n\t\t} else {\r\n\t\t\tint b, c;\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << root -> query(1, n, b, c) << '\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "ldminh4354",
        "id": 226980,
        "date": "2023-01-26 23:58:38",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n#define fi first\r\n#define se second\r\n#define pb push_back\r\n\r\nstruct node\r\n{\r\n    int s,e,m,val,lazy;\r\n    node *l,*r;\r\n    \r\n    node(int S,int E){\r\n        s = S; e = E; m = (s+e) / 2;    // range and midpoint\r\n        val = 0; lazy = 0;              // value and lazy value\r\n        l = nullptr; r = nullptr;       // initialise children nodes to null\r\n    }\r\n\t\r\n    void create(){\r\n        if (s != e){\r\n            // creating children nodes\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n\r\n    // PROBLEM DEPENDENT\r\n    // change according to query type\r\n    int combine(int a, int b){\r\n        return a + b;\r\n    }\r\n\t\r\n    void propogate(){\r\n        if (lazy == 0) return;    // nothing to propogate\r\n\r\n        // PROBLEM DEPENDENT\r\n        // update value of current node\r\n        // val = val + lazy * (change of current node when all its leaf nodes change by lazy)\r\n        val = val + lazy * (e-s+1);\r\n        \r\n        if (s != e){\r\n            if (l == nullptr) create();  // create children nodes if needed\r\n\r\n            // PROBLEM DEPENDENT\r\n            // how two queries would interact with each other\r\n            l -> lazy += lazy;\r\n            r -> lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n\t\r\n    void update(int S, int E, int V){\r\n        if (l == nullptr) create(); // create children nodes if needed\r\n\r\n        // cases of update range\r\n        if (s == S and e == E) lazy += V;                // exactly node range\r\n        else{\r\n            if (E <= m) l -> update(S, E, V);            // left half only\r\n            else if (S >= m+1) r -> update(S, E, V);     // right half only\r\n            else l->update(S,m,V),r->update(m+1,E,V);    // both halves\r\n\t\t\t\r\n            l -> propogate(); r -> propogate();    // propogate down children nodes\r\n            val = combine(l -> val, r -> val);     // combine children to update node's value\r\n        }\r\n    }\r\n\t\r\n    int query(int S,int E){\r\n        if (l==nullptr) create();    // create children nodes if needed\r\n        propogate();                 // propogate down children nodes\r\n\r\n        // cases of query range\r\n        if (s == S and e == E) return val;                          // exactly node range\r\n        else if (E <= m) return l -> query(S,E);                    // left half only\r\n        else if (S >= m+1) return r -> query(S,E);                  // right half only\r\n        else return combine(l -> query(S,m), r -> query(m+1,E));    // both halves\r\n    }\r\n}*root;\r\n\r\nsigned main()\r\n{\r\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\r\n\tint n,q,t,a,b,c;\r\n\tcin>>n>>q;\r\n\troot=new node(1,n);\r\n\tfor (int i=1;i<q+1;i++)\r\n\t{\r\n\t\tcin>>t;\r\n\t\tif (t==1)\r\n\t\t{\r\n\t\t\tcin>>a>>b>>c;\r\n\t\t\troot->update(a,b,c);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcin>>a>>b;\r\n\t\t\tcout<<root->query(a,b)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "shoryu386",
        "id": 220746,
        "date": "2023-01-15 01:50:28",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long stdata;\r\ninline stdata combine(stdata a, stdata b){\r\n\treturn a+b;\r\n}\r\n\r\nconst stdata defval = 0;\r\n#define lazyChange (e-s+1)\r\n#define setSentinel -1\r\nstruct node {\r\n    long long s,e,m;\r\n    node *l, *r;\r\n    stdata v;\r\n    stdata lazyUpd, lazySet;\r\n    node(int S_, int E_): s(S_), e(E_), m((s+e)>>1), l(NULL), r(NULL), v(defval), lazyUpd(0), lazySet(setSentinel) {\r\n\t\t//if(s!=e) { l = new node(s,m); r = new node(m+1,e); }\r\n    }\r\n    \r\n    inline void inst(){\r\n\t\tif (l == NULL) {l = new node(s,m), r = new node(m+1,e);}\r\n    }\r\n    \r\n\tinline stdata forceProp(){\r\n\t\tif (s==e) {if (lazySet != setSentinel){v=lazySet; lazySet = setSentinel;} v+=lazyUpd; lazyUpd = 0; return v;}\r\n\t\tif (lazySet != setSentinel) v = lazyChange*lazySet, inst(), l->lazySet = lazySet, r->lazySet = lazySet, lazySet = setSentinel;\r\n\t\tif (lazyUpd != 0) v += lazyChange*lazyUpd, inst(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n\t\treturn v;\r\n\t}\r\n    \r\n    void set(int x, stdata y){\r\n        if(s==e) { v=y; return; }\r\n        inst();\r\n        if(x>m) r->set(x,y);\r\n        else l->set(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    void upd(int x, stdata y){\r\n        if(s==e) { v+=y; return; }\r\n        inst();\r\n        if(x>m) r->upd(x,y);\r\n        else l->upd(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    \r\n    //range operations assume stdata is a numeric type. (yes, floats work :D)\r\n    //comment out all range operations to ignore it all\r\n    void rangeUpd(int first, int last, stdata c){\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazyUpd += c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tinst();\r\n\t\tforceProp();\r\n\t\tif (first <= m){ l->rangeUpd(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeUpd(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n\t\r\n\tvoid rangeSet(int first, int last, stdata c){\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazySet = c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tinst();\r\n\t\tforceProp();\r\n\t\tif (first <= m){ l->rangeSet(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeSet(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n    \r\n    stdata query(int x, int y){\r\n\t\t\r\n\t\tif (s==e) {return forceProp();}\r\n\t\tif (x <= s && y >= e){ return forceProp();}\r\n\t\tinst();\r\n\t\tforceProp();\r\n        if(y<=m) { return l->query(x, y);}\r\n        if(x>m) { return r->query(x, y);}\r\n        return combine(l->query(x, m), r->query(m+1, y));\r\n    }\r\n};\r\nint main(){\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n\tint n, q; cin >> n >> q;\r\n\tnode st(1, n);\r\n\t\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint com, a, b, c; cin >> com >> a >> b;\r\n\t\tif (com == 1){\r\n\t\t\tcin >> c;\r\n\t\t\tst.rangeUpd(a, b, c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << st.query(a, b) << '\\n';\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n"
    },
    {
        "username": "zyh571",
        "id": 217815,
        "date": "2023-01-10 08:03:29",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tll N, Q;\r\n\tcin >> N >> Q;\r\n\troot = new node(0, N);\r\n\tfor(int i = 0; i < Q; i++){\r\n\t\tll inp, inp2, inp3, inp4;\r\n\t\tcin >> inp >> inp2 >> inp3;\r\n\t\tif(inp == 1){\r\n\t\t\tcin >> inp4;\r\n\t\t\troot->add(inp2, inp3, inp4);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << root->range_sum(inp2, inp3) << '\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "dzuizz",
        "id": 216723,
        "date": "2023-01-08 18:24:15",
        "code": "#include <algorithm>\r\n#include <iostream>\r\n#include <cstring>\r\n#include <climits>\r\n#include <cstdio>\r\n#include <cmath>\r\n#include <unordered_map>\r\n#include <vector>\r\n#include <stack>\r\n#include <deque>\r\n#include <queue>\r\n#include <map>\r\n#include <set>\r\n#include <iomanip>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef unsigned long long ull;\r\ntypedef pair<ll, ll> pll;\r\ntypedef vector<ll> vll;\r\ntypedef vector<pll> vpll;\r\ntypedef vector<string> vs;\r\ntypedef vector<bool> vb;\r\ntypedef map<ll, ll> mll;\r\ntypedef set<ll> sll;\r\ntypedef queue<ll> qll;\r\ntypedef queue<pll> qpll;\r\n\r\n#define all(x) x.begin(), x.end()\r\n#define sz(x) (ll) x.size()\r\n#define fr front()\r\n#define bk back()\r\n#define pb push_back\r\n#define pf push_front\r\n#define fi first\r\n#define se second\r\n#define FOR(i, a, b, inc) for (ll i = a; i < b; i += inc)\r\n#define RFOR(i, a, b, inc) for (ll i = b - 1; i >= a; i -= inc)\r\n#define REP(i, a) FOR(i, 0, a, 1)\r\n#define RREP(i, a) RFOR(i, 0, a, 1)\r\n#define each(a, x) for (auto& a: x)\r\n\r\nstruct Node {\r\n    ll val, lazy, l, r, lf, rg;\r\n    Node(): val(0), lazy(0), lf(-1), rg(-1) {}\r\n};\r\n\r\nconst ll INF = 1e9;\r\nconst ll M = 1e9 + 7;\r\nNode segTree[(ll) 2e7];\r\nll cnt = 2;\r\n\r\nvoid propagate(ll idx) {\r\n    if (segTree[idx].lazy) {\r\n        segTree[idx].val += (segTree[idx].r - segTree[idx].l + 1) * segTree[idx].lazy;\r\n        ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n        \r\n        if (segTree[idx].lf == -1) {\r\n            segTree[idx].lf = cnt++;\r\n            segTree[segTree[idx].lf].l = segTree[idx].l;\r\n            segTree[segTree[idx].lf].r = mid;\r\n        }\r\n        \r\n        if (segTree[idx].rg == -1) {\r\n            segTree[idx].rg = cnt++;\r\n\r\n            segTree[segTree[idx].rg].l = mid + 1;\r\n            segTree[segTree[idx].rg].r = segTree[idx].r;\r\n        }\r\n\r\n        segTree[segTree[idx].lf].lazy += segTree[idx].lazy;\r\n        segTree[segTree[idx].rg].lazy += segTree[idx].lazy;\r\n        segTree[idx].lazy = 0;\r\n    }\r\n}\r\n\r\nvoid update(ll idx, ll x, ll y, ll v) {\r\n    if (segTree[idx].l == x && segTree[idx].r == y) {\r\n        segTree[idx].lazy += v;\r\n        propagate(idx);\r\n        return;\r\n    }\r\n\r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    if (x > mid) update(segTree[idx].rg, x, y, v);\r\n    else if (y <= mid) update(segTree[idx].lf, x, y, v);\r\n    else {\r\n        update(segTree[idx].lf, x, mid, v);\r\n        update(segTree[idx].rg, mid + 1, y, v);\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n    segTree[idx].val = segTree[segTree[idx].lf].val + segTree[segTree[idx].rg].val;\r\n}\r\n\r\nll query(ll idx, ll x, ll y) {\r\n    propagate(idx);\r\n\r\n    if (segTree[idx].l == x && segTree[idx].r == y) return segTree[idx].val;\r\n    \r\n    ll mid = (segTree[idx].l + segTree[idx].r) / 2;\r\n    if (segTree[idx].lf == -1) {\r\n        segTree[idx].lf = cnt++;\r\n\r\n        segTree[segTree[idx].lf].l = segTree[idx].l;\r\n        segTree[segTree[idx].lf].r = mid;\r\n    }\r\n\r\n    if (segTree[idx].rg == -1) {\r\n        segTree[idx].rg = cnt++;\r\n\r\n        segTree[segTree[idx].rg].l = mid + 1;\r\n        segTree[segTree[idx].rg].r = segTree[idx].r;\r\n    }\r\n\r\n    propagate(segTree[idx].lf);\r\n    propagate(segTree[idx].rg);\r\n\r\n    if (x > mid) return query(segTree[idx].rg, x, y);\r\n    else if (y <= mid) return query(segTree[idx].lf, x, y);\r\n    else return query(segTree[idx].lf, x, mid) + query(segTree[idx].rg, mid + 1, y);\r\n}\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\n    ll n, q; cin >> n >> q;\r\n\r\n    segTree[1].l = 1; segTree[1].r = n;//(ll) 1e9;\r\n\r\n    while (q--) {\r\n        ll t; cin >> t;\r\n        \r\n        if (t == 1) {\r\n            ll l, r, x; cin >> l >> r >> x;\r\n            update(1, l, r, x);\r\n        } else {\r\n            ll l, r; cin >> l >> r;\r\n            cout << query(1, l, r) << endl;\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "PanGD",
        "id": 206064,
        "date": "2022-12-31 16:51:40",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long int \r\n//https://codebreaker.xyz/problem/segmenttree2\r\nstruct node{\r\n    int s,e,m;\r\n    int val, lazy;\r\n    node *l = nullptr,*r = nullptr;\r\n    \r\n    \r\n    node(int S, int E){//just creating\r\n        s = S, e=E;\r\n        m = (s+e)>>1;\r\n        val = 0, lazy = 0;\r\n        \r\n        \r\n    }\r\n    \r\n    void create(){\r\n        if(s!=e){\r\n            l = new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n    \r\n    void propagation(){\r\n        if(l == nullptr) create();\r\n        \r\n        if(lazy == 0) return;\r\n        \r\n        val += (lazy * (e - s + 1));\r\n        \r\n        if(s != e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        \r\n        lazy =0;\r\n    }\r\n    \r\n    void update(int S, int E, int increment){\r\n        if(l == nullptr) create(); //lazily create children\r\n            \r\n        \r\n        if(S == s && E == e) lazy += increment;\r\n        else{\r\n            if(E <= m) l->update(S, E, increment);\r\n            else if(S > m) r -> update(S, E, increment);// [S,E] is in the right child\r\n            else {\r\n                l-> update(S, m,increment); \r\n                r->update(m+1, E, increment);\r\n            }\r\n            \r\n            l->propagation(), r->propagation();\r\n            val = l->val + r->val;\r\n        }\r\n    }\r\n    \r\n    \r\n    int query(int S, int E){\r\n        if(l == nullptr) create();\r\n        \r\n        propagation();\r\n        if(S == s && E == e) return val;\r\n        else if(E <= m) return l->query(S, E );\r\n        else if(S > m) return r->query(S, E);\r\n        else return (l->query(S, m) + r->query(m+1,E));     \r\n    }\r\n};\r\n\r\nsigned main(){\r\n    int n,m;\r\n    cin >> n >> m;\r\n    node *root = new node(1,n);\r\n    \r\n    for(int i =0;i<m;i++){\r\n        int type;\r\n        cin >> type;\r\n        if(type == 1){\r\n            int a,b,c;\r\n            //a--;b--;\r\n            \r\n            cin >> a >> b >> c;\r\n            \r\n            root->update(a,b,c);\r\n        }\r\n        else{\r\n            int a,b;\r\n            //a--,b--;\r\n            cin >> a >> b;\r\n            \r\n            cout << root->query(a,b) << \"\\n\"; //inclusive\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "oolimry",
        "id": 205699,
        "date": "2022-12-30 17:38:23",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long int \r\n//https://codebreaker.xyz/problem/segmenttree2\r\nstruct node{\r\n    int s,e,m;\r\n    int val, lazy;\r\n    node *l = nullptr,*r = nullptr;\r\n    \r\n    \r\n    node(int S, int E){//just creating\r\n        s = S, e=E;\r\n        m = (s+e)>>1;\r\n        val = 0, lazy = 0;\r\n        \r\n        \r\n    }\r\n    \r\n    void create(){\r\n        if(s!=e){\r\n            l = new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n    \r\n    void propagation(){\r\n        if(lazy == 0) return;\r\n        \r\n        val += (lazy * (e - s + 1));\r\n        \r\n\t\t\r\n        if(s != e){\r\n\t\t\tif(l == nullptr) create();\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        \r\n        lazy =0;\r\n    }\r\n    \r\n    void update(int S, int E, int increment){\r\n        if(l == nullptr) create(); //lazily create children\r\n        \r\n            \r\n        if(S == s && E == e) lazy += increment;\r\n        else{\r\n            if(E <= m) l->update(S, E, increment);\r\n            else if(S > m) r -> update(S, E, increment);// [S,E] is in the right child\r\n            else l-> update(S, m,increment), r->update(m+1, E, increment);\r\n            \r\n\t\t\tl->propagation(), r->propagation();\r\n            val = l->val + r->val;\r\n        }\r\n        \r\n        \r\n    }\r\n    int query(int S, int E){\r\n        if(l == nullptr) create();\r\n        \r\n        propagation();\r\n        if(S == s && E == e) return val;\r\n        else if(E <= m) return l->query(S, E );\r\n        else if(S > m) return r->query(S, E);\r\n        else return (l->query(S, m) + r->query(m+1,E));     \r\n    }\r\n};\r\n\r\nsigned main(){\r\n    int n,m;\r\n    cin >> n >> m;\r\n    node *root = new node(1,n);\r\n    \r\n    for(int i =0;i<m;i++){\r\n        int type;\r\n        cin >> type;\r\n        if(type == 1){\r\n            int a,b,c;\r\n            //a--;b--;\r\n            \r\n            cin >> a >> b >> c;\r\n            \r\n            root->update(a,b,c);\r\n        }\r\n        else{\r\n            int a,b;\r\n            //a--,b--;\r\n            cin >> a >> b;\r\n            \r\n            cout << root->query(a,b) << \"\\n\"; //inclusive\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "PoTheSloth",
        "id": 203550,
        "date": "2022-12-28 14:06:25",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node\r\n{\r\n    int s, e, mid, val, lazy;\r\n    node *l=nullptr, *r=nullptr;\r\n    node(int S, int E){\r\n        s = S; e = E; mid = (s + e)/2; val = 0; lazy=0;\r\n    }\r\n    void propagate(){\r\n\t\tif(s!=e){\r\n\t\t\tif(l==nullptr)l = new node(s, mid);\r\n\t\t\tif(r==nullptr)r = new node(mid + 1, e);\r\n\t\t}\r\n        if(lazy==0){return;}\r\n        val+=lazy*(e-s+1);\r\n        if(s!=e){\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0;\r\n    }\r\n    void update(int S, int E, int V){\r\n\t\tif(s!=e){\r\n\t\t\tif(l==nullptr)l = new node(s, mid);\r\n\t\t\tif(r==nullptr)r = new node(mid + 1, e);\r\n\t\t}\r\n\t\tpropagate();lazy=0;\r\n\t\tif(s!=e){l->propagate();r->propagate();}\r\n        if(s==S and e==E){lazy+=V;return;}\r\n        else if(E<=mid){propagate(); l->update(S, E, V);}\r\n        else if(S>mid){propagate(); r->update(S, E, V);}\r\n        else{\r\n\t\t\tpropagate();\r\n            l->update(S, mid, V);\r\n            r->update(mid+1, E, V);\r\n        }\r\n        propagate();\r\n        if(s!=e){l->propagate();r->propagate();}\r\n        val = l->val+r->val;\r\n    }\r\n    int query(int S, int E){\r\n\t\tif(s!=e){\r\n\t\t\tif(l==nullptr)l = new node(s, mid);\r\n\t\t\tif(r==nullptr)r = new node(mid + 1, e);\r\n\t\t}\r\n\t\tpropagate();lazy=0;\r\n        if(s == S and e == E){return val;}\r\n        else if(E <= mid){propagate(); return l->query(S, E);}\r\n\t\telse if(S>mid){propagate(); return r->query(S, E);}\r\n\t\telse{propagate(); return (l->query(S, mid) + r->query(mid+1, E));}\r\n\t\tval = l->val+r->val;\r\n    }\r\n    void initialise(int index, int V){\r\n        if(s==e){val=V;return;}\r\n        if(index<=mid)l->initialise(index, V);\r\n        if(index>mid)r->initialise(index, V);\r\n        //l->propagate();r->propagate();\r\n        val = l->val+r->val;\r\n    }\r\n}*segtree;\r\nint n, q;\r\nint32_t main(){\r\n    ios_base::sync_with_stdio(false); cin.tie(0);cout.tie(0);\r\n    cin>>n>>q;\r\n    segtree = new node(0, n);\r\n    for(int i=0; i<q; ++i){\r\n        short type;\r\n        cin>>type;\r\n        if(type==1){\r\n            int s, e, v;\r\n            cin>>s>>e>>v;\r\n\t\t\tsegtree->update(s, e, v);\r\n        }\r\n        if(type==2){\r\n            int s, e;\r\n            cin>>s>>e;\r\n            cout<<segtree->query(s, e)<<'\\n';\r\n        }\r\n    }\r\n    //~ segtree = new node(0, 5); //DEBUG\r\n    //~ segtree->update(1, 3, -2);//DEBUG\r\n    //~ cout<<segtree->query(1, 1)<<' '<<segtree->query(2, 2)<<' '<<segtree->query(3, 3);//DEBUG\r\n}\r\n"
    },
    {
        "username": "hht",
        "id": 199415,
        "date": "2022-12-22 14:37:40",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define ld long double\r\ntypedef pair <int, int> pii;\r\ntypedef pair <int, bool> pib;\r\ntypedef pair <int, pair <int, int> > pip;\r\ntypedef pair <pair <int, int>, int> ppi;\r\n#pragma GCC target (\"avx2\")\r\n#pragma GCC optimization (\"O3\")\r\n#pragma GCC optimization (\"unroll-loops\")\r\n#define fi first\r\n#define se second\r\n#define all(x) (x).begin(),(x).end()\r\n#define MP make_pair\r\n#define rep(i,a,b) for (long long i=(a);i<(b);i++)\r\n#define rrep(i,a,b) for (long long i=(a);i>(b);i--)\r\n#define SZ(x) ((long long) sizeof(x))\r\n#define pb push_back  \r\n\r\n#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\r\n#define fileinp freopen(\"ain.txt\",\"r\",stdin);freopen(\"aout.txt\",\"w\",stdout);\r\n\r\nconst int dx[]={1,-1 ,0,0,1,-1,-1,1};\r\nconst int dy[]={0,0,1,-1,-1,-1,1,1};\r\n\r\nconst int mod=1e9+7;\r\nconst int mod2=998244353;\r\nconst int INF=(int)1e18;\r\nconst int N=4005;\r\n\r\nstruct node{\r\n    int s,m,e,v,lazy;\r\n    node *l,*r;\r\n    node(int _s, int _e){\r\n        s=_s;\r\n        e=_e;\r\n        m=(s+e)/2;\r\n        lazy=0;\r\n        v=0;\r\n    }\r\n    void update(int x,int y,int add){\r\n        if(s==x&&e==y){\r\n            lazy+=add;\r\n            return;\r\n        }\r\n        if(!l)l=new node(s,m); \r\n        if(!r)r=new node(m+1,e);\r\n        propagate();\r\n        if(y<=m)l->update(x,y,add);\r\n        else if(x>m)r->update(x,y,add);\r\n        else{\r\n            l->update(x,m,add);\r\n            r->update(m+1,y,add);\r\n        }\r\n        v=l->value()+r->value();\r\n    }\r\n\r\n    int query(int x, int y){\r\n        if(s==x&&e==y){\r\n            return value();\r\n        }\r\n        if(!l)l = new node(s,m); \r\n        if(!r)r = new node(m+1,e);\r\n        propagate();\r\n        if (y <= m)return l->query(x,y);\r\n        else if(x>m)return r->query(x,y);\r\n        else{\r\n            return l->query(x,m)+r->query(m+1,y);\r\n        }\r\n    }\r\n    int value(){\r\n        return v+lazy*(e-s+1);\r\n    }\r\n    void propagate(){\r\n        if (s==e)return;\r\n        l->lazy+=lazy;\r\n        r->lazy+=lazy;\r\n        lazy=0;\r\n        v=l->value()+r->value();\r\n    }\r\n}*root;\r\n\r\nint n,q,a,b,c,d;\r\n\r\nsigned main(){\r\n    fastio;\r\n    //fileinp;\r\n    cin>>n>>q;\r\n    root=new node(1,n);\r\n    rep(i,0,q){\r\n        cin>>a;\r\n        if(a==1){\r\n            cin>>b>>c>>d;\r\n            root->update(b,c,d);\r\n        }else{\r\n            cin>>b>>c;\r\n            cout<<root->query(b,c)<<'\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "bribritt",
        "id": 199248,
        "date": "2022-12-22 09:05:43",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\nstruct node{\r\n    ll s, e, v, mid, lazy;\r\n    node *l, *r;\r\n    node(ll _s, ll _e) {\r\n        s = _s; e = _e; v = 0; mid = (s + e) / 2; lazy = 0;\r\n    }\r\n    void create() {\r\n        if(!l && s != e) {\r\n            l = new node(s, mid);\r\n            r = new node(mid + 1, e);\r\n        }\r\n    }\r\n    ll truevalue() {\r\n        return lazy * (e - s + 1) + v;\r\n    }\r\n    ll query(ll x, ll y) {\r\n        if(s == x && e == y) {return truevalue();}\r\n        create();\r\n        ll ans = (y - x + 1) * lazy;\r\n        if(y <= mid) return l->query(x, y) + ans;\r\n        else if(x > mid) return r->query(x, y) + ans;\r\n        else return l->query(x,mid) + r->query(mid + 1,y) + ans;\r\n    }\r\n    void update(ll x, ll y, ll u) {\r\n        if(x == s && y == e) {\r\n            lazy += u; return;\r\n        }\r\n        create();\r\n        if(y <= mid) l->update(x, y, u);\r\n        else if(x > mid) r->update(x, y, u);\r\n        else {l->update(x, mid, u); r->update(mid + 1, y, u);}\r\n        v = l->truevalue() + r->truevalue();\r\n    }\r\n}*root;\r\n\r\nint main() {\r\n    ll N, Q, A, B, C; cin >> N >> Q; root = new node(1, N); root->create();\r\n    while(Q--) {\r\n        cin >> A >> B >> C;\r\n        if(A == 1) {\r\n            ll k; cin >> k;\r\n            root->update(B, C, k);\r\n        } else {\r\n            cout << root->query(B, C) << \"\\n\";\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "testing",
        "id": 199053,
        "date": "2022-12-21 20:48:21",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef vector<int> vi;\r\ntypedef pair<ll,ll> pi;\r\n#define mp make_pair\r\n#define pb emplace_back\r\n#define f first\r\n#define s second\r\n\r\nstruct node{\r\n\tint s,m,e;\r\n\tll v,lazy;\r\n\tnode *l, *r;\r\n\tnode(int _s, int _e){\r\n\t\ts = _s;\r\n\t\te = _e;\r\n\t\tm = (s+e)/2;\r\n\t\tlazy = 0;\r\n\t\tv = 0;\r\n\t}\r\n\r\n\tvoid update(int x, int y, int nv){\r\n\t\tif(s==x&&e==y){lazy+=nv;return;}\r\n\r\n\t\tif(!l)l = new node(s,m);\r\n\t\tif(!r)r = new node(m+1,e);\r\n\r\n\t\tif (y <= m)l->update(x,y,nv);\r\n\t\telse if (x > m)r->update(x,y,nv);\r\n\t\telse {l->update(x,m,nv); r->update(m+1,y,nv);}\t\t\r\n\t\tv = l->value() + r->value();\r\n\t}\r\n\r\n\tll query(int x,int y){\r\n\t\tif (s==x&&e==y)return value();\r\n\r\n\t\tif(!l)l = new node(s,m);\r\n\t\tif(!r)r = new node(m+1,e);\r\n\r\n\t\tll ans = 0;\r\n\t\tif (y <= m)ans = l->query(x,y);\r\n\t\telse if (x>m)ans = r->query(x,y);\r\n\t\telse ans = l->query(x,m) + r->query(m+1,y);\r\n\t\tans += (ll)(y-x+1) * lazy;\r\n\t\treturn ans;\r\n\t}\r\n\r\n\tll value(){\r\n\t\treturn v + lazy * (e-s+1);\r\n\t}\r\n}*root;\r\n\r\nint N,Q,a,b,c,d;\r\nint main(){\r\n\tios_base::sync_with_stdio(0);cin.tie(0);\r\n\tcin>>N>>Q;\r\n\troot = new node(1,N);\r\n\tfor(int i=0;i<Q;++i){\r\n\t\tcin>>a;\r\n\t\tif (a == 1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}else{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<'\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "bribritt",
        "id": 199051,
        "date": "2022-12-21 20:43:13",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\nstruct node{\r\n    ll s, e, v, mid, lazy;\r\n    node *l, *r;\r\n    node(ll _s, ll _e) {\r\n        s = _s; e = _e; v = 0; mid = (s + e) / 2; lazy = 0;\r\n    }\r\n    void create() {\r\n        if(!l && s != e) {\r\n            l = new node(s, mid);\r\n            r = new node(mid + 1, e);\r\n        }\r\n    }\r\n    void notlazy() {\r\n        create();\r\n        if(s != e) {l -> lazy += lazy; r -> lazy += lazy;}\r\n        lazy = 0;\r\n        v = l->truevalue() + r->truevalue();\r\n    }\r\n    ll truevalue() {\r\n        return lazy * (e - s + 1) + v;\r\n    }\r\n    ll query(ll x, ll y) {\r\n        if(s == x && e == y) {return truevalue();}\r\n        notlazy();\r\n        if(y <= mid) return l->query(x, y);\r\n        if(x > mid) return r->query(x, y);\r\n        return l->query(x,mid) + r->query(mid + 1,y);\r\n    }\r\n    void update(ll x, ll y, ll u) {\r\n        if(x == s && y == e) {\r\n            lazy += u; return;\r\n        }\r\n        create();\r\n        if(y <= mid) l->update(x, y, u);\r\n        else if(x > mid) r->update(x, y, u);\r\n        else {l->update(x, mid, u); r->update(mid + 1, y, u);}\r\n        v = l->truevalue() + r->truevalue();\r\n    }\r\n}*root;\r\n\r\nint main() {\r\n    ll N, Q, A, B, C; cin >> N >> Q; root = new node(1, N); root->create();\r\n    while(Q--) {\r\n        cin >> A >> B >> C;\r\n        if(A == 1) {\r\n            ll k; cin >> k;\r\n            root->update(B, C, k);\r\n        } else {\r\n            cout << root->query(B, C) << \"\\n\";\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "testing",
        "id": 199048,
        "date": "2022-12-21 20:35:14",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef vector<int> vi;\r\ntypedef pair<ll,ll> pi;\r\n#define mp make_pair\r\n#define pb emplace_back\r\n#define f first\r\n#define s second\r\n\r\nstruct node{\r\n\tint s,m,e;\r\n\tll v,lazy;\r\n\tnode *l, *r;\r\n\tnode(int _s, int _e){\r\n\t\ts = _s;\r\n\t\te = _e;\r\n\t\tm = (s+e)/2;\r\n\t\tlazy = 0;\r\n\t\tv = 0;\r\n\t}\r\n\tvoid update(int x, int y, int nv){\r\n\t\tif (s==x && e==y){\r\n\t\t\t//cerr<<\"Update lazy of \"<<x<<' '<<y<<\" to \"<<lazy+nv<<'\\n';\r\n\t\t\tlazy += nv;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(!l)l = new node(s,m); \r\n\t\tif(!r)r = new node(m+1,e);\r\n\r\n\t\tprop();\r\n\t\tif (y <= m)l->update(x,y,nv);\r\n\t\telse if (x > m)r->update(x,y,nv);\r\n\t\telse {l->update(x,m,nv); r->update(m+1,y,nv);}\r\n\t\tv  = l-> value() + r->value();\r\n\t}\r\n\r\n\tll query(int x,int y){\r\n\t\tif (s==x&&e==y){\r\n\t\t\treturn value();\r\n\t\t}\r\n\t\tif(!l)l = new node(s,m); \r\n\t\tif(!r)r = new node(m+1,e);\r\n\r\n\t\tprop();\r\n\t\tif (y <= m)return l->query(x,y);\r\n\t\telse if (x > m)return r->query(x,y);\r\n\t\telse {\r\n\t\t\treturn l->query(x,m) + r->query(m+1,y);\r\n\t\t}\r\n\t}\r\n\r\n\tll value(){\r\n\t\treturn v + lazy * (e-s+1);\r\n\t}\r\n\r\n\tvoid prop(){\r\n\t\tif (s==e)return;\r\n\t\tl->lazy += lazy;\r\n\t\tr->lazy += lazy;\r\n\t\tlazy = 0;\r\n\t\tv  = l-> value() + r->value();\r\n\t}\r\n}*root;\r\n\r\nint N,Q,a,b,c,d;\r\nint main(){\r\n\tios_base::sync_with_stdio(0);cin.tie(0);\r\n\tcin>>N>>Q;\r\n\troot = new node(1,N);\r\n\tfor(int i=0;i<Q;++i){\r\n\t\tcin>>a;\r\n\t\tif (a == 1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}else{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<'\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "lolbeast",
        "id": 194194,
        "date": "2022-12-16 11:44:32",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node {\r\n    node *l, *r;\r\n    int val, lazy;\r\n    node(): val(0), l(NULL), r(NULL), lazy(0){}\r\n    int value(int s, int e){\r\n        val += (e-s+1) * lazy;\r\n        if (s==e){\r\n            lazy = 0;\r\n            return val;\r\n        }\r\n        if (l == NULL) l = new node();\r\n        l->lazy += lazy;\r\n        if (r == NULL) r = new node();\r\n        r->lazy += lazy;\r\n        lazy = 0;\r\n        return val;\r\n    }\r\n    void update(int s, int e, int x, int y, int v) {\r\n        int m = (s + e) / 2;\r\n        if (s==x && e==y){\r\n           lazy += v;\r\n           return;\r\n        }\r\n        if (y <= m){\r\n            if (l == NULL) l = new node();\r\n            l->update(s, m, x, y, v);\r\n        } else if (x > m){\r\n            if (r == NULL) r = new node();\r\n            r->update(m+1, e, x, y, v);\r\n        } else {\r\n            if (l==NULL) l = new node();\r\n            if (r==NULL) r = new node();\r\n            l->update(s, m, x, m, v);\r\n            r->update(m+1, e, m+1, y, v);\r\n        }\r\n        val = (l==NULL?0:l->value(s, m)) + (r==NULL?0:r->value(m+1, e));\r\n    }\r\n    int query(int s, int e, int x, int y) {\r\n        value(s, e);\r\n        if (s == x && e == y) return val;\r\n        int m = (s + e) / 2;\r\n        if (x > m) return (r==NULL)? 0:r->query(m + 1, e, x, y);\r\n        if (y <= m) return (l==NULL)? 0:l->query(s, m, x, y);\r\n        if (l == NULL && r != NULL) return r->query(m+1, e, m+1, y);\r\n        if (l != NULL && r == NULL) return l->query(s, m, x, m);\r\n        if (l != NULL && r != NULL) return l->query(s, m, x, m) + r->query(m+1, e, m+1, y); //Change here for max\r\n        return 0;\r\n    }\r\n} *root;\r\nmain(){\r\n    int n, q; cin >> n >> q;\r\n    root = new node();\r\n    while (q--){\r\n        int t; cin >> t;\r\n        if (t == 1){\r\n            int a, b, c; cin >> a >> b >> c;\r\n            root->update(1, n, a, b, c);\r\n        } else {\r\n            int a, b; cin >> a >> b;\r\n            cout << root->query(1, n, a, b) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "Wilson",
        "id": 194064,
        "date": "2022-12-16 00:09:57",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node {\r\n\t\tlong long s, e, m;\r\n\t\tlong long val,lazy;\r\n\t\tnode *l, *r;\r\n\t\t\r\n\t\tnode (long long S, long long E) {\r\n\t\t\ts = S, e = E, m = (s+e)/2;\r\n\t\t\tval = 0;\r\n\t\t\tlazy = 0;\r\n\t\t}\r\n\t\t\r\n\t\tvoid create() {\r\n\t\t\tif (s != e) {\r\n\t\t\t\tl = new node(s, m);\r\n\t\t\t\tr = new node(m+1, e);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvoid propogate() {\r\n\t\t\tif (l == nullptr) create();\r\n\t\t\tif (lazy == 0) return;\r\n\t\t\t\r\n\t\t\tval += lazy*(e-s+1);\r\n\t\t\tif (s != e) {\r\n\t\t\t\tl -> lazy+=lazy;\r\n\t\t\t\tr -> lazy+=lazy;\r\n\t\t\t}\r\n\t\t\tlazy = 0;\r\n\t\t}\r\n\t\t\r\n\t\tvoid update(long long S, long long E, long long V) {\r\n\t\t\tpropogate();\r\n\t\t\tif (l == nullptr) create();\r\n\t\t\tif (s==S && e==E) lazy += V;\r\n\t\t\telse {\r\n\t\t\t\tif (E <= m) l->update(S, E, V);\r\n\t\t\t\telse if (m < S) r->update(S, E, V);\r\n\t\t\t\telse l->update(S, m, V), r->update(m+1, E, V);\r\n\t\t\t\t\r\n\t\t\t\tl->propogate(),r->propogate();\r\n\t\t\t\tval = l->val + r->val;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tlong long query(long long S, long long E) {\r\n\t\t\tif (l == nullptr) create();\r\n\t\t\tpropogate();\r\n\t\t\t\r\n\t\t\tif (s==S && e == E) return val;\r\n\t\t\telse if (E <= m) return l->query(S, E);\r\n\t\t\telse if (S >= m+1) return r->query(S, E);\r\n\t\t\telse return l->query(S, m) + r->query(m+1, E);\r\n\t\t}\r\n} *root;\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tlong long N, Q;\r\n\tcin >> N >> Q;\r\n\troot = new node(1,N);\r\n\tlong long t, l, r, k;\r\n\tfor (long long i = 0; i < Q; i++) {\r\n\t\tcin >> t >> l >> r;\r\n\t\tif (t == 1) {\r\n\t\t\tcin >> k;\r\n\t\t\troot -> update(l,r,k);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout << root->query(l,r) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "zixuan",
        "id": 193243,
        "date": "2022-12-14 16:20:35",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define endl '\\n'\r\n\r\n// range add update\r\n// range sum query \r\n// with lazy node create \r\nstruct node{\r\n\tint s,e,m;\r\n\tint val,lazy;\r\n\tnode *l, *r;\r\n\t\r\n\tnode(int S,int E){\r\n\t\ts=S,e=E,m=(s+e)/2;\r\n\t\tval=0;\r\n\t\tif(s!=e) lazy=0;\r\n\t}\r\n\t// lazy node create \r\n\tvoid create(){\r\n\t\tif(s!=e){\r\n\t\t\tl=new node(s,m);\r\n\t\t\tr=new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\t// lazy propagation \r\n\tvoid propagate(){\r\n\t\tif(s==e) return;\r\n\t\tif(lazy==0) return;\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif(l==nullptr) create();\r\n\t\tif(e-s==2){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->val+=lazy;\r\n\t\t}\r\n\t\telse if(e-s==1){\r\n\t\t\tl->val+=lazy;\r\n\t\t\tr->val+=lazy;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\t// range add update \r\n\tvoid update(int S,int E,int V){\r\n\t\tif(s==S and e==E){\r\n\t\t\tif(s!=e){\r\n\t\t\t\tlazy+=V; return;\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tval+=V; return;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif(l==nullptr) create();\r\n\t\t\r\n\t\tif(E<=m) l->update(S,E,V);\r\n\t\telse if(S>m)  r->update(S,E,V);\r\n\t\telse{\r\n\t\t\tl->update(S,m,V);\r\n\t\t\tr->update(m+1,E,V);\r\n\t\t}\r\n\t\tl->propagate(); r->propagate();\r\n\t\tval = l->val + r->val;\t\r\n\t}\r\n\t// range sum query \r\n\tint query(int S,int E){\r\n\t\tif(l==nullptr) create();\r\n\t\tpropagate();\r\n\t\tif(s==S and e==E) return val;\r\n\t\telse if(E<=m) return l->query(S,E);\r\n\t\telse if(S>m) return r->query(S,E);\r\n\t\telse return l->query(S,m) + r->query(m+1,E);\r\n\t}\r\n} *root;\r\n\r\nint32_t main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n\tint n,q; cin>>n>>q;\r\n\troot=new node(1,n);\r\n\tint type;\r\n\tint a,b,c;\r\n\tint ans;\r\n\twhile(q--){\r\n\t\tcin>>type;\r\n\t\tif(type==1){\r\n\t\t\tcin>>a>>b>>c;\r\n\t\t\troot->update(a,b,c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>a>>b;\r\n\t\t\tans=root->query(a,b);\r\n\t\t\tcout<<ans<<endl;\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "zixuan",
        "id": 193196,
        "date": "2022-12-14 15:34:06",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define endl '\\n'\r\n\r\n// range add update\r\n// range sum query \r\n// with lazy node create \r\nstruct node{\r\n\tint s,e,m;\r\n\tint val,lazy;\r\n\tnode *l, *r;\r\n\t\r\n\tnode(int S,int E){\r\n\t\ts=S,e=E,m=(s+e)/2;\r\n\t\tval=0,lazy=0;\r\n\t}\r\n\t// lazy node create \r\n\tvoid create(){\r\n\t\tif(s!=e){\r\n\t\t\tl=new node(s,m);\r\n\t\t\tr=new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\t// lazy propagation \r\n\tvoid propagate(){\r\n\t\tif(lazy==0) return;\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif(l==nullptr) create();\r\n\t\tif(s!=e){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\t// range add update \r\n\tvoid update(int S,int E,int V){\r\n\t\tif(s==S and e==E){\r\n\t\t\tlazy+=V; return;\r\n\t\t}\r\n\t\t\r\n\t\tif(l==nullptr) create();\r\n\t\t\r\n\t\tif(E<=m) l->update(S,E,V);\r\n\t\telse if(S>m)  r->update(S,E,V);\r\n\t\telse{\r\n\t\t\tl->update(S,m,V);\r\n\t\t\tr->update(m+1,E,V);\r\n\t\t}\r\n\t\tl->propagate(); r->propagate();\r\n\t\tval = l->val + r->val;\t\r\n\t}\r\n\t// range sum query \r\n\tint query(int S,int E){\r\n\t\tif(l==nullptr) create();\r\n\t\tpropagate();\r\n\t\tif(s==S and e==E) return val;\r\n\t\telse if(E<=m) return l->query(S,E);\r\n\t\telse if(S>m) return r->query(S,E);\r\n\t\telse return l->query(S,m) + r->query(m+1,E);\r\n\t}\r\n} *root;\r\n\r\nint32_t main() {\r\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n\tint n,q; cin>>n>>q;\r\n\troot=new node(1,n);\r\n\tint type;\r\n\tint a,b,c;\r\n\tint ans;\r\n\twhile(q--){\r\n\t\tcin>>type;\r\n\t\tif(type==1){\r\n\t\t\tcin>>a>>b>>c;\r\n\t\t\troot->update(a,b,c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>a>>b;\r\n\t\t\tans=root->query(a,b);\r\n\t\t\tcout<<ans<<endl;\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "lolbeast",
        "id": 191213,
        "date": "2022-12-12 12:03:37",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node {\r\n    node *l, *r;\r\n    int val, lazy;\r\n    node(): val(0), l(NULL), r(NULL), lazy(0){}\r\n    int value(int s, int e){\r\n        val += (e-s+1) * lazy;\r\n        if (s==e){\r\n            lazy = 0;\r\n            return val;\r\n        }\r\n        if (l == NULL) l = new node();\r\n        l->lazy += lazy;\r\n        if (r == NULL) r = new node();\r\n        r->lazy += lazy;\r\n        lazy = 0;\r\n        return val;\r\n    }\r\n    void update(int s, int e, int x, int y, int v) {\r\n        int m = (s + e) / 2;\r\n        if (s==x && e==y){\r\n           lazy += v;\r\n           return;\r\n        }\r\n        if (y <= m){\r\n            if (l == NULL) l = new node();\r\n            l->update(s, m, x, y, v);\r\n        } else if (x > m){\r\n            if (r == NULL) r = new node();\r\n            r->update(m+1, e, x, y, v);\r\n        } else {\r\n            if (l==NULL) l = new node();\r\n            if (r==NULL) r = new node();\r\n            l->update(s, m, x, m, v);\r\n            r->update(m+1, e, m+1, y, v);\r\n        }\r\n        val = (l==NULL?0:l->value(s, m)) + (r==NULL?0:r->value(m+1, e));\r\n    }\r\n    int query(int s, int e, int x, int y) {\r\n        value(s, e);\r\n        if (s == x && e == y) return val;\r\n        int m = (s + e) / 2;\r\n        if (x > m) return (r==NULL)? 0:r->query(m + 1, e, x, y);\r\n        if (y <= m) return (l==NULL)? 0:l->query(s, m, x, y);\r\n        if (l == NULL && r != NULL) return r->query(m+1, e, m+1, y);\r\n        if (l != NULL && r == NULL) return l->query(s, m, x, m);\r\n        if (l != NULL && r != NULL) return l->query(s, m, x, m) + r->query(m+1, e, m+1, y); //Change here for max\r\n        return 0;\r\n    }\r\n} *root;\r\nmain(){\r\n    int n, q; cin >> n >> q;\r\n    root = new node();\r\n    while (q--){\r\n        int t; cin >> t;\r\n        if (t == 1){\r\n            int a, b, c; cin >> a >> b >> c;\r\n            root->update(1, n, a, b, c);\r\n        } else {\r\n            int a, b; cin >> a >> b;\r\n            cout << root->query(1, n, a, b) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "600Mihnea",
        "id": 190214,
        "date": "2022-12-11 17:12:40",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nint n;\r\n\r\nstruct V\r\n{\r\n  ll s;\r\n  ll lazy;\r\n  int lft;\r\n  int rgh;\r\n\r\n  V()\r\n  {\r\n    s = lazy = lft = rgh = 0;\r\n  }\r\n};\r\n\r\nvector<V> v = {{}};\r\n\r\nint get_new() /// very dangerous!!!!!!!!!!!!!!!!!!!!!!!!\r\n{\r\n  v.push_back({});\r\n  return (int) v.size() - 1;\r\n}\r\n\r\nvoid push(int i, int tl, int tr);\r\n\r\nbool has_kids(int i)\r\n{\r\n  assert(!!v[i].lft == !!v[i].rgh);\r\n  return !!v[i].lft;\r\n}\r\n\r\nvoid make_kids(int i, int tl, int tr)\r\n{\r\n  assert(!has_kids(i));\r\n  assert(tl < tr);\r\n  int x = get_new();\r\n  v[i].lft = x;\r\n  x = get_new();\r\n  v[i].rgh = x;\r\n  push(i, tl, tr);\r\n}\r\n\r\nvoid push(int i, int tl, int tr)\r\n{\r\n  if (v[i].lazy)\r\n  {\r\n    if (tl == tr)\r\n    {\r\n      v[i].s += v[i].lazy * (tr - tl + 1);\r\n\r\n      v[i].lazy = 0;\r\n\r\n      return;\r\n    }\r\n    if (has_kids(i))\r\n    {\r\n      v[v[i].lft].lazy += v[i].lazy;\r\n      v[v[i].rgh].lazy += v[i].lazy;\r\n      v[i].s += v[i].lazy * (tr - tl + 1);\r\n      v[i].lazy = 0;\r\n      return;\r\n    }\r\n    /// can wait\r\n  }\r\n}\r\n\r\nvoid add(int i, int tl, int tr, int l, int r, int x)\r\n{\r\n  push(i, tl, tr);\r\n  if (tr < l || r < tl)\r\n  {\r\n    return;\r\n  }\r\n  if (l <= tl && tr <= r)\r\n  {\r\n    v[i].lazy += x;\r\n    push(i, tl, tr);\r\n    return;\r\n  }\r\n  int tm = (tl + tr) / 2;\r\n  if (!has_kids(i))\r\n  {\r\n    make_kids(i, tl, tr);\r\n  }\r\n  add(v[i].lft, tl, tm, l, r, x);\r\n  add(v[i].rgh, tm + 1, tr, l, r, x);\r\n  v[i].s = v[v[i].lft].s + v[v[i].rgh].s + v[v[i].lft].lazy * (tm - tl + 1) + v[v[i].rgh].lazy * (tr - (tm + 1) + 1);\r\n}\r\n\r\nll get(int i, int tl, int tr, int l, int r)\r\n{\r\n  push(i, tl, tr);\r\n  if (tr < l || r < tl)\r\n  {\r\n    return 0;\r\n  }\r\n  if (l <= tl && tr <= r)\r\n  {\r\n    return v[i].s + v[i].lazy * (tr - tl + 1);\r\n  }\r\n  int tm = (tl + tr) / 2;\r\n  if (!has_kids(i))\r\n  {\r\n    return v[i].lazy * (min(r, tr) - max(l, tl) + 1);\r\n  }\r\n  return get(v[i].lft, tl, tm, l, r) + get(v[i].rgh, tm + 1, tr, l, r);\r\n}\r\n\r\nint main()\r\n{\r\n#ifdef ONPC\r\n  freopen (\"input.txt\", \"r\", stdin);\r\n#endif // ONPC\r\n#ifndef ONPC\r\n  ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#endif // ONPC\r\n\r\n  int n, q;\r\n  cin >> n >> q;\r\n  for (int iq = 1; iq <= q; iq++)\r\n  {\r\n    int tp;\r\n    cin >> tp;\r\n    assert(tp == 1 || tp == 2);\r\n    if (tp == 1)\r\n    {\r\n      int l, r, x;\r\n      cin >> l >> r >> x;\r\n      assert(1 <= l && l <= r && r <= n);\r\n      add(0, 1, n, l, r, x);\r\n      continue;\r\n    }\r\n    assert(tp == 2);\r\n    int l, r;\r\n    cin >> l >> r;\r\n    assert(1 <= l && l <= r && r <= n);\r\n    cout << get(0, 1, n, l, r) << \"\\n\";\r\n  }\r\n\r\n}\r\n"
    },
    {
        "username": "600Mihnea",
        "id": 190212,
        "date": "2022-12-11 17:12:00",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nint n;\r\n\r\nstruct V\r\n{\r\n  ll s;\r\n  ll lazy;\r\n  int lft;\r\n  int rgh;\r\n\r\n  V()\r\n  {\r\n    s = lazy = lft = rgh = 0;\r\n  }\r\n};\r\n\r\nvector<V> v = {{}};\r\n\r\nint get_new() /// very dangerous!!!!!!!!!!!!!!!!!!!!!!!!\r\n{\r\n  v.push_back({});\r\n  return (int) v.size() - 1;\r\n}\r\n\r\nvoid push(int i, int tl, int tr);\r\n\r\nbool has_kids(int i)\r\n{\r\n  assert(!!v[i].lft == !!v[i].rgh);\r\n  return !!v[i].lft;\r\n}\r\n\r\nvoid make_kids(int i, int tl, int tr)\r\n{\r\n  assert(!has_kids(i));\r\n  assert(tl < tr);\r\n  int x = get_new();\r\n  v[i].lft = x;\r\n  x = get_new();\r\n  v[i].rgh = x;\r\n  push(i, tl, tr);\r\n}\r\n\r\nvoid push(int i, int tl, int tr)\r\n{\r\n  if (v[i].lazy)\r\n  {\r\n    if (tl == tr)\r\n    {\r\n      v[i].s += v[i].lazy * (tr - tl + 1);\r\n\r\n      v[i].lazy = 0;\r\n\r\n      return;\r\n    }\r\n    if (has_kids(i))\r\n    {\r\n      v[v[i].lft].lazy += v[i].lazy;\r\n      v[v[i].rgh].lazy += v[i].lazy;\r\n      v[i].s += v[i].lazy * (tr - tl + 1);\r\n      v[i].lazy = 0;\r\n      return;\r\n    }\r\n    /// can wait\r\n  }\r\n}\r\n\r\nvoid add(int i, int tl, int tr, int l, int r, int x)\r\n{\r\n  push(i, tl, tr);\r\n  if (tr < l || r < tl)\r\n  {\r\n    return;\r\n  }\r\n  if (l <= tl && tr <= r)\r\n  {\r\n    v[i].lazy += x;\r\n    push(i, tl, tr);\r\n    return;\r\n  }\r\n  int tm = (tl + tr) / 2;\r\n  if (!has_kids(i))\r\n  {\r\n    make_kids(i, tl, tr);\r\n  }\r\n  add(v[i].lft, tl, tm, l, r, x);\r\n  add(v[i].rgh, tm + 1, tr, l, r, x);\r\n  v[i].s = v[v[i].lft].s + v[v[i].rgh].s + v[v[i].lft].lazy * (tm - tl + 1) + v[v[i].rgh].lazy * (tr - (tm + 1) + 1);\r\n}\r\n\r\nll get(int i, int tl, int tr, int l, int r)\r\n{\r\n  push(i, tl, tr);\r\n  if (tr < l || r < tl)\r\n  {\r\n    return 0;\r\n  }\r\n  if (l <= tl && tr <= r)\r\n  {\r\n   // cout << \"aici\\n\";\r\n    return v[i].s + v[i].lazy * (tr - tl + 1);\r\n  }\r\n  int tm = (tl + tr) / 2;\r\n  if (!has_kids(i))\r\n  {\r\n    make_kids(i, tl, tr);\r\n  }\r\n  return get(v[i].lft, tl, tm, l, r) + get(v[i].rgh, tm + 1, tr, l, r);\r\n}\r\n\r\nint main()\r\n{\r\n#ifdef ONPC\r\n  freopen (\"input.txt\", \"r\", stdin);\r\n#endif // ONPC\r\n#ifndef ONPC\r\n  ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#endif // ONPC\r\n\r\n  int n, q;\r\n  cin >> n >> q;\r\n  for (int iq = 1; iq <= q; iq++)\r\n  {\r\n    int tp;\r\n    cin >> tp;\r\n    assert(tp == 1 || tp == 2);\r\n    if (tp == 1)\r\n    {\r\n      int l, r, x;\r\n      cin >> l >> r >> x;\r\n      assert(1 <= l && l <= r && r <= n);\r\n      add(0, 1, n, l, r, x);\r\n      continue;\r\n    }\r\n    assert(tp == 2);\r\n    int l, r;\r\n    cin >> l >> r;\r\n    assert(1 <= l && l <= r && r <= n);\r\n    cout << get(0, 1, n, l, r) << \"\\n\";\r\n  }\r\n\r\n}\r\n"
    },
    {
        "username": "huanrongnush",
        "id": 189580,
        "date": "2022-12-10 15:45:15",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\n\r\nstruct node{\r\n    int s, e, m;\r\n    int val;\r\n    int lazy;\r\n    \r\n    node *l, *r;\r\n\r\n    node (int S, int E){\r\n        s = S, e = E, m = (s + e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n\r\n\tvoid propogate(){\r\n\t\tif (lazy == 0) return;\r\n\t\tval += lazy*(e-s + 1);\r\n\t\tif (s != e){\r\n\t\t\tif (l == nullptr || r == nullptr) create();\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\t\r\n\tvoid create(){\r\n\t\tif (s != e){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m + 1, e);\r\n\t\t}\r\n\t}\r\n\t\r\n    void update(int S, int E, int V){\r\n\t\tif (l == nullptr || r == nullptr) create();\r\n        if (s == S && e == E) lazy += V;\r\n        else{\r\n            if (E <= m) l->update(S, E, V);\r\n            else if (m < S)r->update(S, E, V);\r\n            else l->update(S, m, V),r->update(m + 1, E, V);\r\n\t\t\t\r\n\t\t\tl->propogate(),r->propogate();\r\n            val = l->val + r->val;\r\n        }\r\n    }\r\n\r\n    int query(int S, int E){\r\n\t\tpropogate();\r\n\t\tif (l == nullptr || r == nullptr) create();\r\n\t\t\r\n\t\t\r\n        if (s == S && e == E) return val;\r\n        else if (E <= m) return l->query(S,E);\r\n        else if (S >= m + 1) return r-> query(S, E);\r\n        else return l->query(S, m) + r->query(m + 1, E);\r\n    }\r\n\r\n} *root;\r\n\r\nsigned main(){\r\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\tint n, q, inp1, inp2, inp3, inp4; cin >> n >> q;\r\n\troot = new node(1, n + 5);\r\n\t\r\n\tfor (int i = 0; i < q; i++){\r\n\t\tcin >> inp1;\r\n\t\tif (inp1 == 1){\r\n\t\t\tcin >> inp2 >> inp3 >> inp4;\r\n\t\t\troot->update(inp2, inp3, inp4);\r\n\t\t} else {\r\n\t\t\tcin >> inp2 >> inp3;\r\n\t\t\tcout << root->query(inp2, inp3) << '\\n';\r\n\t\t}\t\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\t\r\n}\r\n\r\n"
    },
    {
        "username": "yhkhoo",
        "id": 189575,
        "date": "2022-12-10 15:43:41",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\nstruct node{\r\n\tint s, e, m;\r\n\tint val;\r\n\tint lazy;\r\n\tnode *l, *r;\r\n\t\r\n\tnode(int S, int E){\r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t\tval = 0, lazy = 0;\r\n\t}\r\n\t\r\n\tvoid mitosis(){\r\n\t\tif(s!=e){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid prop(){\r\n\t\tif(lazy==0) return;\r\n\t\t\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tif(l==nullptr) mitosis();\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\t\r\n\tvoid update(int S, int E, int V){\r\n\t\tif(l == nullptr) mitosis();\r\n\t\tif(s==S && e==E) lazy += V;\r\n\t\telse{\r\n\t\t\tif(E <= m) l->update(S, E, V);\r\n\t\t\telse if(m < S) r->update(S, E, V);\r\n\t\t\telse l->update(S, m, V), r->update(m+1, E, V);\r\n\t\t\t\r\n\t\t\tl->prop(), r->prop();\r\n\t\t\t\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\t\r\n\tint query(int S, int E){\r\n\t\tif(l == nullptr) mitosis();\r\n\t\tprop();\r\n\t\tif(s==S && e==E) return val;\r\n\t\telse if(E<=m) return l->query(S, E);\r\n\t\telse if(S>m) return r->query(S, E);\r\n\t\telse return l->query(S, m) + r->query(m+1, E);\r\n\t}\r\n} *root;\r\n\r\nsigned main(){\r\n\tcin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\r\n\tint n, q;\r\n\tcin >> n >> q;\r\n\troot = new node(1, n);\r\n\twhile(q--){\r\n\t\tshort t;\r\n\t\tcin >> t;\r\n\t\tif(t==1){\r\n\t\t\tint l, r, k;\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\troot->update(l, r, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n"
    },
    {
        "username": "InfinityIntegral",
        "id": 189493,
        "date": "2022-12-10 14:45:50",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\n// getchar fast io\r\ninline int readInt() {\r\n\tint x = 0;\r\n\tchar ch = getchar();\r\n\twhile (ch < '0' || ch > '9') ch = getchar_unlocked();\r\n\twhile (ch >= '0' && ch <= '9'){\r\n\t\tx = (x << 3) + (x << 1) + ch - '0';\r\n\t\tch = getchar_unlocked();\r\n\t}\r\n\treturn x;\r\n}\r\n\r\n// segment tree\r\nstruct node {\r\n\tint n;\r\n\tint l;\r\n\tint r;\r\n\tint m;\r\n\tint prop;\r\n\tnode *lnode=nullptr, *rnode=nullptr;\r\n\t\r\n\tnode(int x, int y) {\r\n\t\tn = 0;\r\n\t\tl = x;\r\n\t\tr = y;\r\n\t\tm = (x+y)/2;\r\n\t\tprop = 0;\r\n\t\t\r\n\t\t/*\r\n\t\t// normal creation\r\n\t\tif (l != r){\r\n\t\t\tlnode = new node(l, m);\r\n\t\t\trnode = new node(m+1, r);\r\n\t\t}\r\n\t\t*/\r\n\t}\r\n\t\r\n\t\r\n\t// lazy node\r\n\tvoid create (){\r\n\t\tif (l != r){\r\n\t\t\tlnode = new node(l,m);\r\n\t\t\trnode = new node(m+1,r);\r\n\t\t}\r\n\t}\r\n\t\r\n\t\t\r\n\t// lazy prop function\r\n\tvoid lazyprop() {\r\n\t\tif (lnode == nullptr){create();}\r\n\t\tif (prop != 0){\r\n\t\t\tn += prop*(r-l+1);\r\n\t\t\tif (l != r){\r\n\t\t\t\tlnode->prop += prop;\r\n\t\t\t\trnode->prop += prop;\r\n\t\t\t}\r\n\t\t\tprop = 0;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/*\r\n\t// point update\r\n\tvoid pupdate (int nupd, int kupd){\r\n\t\tif (l == r){\r\n\t\t\tn = kupd;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (nupd <= m){\r\n\t\t\t\tlnode -> pupdate(nupd, kupd);\r\n\t\t\t}\r\n\t\t\telse if (nupd > m){\r\n\t\t\t\trnode -> pupdate(nupd, kupd);\r\n\t\t\t}\r\n\t\t\tn = (lnode->n) + (rnode->n);\r\n\t\t}\r\n\t}\r\n\t*/\r\n\t\r\n\t// range update\r\n\tvoid rupdate (int lupd, int rupd, int kupd){\r\n\t\t// only for lazy node\r\n\t\tif (lnode == nullptr){create();}\r\n\t\t\r\n\t\t// only for lazy prop\r\n\t\tlazyprop();\r\n\t\t\r\n\t\tif (lupd == l && rupd ==r){\r\n\t\t\tprop += kupd;\r\n\t\t}\r\n\t\telse if (rupd <= m){\r\n\t\t\tlnode->rupdate(lupd, rupd, kupd);\r\n\t\t}\r\n\t\telse if (lupd > m){\r\n\t\t\trnode->rupdate(lupd, rupd, kupd);\r\n\t\t}\r\n\t\telse  {\r\n\t\t\tlnode->rupdate(lupd, m, kupd);\r\n\t\t\trnode->rupdate(m+1, rupd, kupd);\r\n\t\t}\r\n\t\t\r\n\t\tif (l != r){\r\n\t\t\tlnode->lazyprop();\r\n\t\t\trnode->lazyprop();\r\n\t\t\tn = lnode->n + rnode->n;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t// query\r\n\tint query(int lbound, int rbound){\r\n\t\t// only for lazy node\r\n\t\tif (lnode == nullptr){create();}\r\n\t\t\r\n\t\t// only for lazy prop\r\n\t\tlazyprop();\r\n\t\t\r\n\t\tif (lbound==l && rbound==r){\r\n\t\t\treturn n;\r\n\t\t}\r\n\t\telse if (rbound <= m){\r\n\t\t\treturn lnode -> query(lbound,rbound);\r\n\t\t}\r\n\t\telse if (lbound > m){\r\n\t\t\treturn rnode -> query(lbound,rbound);\r\n\t\t}\r\n\t\telse  {\r\n\t\t\treturn (lnode->query(lbound,m)) + (rnode->query(m+1,rbound));\r\n\t\t}\r\n\t}\r\n};\r\n\r\nint n;\r\nint q;\r\nint w;\r\nint l;\r\nint r;\r\nint k;\r\n\r\nsigned main() {\r\n\tcin >> n;\r\n\tcin >> q;\r\n\tnode simo(1,n);\r\n\t\r\n\tfor (int i=0; i<q; i++){\r\n\t\tw = readInt();\r\n\t\tif (w == 1){\r\n\t\t\tcin >> l;\r\n\t\t\tcin >> r;\r\n\t\t\tcin >> k;\r\n\t\t\tsimo.rupdate(l,r,k);\r\n\t\t}\r\n\t\telse if (w == 2){\r\n\t\t\tcin >> l;\r\n\t\t\tcin >> r;\r\n\t\t\tcout << simo.query(l,r) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "PoTheSloth",
        "id": 189444,
        "date": "2022-12-10 13:58:12",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node\r\n{\r\n    int s, e, mid, val, lazy;\r\n    node *l=nullptr, *r=nullptr;\r\n    node(int S, int E){\r\n        s = S; e = E; mid = (s + e)/2; val = 0; lazy=0;\r\n    }\r\n    void propagate(){\r\n\t\tif(s!=e){\r\n\t\t\tif(l==nullptr)l = new node(s, mid);\r\n\t\t\tif(r==nullptr)r = new node(mid + 1, e);\r\n\t\t}\r\n        if(lazy==0){return;}\r\n        val+=lazy*(e-s+1);\r\n        if(s!=e){\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0;\r\n    }\r\n    void update(int S, int E, int V){\r\n\t\tif(s!=e){\r\n\t\t\tif(l==nullptr)l = new node(s, mid);\r\n\t\t\tif(r==nullptr)r = new node(mid + 1, e);\r\n\t\t}\r\n\t\tpropagate();lazy=0;\r\n\t\tif(s!=e){l->propagate();r->propagate();}\r\n        if(s==S and e==E){lazy+=V;return;}\r\n        else if(E<=mid){propagate(); l->update(S, E, V);}\r\n        else if(S>mid){propagate(); r->update(S, E, V);}\r\n        else{\r\n\t\t\tpropagate();\r\n            l->update(S, mid, V);\r\n            r->update(mid+1, E, V);\r\n        }\r\n        propagate();\r\n        if(s!=e){l->propagate();r->propagate();}\r\n        val = l->val+r->val;\r\n    }\r\n    int query(int S, int E){\r\n\t\tif(s!=e){\r\n\t\t\tif(l==nullptr)l = new node(s, mid);\r\n\t\t\tif(r==nullptr)r = new node(mid + 1, e);\r\n\t\t}\r\n\t\tpropagate();lazy=0;\r\n\t\tif(s!=e){l->propagate();r->propagate();}\r\n        if(s == S and e == E){return val;}\r\n        else if(E <= mid){propagate(); return l->query(S, E);}\r\n\t\telse if(S>mid){propagate(); return r->query(S, E);}\r\n\t\telse{propagate(); return (l->query(S, mid) + r->query(mid+1, E));}\r\n\t\tval = l->val+r->val;\r\n    }\r\n    void initialise(int index, int V){\r\n        if(s==e){val=V;return;}\r\n        if(index<=mid)l->initialise(index, V);\r\n        if(index>mid)r->initialise(index, V);\r\n        //l->propagate();r->propagate();\r\n        val = l->val+r->val;\r\n    }\r\n}*segtree;\r\nint n, q;\r\nint32_t main(){\r\n    ios_base::sync_with_stdio(false); cin.tie(0);cout.tie(0);\r\n    cin>>n>>q;\r\n    segtree = new node(0, n);\r\n    for(int i=0; i<q; ++i){\r\n        short type;\r\n        cin>>type;\r\n        if(type==1){\r\n            int s, e, v;\r\n            cin>>s>>e>>v;\r\n\t\t\tsegtree->update(s, e, v);\r\n        }\r\n        if(type==2){\r\n            int s, e;\r\n            cin>>s>>e;\r\n            cout<<segtree->query(s, e)<<'\\n';\r\n        }\r\n    }\r\n    //~ segtree = new node(0, 5); //DEBUG\r\n    //~ segtree->update(1, 3, -2);//DEBUG\r\n    //~ cout<<segtree->query(1, 1)<<' '<<segtree->query(2, 2)<<' '<<segtree->query(3, 3);//DEBUG\r\n}\r\n"
    },
    {
        "username": "Xiaoyang",
        "id": 189365,
        "date": "2022-12-10 12:28:21",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define fi first\r\n#define se second\r\n#define pii pair<long long,long long>\r\n#define pb push_back\r\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\r\n#define inf 0x3f3f3f3f\r\n#define rep(i,a,b) for (ll i=a;i<(b);i++)\r\n#define MP make_pair\r\n#define SZ(x) (ll(x.size()))\r\n#define ll long long\r\n#define mod 1000000007\r\n#define ALL(x) x.begin(),x.end()\r\n#define endl \"\\n\"\r\nvoid inc(ll &a,ll b) {a=(a+b)%mod;}\r\nvoid dec(ll &a,ll b) {a=(a-b+mod)%mod;}\r\nll lowbit(ll x) {return x&(-x);}\r\nll expo(ll base,ll p) {ll ret=1;while(p>0){if (p%2ll==1ll) ret=ret*base%mod;base=base*base%mod;p/=2ll;}return ret;}\r\n\r\nconst ll maxn=5e6+5;\r\nll lc[maxn],rc[maxn],tree[maxn],add[maxn];\r\nll tot=1,rt=1;\r\nvoid fill(ll c,ll cl,ll cr,ll val){\r\n\ttree[c]+=val*(cr-cl+1);\r\n\tadd[c]+=val;\r\n}\r\nvoid pushdown(ll c,ll cl, ll cr){\r\n\tif(lc[c]==-1)lc[c]=++tot;\r\n\tif(rc[c]==-1)rc[c]=++tot;\r\n\tll mid=cl+cr>>1;\r\n\tfill(lc[c],cl,mid,add[c]);\r\n\tfill(rc[c],mid+1,cr,add[c]);\r\n\tadd[c]=0;\r\n}\r\nvoid update(ll &c,ll cl, ll cr, ll l, ll r, ll val){\r\n\tif(c==-1)c=++tot;\r\n\tif(l<=cl and cr<=r){\r\n\t\tfill(c,cl,cr,val);\r\n\t\treturn;\r\n\t}\r\n\tpushdown(c,cl,cr);\r\n\tll mid=cl+cr>>1;\r\n\tif(l<=mid)update(lc[c],cl,mid,l,r,val);\r\n\tif(r>mid)update(rc[c],mid+1,cr,l,r,val);\r\n\ttree[c]=tree[lc[c]]+tree[rc[c]];\r\n\treturn;\r\n}\r\nll query(ll c,ll cl, ll cr, ll l, ll r){\r\n\tif(c==-1)return 0;\r\n\tif(l<=cl and cr<=r)return tree[c];\r\n\tpushdown(c,cl,cr);\r\n\tll mid=cl+cr>>1;\r\n\tll ans=0;\r\n\tif(l<=mid)ans+=query(lc[c],cl,mid,l,r);\r\n\tif(r>mid)ans+=query(rc[c],mid+1,cr,l,r);\r\n\treturn ans;\r\n}\r\nint main(){\r\n    ios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tmemset(lc,-1,sizeof lc);\r\n\tmemset(rc,-1,sizeof rc);\r\n\tll n,q;cin>>n>>q;\r\n\twhile(q--){\r\n\t\tll op;cin>>op;\r\n\t\tif(op==1){\r\n\t\t\tll l,r,k;cin>>l>>r>>k;\r\n\t\t\tupdate(rt,1,n,l,r,k);\r\n\t\t}else{\r\n\t\t\tll l,r;cin>>l>>r;\r\n\t\t\tcout<<query(1,1,n,l,r)<<endl;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n/*5 5\r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5*/\r\n"
    },
    {
        "username": "AlphanumericUsername",
        "id": 189202,
        "date": "2022-12-10 11:34:43",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nint sum = 0;\r\ntypedef long long ll;\r\nstruct node {\r\n  int s, e;\r\n  ll mn, mx, sum;\r\n  bool lset;\r\n  ll add_val, set_val;\r\n  node *l, *r;\r\n  node(int _s, int _e, int A[] = NULL)\r\n      : s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0),\r\n        l(NULL), r(NULL) {\r\n    if (A == NULL)\r\n      return;\r\n    if (s == e)\r\n      mn = mx = sum = A[s];\r\n    else {\r\n      l = new node(s, (s + e) >> 1, A), r = new node((s + e + 2) >> 1, e, A);\r\n      combine();\r\n    }\r\n  }\r\n  void create_children() {\r\n    if (s == e)\r\n      return;\r\n    if (l != NULL)\r\n      return;\r\n    int m = (s + e) >> 1;\r\n    l = new node(s, m);\r\n    r = new node(m + 1, e);\r\n  }\r\n  void self_set(ll v) {\r\n    lset = 1;\r\n    mn = mx = set_val = v;\r\n    sum = v * (e - s + 1);\r\n    add_val = 0;\r\n  }\r\n  void self_add(ll v) {\r\n    if (lset) {\r\n      self_set(v + set_val);\r\n      return;\r\n    }\r\n    mn += v, mx += v, add_val += v;\r\n    sum += v * (e - s + 1);\r\n  }\r\n  void lazy_propagate() {\r\n    if (s == e)\r\n      return;\r\n    if (lset) {\r\n      l->self_set(set_val), r->self_set(set_val);\r\n      lset = set_val = 0;\r\n    }\r\n    if (add_val != 0) {\r\n      l->self_add(add_val), r->self_add(add_val);\r\n      add_val = 0;\r\n    }\r\n  }\r\n  void combine() {\r\n    if (l == NULL)\r\n      return;\r\n    sum = l->sum + r->sum;\r\n    mn = min(l->mn, r->mn);\r\n    mx = max(l->mx, r->mx);\r\n  }\r\n  void add(int x, int y, ll v) {\r\n    if (s == x && e == y) {\r\n      self_add(v);\r\n      return;\r\n    }\r\n    int m = (s + e) >> 1;\r\n    create_children();\r\n    lazy_propagate();\r\n    if (x <= m)\r\n      l->add(x, min(y, m), v);\r\n    if (y > m)\r\n      r->add(max(x, m + 1), y, v);\r\n    combine();\r\n  }\r\n  void set(int x, int y, ll v) {\r\n    if (s == x && e == y) {\r\n      self_set(v);\r\n      return;\r\n    }\r\n    int m = (s + e) >> 1;\r\n    create_children();\r\n    lazy_propagate();\r\n    if (x <= m)\r\n      l->set(x, min(y, m), v);\r\n    if (y > m)\r\n      r->set(max(x, m + 1), y, v);\r\n    combine();\r\n  }\r\n  ll range_sum(int x, int y) {\r\n    if (s == x && e == y)\r\n      return sum;\r\n    if (l == NULL || lset)\r\n      return (sum / (e - s + 1)) * (y - x + 1);\r\n    int m = (s + e) >> 1;\r\n    lazy_propagate();\r\n    if (y <= m)\r\n      return l->range_sum(x, y);\r\n    if (x > m)\r\n      return r->range_sum(x, y);\r\n    return l->range_sum(x, m) + r->range_sum(m + 1, y);\r\n  }\r\n  ll range_min(int x, int y) {\r\n    if (s == x && e == y)\r\n      return mn;\r\n    if (l == NULL || lset)\r\n      return mn;\r\n    int m = (s + e) >> 1;\r\n    lazy_propagate();\r\n    if (y <= m)\r\n      return l->range_min(x, y);\r\n    if (x > m)\r\n      return r->range_min(x, y);\r\n    return min(l->range_min(x, m), r->range_min(m + 1, y));\r\n  }\r\n  ll range_max(int x, int y) {\r\n    if (s == x && e == y)\r\n      return mx;\r\n    if (l == NULL || lset)\r\n      return mx;\r\n    int m = (s + e) >> 1;\r\n    lazy_propagate();\r\n    if (y <= m)\r\n      return l->range_max(x, y);\r\n    if (x > m)\r\n      return r->range_max(x, y);\r\n    return max(l->range_max(x, m), r->range_max(m + 1, y));\r\n  }\r\n  ~node() {\r\n    if (l != NULL)\r\n      delete l;\r\n    if (r != NULL)\r\n      delete r;\r\n  }\r\n} * root;\r\nint32_t main() {\r\n  ios::sync_with_stdio(0);\r\n  cin.tie(NULL);\r\n  cout.tie(NULL);\r\n  int n, q;\r\n  cin >> n >> q;\r\n  root = new node(0, 10000000000);\r\n  int a, b, c;\r\n  for (int i = 0; i < q; ++i) {\r\n    cin >> a >> b >> c;\r\n    if (a == 1) {\r\n      int d;\r\n      cin >> d;\r\n      root->add(b, c, d);\r\n    } else {\r\n      sum = 0;\r\n      root->range_sum(b, c);\r\n      cout << root->range_sum(b,c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "awesomeyy22",
        "id": 188984,
        "date": "2022-12-10 10:02:31",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n\tll s, e, m;\r\n\tll val, prop;\r\n\tnode *l, *r;\r\n\tnode(ll S, ll E){\r\n\t\ts = S, e = E, m = floor((S + E)/2);\r\n\t\tval = 0, prop = 0;\r\n\t\tif(s != e){\r\n\t\t\tl = r = NULL;\r\n\t\t}\r\n\t}\r\n\tvoid create(){\r\n\t\tl = new node(s, m);\r\n\t\tr = new node(m + 1, e);\r\n\t}\r\n\tll propogate(){\r\n\t\tif(s == e){\r\n\t\t\tval += prop;\r\n\t\t\tprop = 0;\r\n\t\t\treturn val;\r\n\t\t}\r\n\t\tval += (e - s + 1) * prop;\r\n\t\tif(l == NULL) create();\r\n\t\tr->prop += prop;\r\n\t\tl->prop += prop;\r\n\t\tprop = 0;\r\n\t\treturn val;\r\n\t}\r\n\tvoid update(ll x, ll y, ll k){\r\n\t\tif(x == s && e == y){\r\n\t\t\tprop += k;\r\n\t\t}else{\r\n\t\t\tif(l == NULL) create();\r\n\t\t\tif(x > m) r->update(x, y, k);\r\n\t\t\telse if(y <= m) l->update(x, y, k);\r\n\t\t\telse{\r\n\t\t\t\tl->update(x, m, k);\r\n\t\t\t\tr->update(m + 1, y, k);\r\n\t\t\t}\r\n\t\t\tval = l->propogate() + r->propogate();\r\n\t\t}\r\n\t}\r\n\tll query(ll S, ll E){\r\n\t\tpropogate();\r\n\t\tif(S == s && E == e) return val;\r\n\t\tif(l == NULL) create();\r\n\t\tif(S > m) return r->query(S, E);\r\n\t\t\telse if(E <= m) return l->query(S, E);\r\n\t\t\telse{\r\n\t\t\t\treturn l->query(S, m) + r->query(m + 1, E);\r\n\t\t\t}\r\n\t}\r\n\t\r\n}*root;\r\n\r\nint main(){\r\n\tios::sync_with_stdio(0), cin.tie(0);\r\n\tll n, q;\r\n\tcin >> n >> q;\r\n\troot = new node(0, n-1);\r\n\tfor(ll i = 0; i < q; i++){\r\n\t\tll op;\r\n\t\tcin >> op;\r\n\t\tif(op == 1){\r\n\t\t\tll L, R, K;\r\n\t\t\tcin >> L >> R >> K;\r\n\t\t\troot->update(L-1, R-1, K);\r\n\t\t}else{\r\n\t\t\tll L, R;\r\n\t\t\tcin >> L >> R;\r\n\t\t\tcout << root->query(L-1, R-1) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "RandomPerson",
        "id": 188925,
        "date": "2022-12-10 09:40:44",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define FOR(a,b,c)for(int a=b;a<c;a++)\r\n#define mp make_pair\r\n#define pb push_back\r\n#define pii pair<int,int>\r\n\r\nstruct ST {\r\n    int s,m,e;\r\n    int v,lazy;\r\n    struct ST *l, *r;\r\n\r\n    ST(int _s, int _e)\r\n    {\r\n        s=_s;e=_e;m=s+e>>1;\r\n        v=0;\r\n        lazy=0;\r\n        l=r=NULL;\r\n    }\r\n\r\n    int force()\r\n    {\r\n        if(s!=e)if(!l)l=new ST(s,m),r=new ST(m+1,e);\r\n        if(!lazy)return v;\r\n        v+=lazy*(e-s+1);\r\n        if(s!=e){\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0;\r\n        return v;\r\n    }\r\n\r\n    void update(int _s, int _e, int x)\r\n    {\r\n        force();\r\n        if(s==_s&&e==_e) lazy+=x;\r\n        else if (_e <= m) l->update(_s,_e,x);\r\n        else if (_s > m) r->update(_s,_e,x);\r\n        else {\r\n            l->update(_s,m,x);\r\n            r->update(m+1,_e,x);\r\n        }\r\n        if(s!=e)v=l->force() + r->force();\r\n    }\r\n\r\n    int query(int _s, int _e)\r\n    {\r\n        force();\r\n        if(s==e||(s==_s&&e==_e)) return v;\r\n        else if (_e <= m) return l->query(_s,_e);\r\n        else if (_s > m) return r->query(_s,_e);\r\n        else {\r\n            return l->query(_s,m)+r->query(m+1,_e);\r\n        }\r\n    }\r\n};\r\n\r\nint N,Q;\r\nsigned main(void)\r\n{\r\n    ios_base::sync_with_stdio(0);cin.tie(0);\r\n    cin>>N>>Q;\r\n    struct ST *st = new ST(1,1e9+5);\r\n    FOR(i,0,Q){\r\n        int t;cin>>t;\r\n        if(t==1){int l,r,k;cin>>l>>r>>k;st->update(l,r,k);}\r\n        else {int l,r;cin>>l>>r;cout<<st->query(l,r)<<'\\n';}\r\n    }\r\n}"
    },
    {
        "username": "kxd",
        "id": 188895,
        "date": "2022-12-10 09:26:28",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define ll long long\r\n#define pb push_back\r\n#define p_q priority_queue\r\n#define m_p make_pair\r\n#define pii pair<int,int>\r\n#define endl '\\n'\r\n#define INIT ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define FOR(i, a, b) for(int i = a; i < b; i++)\r\n#define forn(i, n) for (int i = 0; i < n; i++)\r\n#define f first\r\n#define s second\r\n\r\nusing namespace std;\r\nconst int N = 5e6+5;\r\nconst int INF = 1e18;\r\n\r\nstruct node {\r\n    int s, e, m, v;\r\n    int lazy; //lazy value storage\r\n    node *l, *r;\r\n    node(int _s, int _e) {\r\n        s = _s;\r\n        e = _e;\r\n        v = lazy = 0;\r\n        if (s == e) return;\r\n        m = (s + e) / 2;\r\n        //Do not create the children here\r\n    }\r\n    void propo() { \r\n        //Create before propo\r\n        if (s != e && l == nullptr) {\r\n        \tl = new node(s, m);\r\n        \tr = new node(m+1, e);\r\n\t\t}\r\n        if (lazy != 0) {\r\n            //Update value base on range\r\n            v += lazy * (e - s + 1);\r\n            //Propogate\r\n            if (s != e){\r\n                r -> lazy += lazy;\r\n                l -> lazy += lazy;\r\n            }\r\n            //Reset value\r\n            lazy = 0;\r\n        }\r\n    }\r\n    void up(int x, int y, int c) {\r\n        //Propo before update\r\n        if (s >= x && e <= y) {\r\n            lazy += c;\r\n            return;\r\n        }\r\n        else {\r\n        \tpropo();\r\n            if (y <= m) l -> up(x, y, c);\r\n            else if (x > m) r -> up(x, y, c);\r\n            else {\r\n\t\t\t\tl -> up(x, y, c);\r\n\t\t\t\tr -> up(x, y, c);\r\n\t\t\t}\r\n            //Reminder to propo before updating cur node value\r\n            l -> propo(); r -> propo();\r\n            v = l -> v + r -> v;\r\n        }\r\n    }\r\n    int query(int x, int y) {\r\n        //Propo before processing query\r\n        propo();\r\n        if (s >= x && e <= y) return v;\r\n        if (x > m) return r -> query(x, y);\r\n        if (y <= m) return l -> query(x, y);\r\n        else return l -> query(x, y) + r -> query(x, y);\r\n    }\r\n} *root;\r\n\r\nsigned main() {\r\n\tINIT\r\n    int n; cin >> n;\r\n    root = new node(0, n);\r\n    int q; cin >> q;\r\n    int t, l, r, k;\r\n    while(q--) {\r\n        cin >> t;\r\n        if (t == 1) {\r\n            cin >> l >> r >> k;\r\n            root -> up(l, r, k);\r\n        } else {\r\n            cin >> l >> r;\r\n            cout << root -> query(l, r) << endl;\r\n        }\r\n    }\r\n}   "
    },
    {
        "username": "OSoverspike",
        "id": 188871,
        "date": "2022-12-10 09:01:21",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nint n, q;\r\nstruct node {\r\n    int s, e, m, val, lazy;\r\n    node *l, *r;\r\n    node (int _s, int _e) :\r\n        s(_s),e(_e),m((_e+_s)/2),val(0),lazy(0){\r\n            l=nullptr;\r\n            r=nullptr;\r\n        }\r\n    int rangesum(int a, int b) {\r\n        if (l==nullptr)create();\r\n        propogate();\r\n        if (a<=s&&b>=e)return val;\r\n        if (a>=m+1)return (r->rangesum(a, b));\r\n        if (b<=m) return (l->rangesum(a, b));\r\n        return (l->rangesum(a, b))+(r->rangesum(a, b));\r\n    }\r\n    void update(int a, int b, int v) {\r\n        if (l==nullptr)create();\r\n        propogate();\r\n        if (a<=s&&b>=e){lazy+=v; propogate(); return;}\r\n        if (a>=m+1) r->update(a, b, v);\r\n        else if (b<=m) l->update(a, b, v);\r\n        else {\r\n            l->update(a, m, v);\r\n            r->update(m+1, b, v);\r\n        }\r\n\t\tl->propogate();\r\n\t\tr->propogate();\r\n        val=l->val+r->val;\r\n    }\r\n    void propogate() {\r\n        if (l==nullptr)create();\r\n        if (lazy==0) return;\r\n        val+=lazy*(e-s+1);\r\n        if (s!=e) {\r\n            r->lazy+=lazy;\r\n            l->lazy+=lazy;\r\n        }\r\n        lazy=0;\r\n    }\r\n    void create() {\r\n        if (s!=e){\r\n            l=new node(s, m);\r\n            r=new node(m+1, e);\r\n        }\r\n    }\r\n} *root;\r\nsigned main() {\r\n\r\n    std::ios::sync_with_stdio(false);\r\n    //freopen(\"input\", \"r\", stdin);\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n    cin >> n;\r\n    root=new node(0, n);\r\n    int temp;\r\n    cin >> q;\r\n    int temp1, temp2, temp3, temp4;\r\n    for (int a=0; a<q; a++) {\r\n        cin >> temp1;\r\n        if (temp1==2) {\r\n            cin >> temp2;\r\n            cin >> temp3;\r\n            cout << root->rangesum(temp2, temp3) << endl;\r\n        }\r\n        else {\r\n            cin >> temp2;\r\n            cin >> temp3;\r\n            cin >> temp4;\r\n            root->update(temp2, temp3, temp4);\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "chenweilian",
        "id": 188870,
        "date": "2022-12-10 09:00:39",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint n;\r\nunordered_map<long, long> f1, f2;\r\nvoid add(int p, long x) {\r\n    for(int i = p; i <= n; i += i & -i) {\r\n        f1[i] += x; f2[i] += x*p;\r\n    }\r\n}\r\nlong sum(int p) {\r\n    long res = 0;\r\n    for(int i = p; i; i -= i & -i) {\r\n        res += (p+1)*f1[i] - f2[i];\r\n    }\r\n    return res;\r\n}\r\nint main() {\r\n    ios::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n    int comm, q, a = 0, b = 0, c = 0;\r\n    cin>>n>>comm;\r\n    for(int i = 1; i <= comm; i++) {\r\n        cin>>q;\r\n        if(q == 1) {\r\n            cin>>a>>b>>c;\r\n            add(a, c);\r\n            add(b+1, -c);\r\n        }\r\n        else if(q == 2) {\r\n            cin>>a>>b;\r\n            cout<<sum(b)-sum(a-1)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "Xiaoyang",
        "id": 188869,
        "date": "2022-12-10 08:58:15",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define fi first\r\n#define se second\r\n#define pii pair<long long,long long>\r\n#define pb push_back\r\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\r\n#define inf 0x3f3f3f3f\r\n#define rep(i,a,b) for (ll i=a;i<(b);i++)\r\n#define MP make_pair\r\n#define SZ(x) (ll(x.size()))\r\n#define ll long long\r\n#define mod 1000000007\r\n#define ALL(x) x.begin(),x.end()\r\n#define endl \"\\n\"\r\nvoid inc(ll &a,ll b) {a=(a+b)%mod;}\r\nvoid dec(ll &a,ll b) {a=(a-b+mod)%mod;}\r\nll lowbit(ll x) {return x&(-x);}\r\nll expo(ll base,ll p) {ll ret=1;while(p>0){if (p%2ll==1ll) ret=ret*base%mod;base=base*base%mod;p/=2ll;}return ret;}\r\n\r\nconst ll maxn=5e6+5;\r\nll lc[maxn],rc[maxn],tree[maxn],add[maxn];\r\nll tot=1,rt=1;\r\nvoid fill(ll c,ll cl,ll cr,ll val){\r\n\ttree[c]+=val*(cr-cl+1);\r\n\tadd[c]+=val;\r\n}\r\nvoid pushdown(ll c,ll cl, ll cr){\r\n\tif(lc[c]==-1)lc[c]=++tot;\r\n\tif(rc[c]==-1)rc[c]=++tot;\r\n\tll mid=cl+cr>>1;\r\n\tfill(lc[c],cl,mid,add[c]);\r\n\tfill(rc[c],mid+1,cr,add[c]);\r\n\tadd[c]=0;\r\n}\r\nvoid update(ll &c,ll cl, ll cr, ll l, ll r, ll val){\r\n\tif(c==-1)c=++tot;\r\n\tif(l<=cl and cr<=r){\r\n\t\tfill(c,cl,cr,val);\r\n\t\treturn;\r\n\t}\r\n\tpushdown(c,cl,cr);\r\n\tll mid=cl+cr>>1;\r\n\tif(l<=mid)update(lc[c],cl,mid,l,r,val);\r\n\tif(r>mid)update(rc[c],mid+1,cr,l,r,val);\r\n\ttree[c]=tree[lc[c]]+tree[rc[c]];\r\n\treturn;\r\n}\r\nll query(ll c,ll cl, ll cr, ll l, ll r){\r\n\tif(c==-1)return 0;\r\n\tif(l<=cl and cr<=r)return tree[c];\r\n\tpushdown(c,cl,cr);\r\n\tll mid=cl+cr>>1;\r\n\tll ans=0;\r\n\tif(l<=mid)ans+=query(lc[c],cl,mid,l,r);\r\n\tif(r>mid)ans+=query(rc[c],mid+1,cr,l,r);\r\n\treturn ans;\r\n}\r\nint main(){\r\n    ios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tmemset(lc,-1,sizeof lc);\r\n\tmemset(rc,-1,sizeof rc);\r\n\tll n,q;cin>>n>>q;\r\n\twhile(q--){\r\n\t\tll op;cin>>op;\r\n\t\tif(op==1){\r\n\t\t\tll l,r,k;cin>>l>>r>>k;\r\n\t\t\tupdate(rt,1,n,l,r,k);\r\n\t\t}else{\r\n\t\t\tll l,r;cin>>l>>r;\r\n\t\t\tcout<<query(1,1,n,l,r)<<endl;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n/*5 5\r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5*/\r\n"
    },
    {
        "username": "Xiaoyang",
        "id": 188713,
        "date": "2022-12-09 23:08:31",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define fi first\r\n#define se second\r\n#define pii pair<long long,long long>\r\n#define pb push_back\r\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\r\n#define inf 0x3f3f3f3f\r\n#define rep(i,a,b) for (ll i=a;i<(b);i++)\r\n#define MP make_pair\r\n#define SZ(x) (ll(x.size()))\r\n#define ll long long\r\n#define mod 1000000007\r\n#define ALL(x) x.begin(),x.end()\r\n#define endl \"\\n\"\r\nvoid inc(ll &a,ll b) {a=(a+b)%mod;}\r\nvoid dec(ll &a,ll b) {a=(a-b+mod)%mod;}\r\nll lowbit(ll x) {return x&(-x);}\r\nll expo(ll base,ll p) {ll ret=1;while(p>0){if (p%2ll==1ll) ret=ret*base%mod;base=base*base%mod;p/=2ll;}return ret;}\r\n\r\nconst ll maxn=5e6+5;\r\nll lc[maxn],rc[maxn],tree[maxn],add[maxn];\r\nll tot=1,rt=1;\r\nvoid fill(ll c,ll cl,ll cr,ll val){\r\n\ttree[c]+=val*(cr-cl+1);\r\n\tadd[c]+=val;\r\n}\r\nvoid pushdown(ll c,ll cl, ll cr){\r\n\tif(lc[c]==-1)lc[c]=++tot;\r\n\tif(rc[c]==-1)rc[c]=++tot;\r\n\tll mid=cl+cr>>1;\r\n\tfill(lc[c],cl,mid,add[c]);\r\n\tfill(rc[c],mid+1,cr,add[c]);\r\n\tadd[c]=0;\r\n}\r\nvoid update(ll &c,ll cl, ll cr, ll l, ll r, ll val){\r\n\tif(c==-1)c=++tot;\r\n\tif(l<=cl and cr<=r){\r\n\t\tfill(c,cl,cr,val);\r\n\t\treturn;\r\n\t}\r\n\tpushdown(c,cl,cr);\r\n\tll mid=cl+cr>>1;\r\n\tif(l<=mid)update(lc[c],cl,mid,l,r,val);\r\n\tif(r>mid)update(rc[c],mid+1,cr,l,r,val);\r\n\tif(lc[c]==-1)tree[c]=tree[rc[c]];\r\n\telse if(rc[c]==-1)tree[c]=tree[lc[c]];\r\n\telse tree[c]=tree[lc[c]]+tree[rc[c]];\r\n\treturn;\r\n}\r\nll query(ll c,ll cl, ll cr, ll l, ll r){\r\n\tif(c==-1)return 0;\r\n\tif(l<=cl and cr<=r)return tree[c];\r\n\tpushdown(c,cl,cr);\r\n\tll mid=cl+cr>>1;\r\n\tll ans=0;\r\n\tif(l<=mid)ans+=query(lc[c],cl,mid,l,r);\r\n\tif(r>mid)ans+=query(rc[c],mid+1,cr,l,r);\r\n\treturn ans;\r\n}\r\nint main(){\r\n    ios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tmemset(lc,-1,sizeof lc);\r\n\tmemset(rc,-1,sizeof rc);\r\n\tll n,q;cin>>n>>q;\r\n\twhile(q--){\r\n\t\tll op;cin>>op;\r\n\t\tif(op==1){\r\n\t\t\tll l,r,k;cin>>l>>r>>k;\r\n\t\t\tupdate(rt,1,n,l,r,k);\r\n\t\t}else{\r\n\t\t\tll l,r;cin>>l>>r;\r\n\t\t\tcout<<query(1,1,n,l,r)<<endl;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n/*5 5\r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5*/\r\n"
    },
    {
        "username": "Xiaoyang",
        "id": 188712,
        "date": "2022-12-09 23:05:23",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define fi first\r\n#define se second\r\n#define pii pair<long long,long long>\r\n#define pb push_back\r\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\r\n#define inf 0x3f3f3f3f\r\n#define rep(i,a,b) for (ll i=a;i<(b);i++)\r\n#define MP make_pair\r\n#define SZ(x) (ll(x.size()))\r\n#define ll long long\r\n#define mod 1000000007\r\n#define ALL(x) x.begin(),x.end()\r\n#define endl \"\\n\"\r\nvoid inc(ll &a,ll b) {a=(a+b)%mod;}\r\nvoid dec(ll &a,ll b) {a=(a-b+mod)%mod;}\r\nll lowbit(ll x) {return x&(-x);}\r\nll expo(ll base,ll p) {ll ret=1;while(p>0){if (p%2ll==1ll) ret=ret*base%mod;base=base*base%mod;p/=2ll;}return ret;}\r\n\r\nconst ll maxn=5e6+5;\r\nll lc[maxn],rc[maxn],tree[maxn],add[maxn];\r\nll tot=1,rt=1;\r\nvoid fill(ll c,ll cl,ll cr,ll val){\r\n\ttree[c]+=val*(cr-cl+1);\r\n\tadd[c]+=val;\r\n}\r\nvoid pushdown(ll c,ll cl, ll cr){\r\n\tif(lc[c]==-1)lc[c]=++tot;\r\n\tif(rc[c]==-1)rc[c]=++tot;\r\n\tll mid=cl+cr>>1;\r\n\tfill(lc[c],cl,mid,add[c]);\r\n\tfill(rc[c],mid+1,cr,add[c]);\r\n\tadd[c]=0;\r\n}\r\nvoid update(ll &c,ll cl, ll cr, ll l, ll r, ll val){\r\n\tif(c==-1)c=++tot;\r\n\tif(l<=cl and cr<=r){\r\n\t\tfill(c,cl,cr,val);\r\n\t\treturn;\r\n\t}\r\n\tif(add[c]!=0)pushdown(c,cl,cr);\r\n\tll mid=cl+cr>>1;\r\n\tif(l<=mid)update(lc[c],cl,mid,l,r,val);\r\n\tif(r>mid)update(rc[c],mid+1,cr,l,r,val);\r\n\tif(lc[c]==-1)tree[c]=tree[rc[c]];\r\n\telse if(rc[c]==-1)tree[c]=tree[lc[c]];\r\n\telse tree[c]=tree[lc[c]]+tree[rc[c]];\r\n\treturn;\r\n}\r\nll query(ll c,ll cl, ll cr, ll l, ll r){\r\n\tif(c==-1)return 0;\r\n\tif(l<=cl and cr<=r)return tree[c];\r\n\tif(add[c]!=0)pushdown(c,cl,cr);\r\n\tll mid=cl+cr>>1;\r\n\tll ans=0;\r\n\tif(l<=mid)ans+=query(lc[c],cl,mid,l,r);\r\n\tif(r>mid)ans+=query(rc[c],mid+1,cr,l,r);\r\n\treturn ans;\r\n}\r\nint main(){\r\n    ios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tmemset(lc,-1,sizeof lc);\r\n\tmemset(rc,-1,sizeof rc);\r\n\tll n,q;cin>>n>>q;\r\n\twhile(q--){\r\n\t\tll op;cin>>op;\r\n\t\tif(op==1){\r\n\t\t\tll l,r,k;cin>>l>>r>>k;\r\n\t\t\tupdate(rt,1,n,l,r,k);\r\n\t\t}else{\r\n\t\t\tll l,r;cin>>l>>r;\r\n\t\t\tcout<<query(1,1,n,l,r)<<endl;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n/*5 5\r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5*/\r\n"
    },
    {
        "username": "lzh7522",
        "id": 188631,
        "date": "2022-12-09 19:09:52",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct Node\r\n{\r\n    long long s, e, m;\r\n    long long val, lazy;\r\n    Node *l, *r;\r\n    Node(long long _s, long long _e)\r\n    {\r\n        s = _s;\r\n        e = _e;\r\n        m = (s + e) / 2;\r\n        val = 0;\r\n        lazy = 0;\r\n        l = nullptr;\r\n        r = nullptr;\r\n    }\r\n\r\n    void createlr()\r\n    {\r\n        if (s != e)\r\n        {\r\n            l = new Node(s, m);\r\n            r = new Node(m + 1, e);\r\n        }\r\n    }\r\n\r\n    void propogate()\r\n    {\r\n        if (s == e)\r\n        {\r\n            val += lazy;\r\n            lazy = 0;\r\n            return;\r\n        }\r\n        val += lazy * (e - s + 1);\r\n        if (l == nullptr || r == nullptr)\r\n        {\r\n            createlr();\r\n        }\r\n        l->lazy += lazy;\r\n        r->lazy += lazy;\r\n        lazy = 0;\r\n    }\r\n\r\n    void update(long long S, long long E, long long increment)\r\n    {\r\n        if (s == S && e == E)\r\n        {\r\n            lazy += increment;\r\n        }\r\n        else\r\n        {\r\n            if (l == nullptr || r == nullptr)\r\n            {\r\n                createlr();\r\n            }\r\n            if (E <= m)\r\n            {\r\n                l->update(S, E, increment);\r\n            }\r\n            else if (m < S)\r\n            {\r\n                r->update(S, E, increment);\r\n            }\r\n            else\r\n            {\r\n                l->update(S, m, increment);\r\n                r->update(m + 1, E, increment);\r\n            }\r\n            l->propogate();\r\n            r->propogate();\r\n            val = l->val + r->val;\r\n        }\r\n    }\r\n\r\n    long long query(long long S, long long E)\r\n    {\r\n        propogate();\r\n\r\n        if (s == S && e == E)\r\n        {\r\n            return val;\r\n        }\r\n        if (E <= m)\r\n        {\r\n            return l->query(S, E);\r\n        }\r\n        else if (m < S)\r\n        {\r\n            return r->query(S, E);\r\n        }\r\n        else\r\n        {\r\n            return l->query(S, m) + r->query(m + 1, E);\r\n        }\r\n    };\r\n} *root;\r\n\r\nint main()\r\n{\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n\r\n    long long N, Q;\r\n    cin >> N >> Q;\r\n    root = new Node(0, N - 1);\r\n\r\n    for (long long i = 0; i < Q; i++)\r\n    {\r\n        long long type;\r\n        cin >> type;\r\n        if (type == 1)\r\n        {\r\n            long long s, e, v;\r\n            cin >> s >> e >> v;\r\n            root->update(s - 1, e - 1, v);\r\n        }\r\n        else\r\n        {\r\n            long long s, e;\r\n            cin >> s >> e;\r\n            cout << root->query(s - 1, e - 1) << \"\\n\";\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}"
    },
    {
        "username": "NeeNawAmbulance",
        "id": 188341,
        "date": "2022-12-09 12:39:43",
        "code": "#pragma GCC optimize(\"O3,unroll-loops\")\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define double long double\r\n#define endl '\\n'\r\n#define all(x) (x).begin(), (x).end()\r\n#define pb push_back\r\n#define fi first\r\n#define se second\r\n#define sz(x) (int)(x).size()\r\n#define speed                     \\\r\n\tios_base::sync_with_stdio(0); \\\r\n\tcin.tie(0);                   \\\r\n\tcout.tie(0)\r\n#define pi pair<long long, long long>\r\n#define pii pair<long long, pi>\r\ntemplate <class T>\r\nusing v = vector<T>;\r\n#ifdef DEBUG\r\ntemplate <typename T>\r\ninline void debug(T x)\r\n{\r\n\tcout << x << \" \";\r\n}\r\ntemplate <typename T, typename... Args>\r\ninline void debug(T x, Args... args)\r\n{\r\n\tcout << x << \" | \";\r\n\tdebug(args...);\r\n}\r\n#define debug(...)                         \\\r\n\tcout << \"[\" << #__VA_ARGS__ << \"] : \"; \\\r\n\tdebug(__VA_ARGS__);                    \\\r\n\tcout << endl\r\n#endif\r\n#ifndef DEBUG\r\ntemplate <typename T>\r\ninline void debug(T x){}\r\ntemplate <typename T, typename... Args>\r\ninline void debug(T x, Args... args) {}\r\n#define debug(...)\r\n#endif\r\nostream &operator<<(ostream &o_str, const v<int> &p)\r\n{\r\n\to_str << \"{ \";\r\n\tfor (auto i = 0; i < (int)p.size(); i++)\r\n\t{\r\n\t\to_str << p[i];\r\n\t\tif (i < (int)p.size() - 1)\r\n\t\t{\r\n\t\t\to_str << \", \";\r\n\t\t}\r\n\t}\r\n\treturn o_str << \" }\";\r\n}\r\n\r\nstruct node\r\n{\r\n\tint start, end, middle, val, lazy;\r\n\tnode *left = nullptr;\r\n\tnode *right = nullptr;\r\n\tnode(int s, int e)\r\n\t{\r\n\t\tstart = s, end = e, middle = (start + end) / 2;\r\n\t\tval = 0;\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid create()\r\n\t{\r\n\t\tif (start != end){\r\n\t\t\tleft = new node(start, middle);\r\n\t\t\tright = new node(middle + 1, end);\r\n\t\t}\r\n\t}\r\n\tvoid propogate()\r\n\t{\r\n\t\tif (lazy == 0)return;\r\n\t\tval += (end - start + 1) * lazy;\r\n\t\tif (start != end){\r\n\t\t\tif(left == nullptr)create();\r\n\t\t\tleft->lazy += lazy;\r\n\t\t\tright->lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid update(int s,int e, int value)\r\n\t{\r\n\t\tif(left == nullptr)create();\r\n\t\tif(start == s && end == e){\r\n\t\t\tlazy += value;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tif(s > middle)right->update(s,e,value);\r\n\t\t\telse if(e <= middle)left->update(s,e,value);\r\n\t\t\telse{\r\n\t\t\t\tleft->update(s,middle,value);\r\n\t\t\t\tright->update(middle+1,e,value);\r\n\t\t\t}\r\n\t\t\tleft->propogate();\r\n\t\t\tright->propogate();\r\n\t\t\tval = left->val + right->val;\r\n\t\t}\r\n\t}\r\n\tint query(int s, int e)\r\n\t{\r\n\t\tif(left == nullptr)create();\r\n\t\tpropogate();\r\n\t\tif(start == s && end == e)return val;\r\n\t\telse if (s > middle)return right->query(s, e);\r\n\t\telse if (e <= middle)return left->query(s, e);\r\n\t\telse return left->query(s, middle) + right->query(middle + 1, e);\r\n\t}\r\n} * root;\r\n\r\nsigned main(int32_t argc, char *argv[])\r\n{\r\n\t// FILE *in = freopen(argv[1], \"r\", stdin);\r\n\t#ifdef DEBUG\r\n\t\tauto start = chrono::steady_clock::now();\r\n\t#endif\r\n\tspeed;\r\n\tint n, q;\r\n\tcin >> n >> q;\r\n\troot = new node(1, n+1);\r\n\twhile (q--)\r\n\t{\r\n\t\tint t, l, r;\r\n\t\tcin >> t >> l >> r;\r\n\t\tif (t == 1)\r\n\t\t{\r\n\t\t\tint x;\r\n\t\t\tcin >> x;\r\n\t\t\troot->update(l, r, x);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << root->query(l, r) << endl;\r\n\t\t}\r\n\t}\r\n\t#ifdef DEBUG\r\n\t\tauto end = chrono::steady_clock::now();\r\n\t\tauto diff = end - start;\r\n\t\tcout << chrono::duration<double, milli>(diff).count() << \" ms\" << endl;\r\n\t#endif\r\n}"
    },
    {
        "username": "bron",
        "id": 188276,
        "date": "2022-12-09 11:01:27",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long \r\nstruct node{\r\n\tint s,e,m,val=0,lazy=0;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\tnode(int S, int E){\r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t}\r\n\tvoid build(){\r\n\t\tif(l==nullptr){\r\n\t\tl = new node(s,m);\r\n\t\tr = new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif(lazy == 0) return;\r\n\t\tval += lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tbuild();\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid update(int S, int E, int V){\r\n\t\tpropogate();\r\n\t\tif(s==S && e==E) lazy+=V;\r\n\t\telse{\r\n\t\t\tbuild();\r\n\t\t\tif(E<=m) l->update(S,E,V);\r\n\t\t\telse if(S>m) r->update(S,E,V);\r\n\t\t\telse l->update(S,m,V), r->update(m+1,E,V);\r\n\t\t\tl->propogate();\r\n\t\t\tr->propogate();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\tint query(int S, int E){\r\n\t\tpropogate();\r\n\t\tif((s==S && e==E) || l==nullptr) return val;\r\n\t\tif(E<=m) return l->query(S,E);\r\n\t\tif(S>m) return r->query(S,E);\r\n\t\treturn l->query(S,m) + r->query(m+1,E);\r\n\t}\r\n}*root;\r\nmain(){\r\n\tcin.tie(0);\r\n\tios::sync_with_stdio(0);\r\n\tint n,q;\r\n\tcin>>n>>q;\r\n\troot = new node(0,n+3);\r\n\tfor(int i=0;i<q;i++){\r\n\t\tint a,b,c,d;\r\n\t\tcin>>a;\r\n\t\tif(a==1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "bron",
        "id": 188268,
        "date": "2022-12-09 10:51:55",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long \r\nstruct node{\r\n\tint s,e,m,val=0,lazy=0;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\tnode(int S, int E){\r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t}\r\n\tvoid build(){\r\n\t\tif(l==nullptr) l = new node(s,m), r= new node(m+1,e);\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif(lazy == 0) return;\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tbuild();\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid update(int S, int E, int V){\r\n\t\tpropogate();\r\n\t\tif(s==S && e==E) lazy+=V;\r\n\t\telse{\r\n\t\t\tbuild();\r\n\t\t\tif(E<=m) l->update(S,E,V);\r\n\t\t\telse if(S>m) r->update(S,E,V);\r\n\t\t\telse l->update(S,m,V), r->update(m+1,E,V);\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\tint query(int S, int E){\r\n\t\tpropogate();\r\n\t\tif((s==S && e==E) || l==nullptr) return val;\r\n\t\tif(E<=m) return l->query(S,E);\r\n\t\tif(S>m) return r->query(S,E);\r\n\t\treturn l->query(S,m) + r->query(m+1,E);\r\n\t}\r\n}*root;\r\nmain(){\r\n\tcin.tie(0);\r\n\tios::sync_with_stdio(0);\r\n\tint n,q;\r\n\tcin>>n>>q;\r\n\troot = new node(0,n+3);\r\n\tfor(int i=0;i<q;i++){\r\n\t\tint a,b,c,d;\r\n\t\tcin>>a;\r\n\t\tif(a==1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "bron",
        "id": 188081,
        "date": "2022-12-08 20:26:48",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long \r\nstruct node{\r\n\tint s,e,m,val=0,lazy=0;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\tnode(int S, int E){\r\n\t\ts = S, e = E, m=(s+e)/2;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(l==nullptr){\r\n\t\t\tl = new node(s,m);\r\n\t\t\tr = new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif(lazy == 0) return;\r\n\t\tval += (e-s+1)*lazy;\r\n\t\tif(s!=e){\r\n\t\t\tcreate();\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid update(int S, int E, int V){\r\n\t\tpropogate();\r\n\t\tif(s==S && e==E) lazy+=V;\r\n\t\telse{\r\n\t\t\tcreate();\r\n\t\t\tif(E<=m) l->update(S,E,V);\r\n\t\t\telse if(S>m) r->update(S,E,V);\r\n\t\t\telse l->update(S,m,V), r->update(m+1,E,V);\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\tint query(int S, int E){\r\n\t\tpropogate();\r\n\t\tif((s==S && e==E) || l == nullptr) return val;\r\n\t\tif(E<=m) return l->query(S,E);\r\n\t\tif(S>m) return r->query(S,E);\r\n\t\treturn l->query(S,m) + r->query(m+1,E);\r\n\t}\r\n}*root;\r\nmain(){\r\n\tcin.tie(0);\r\n\tios::sync_with_stdio(0);\r\n\tint n,q;\r\n\tcin>>n>>q;\r\n\troot = new node(0,n+3);\r\n\tfor(int i=0;i<q;i++){\r\n\t\tint a,b,c,d;\r\n\t\tcin>>a;\r\n\t\tif(a==1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "Craftless",
        "id": 188031,
        "date": "2022-12-08 19:29:52",
        "code": "#include <bits/stdc++.h>\r\n#define int long long int\r\n#define pi pair<int, int> \r\n#define pb push_back\r\n#define F first\r\n#define S second\r\n\r\nusing namespace std;\r\n\r\nint N, Q;\r\n\r\nstruct node {\r\n    int s, e, m, val, lazy;\r\n    node *l, *r;\r\n    node (int _s, int _e) {\r\n        s = _s; e = _e;\r\n        m = (s + e) / 2;\r\n        val = 0;\r\n        lazy = 0;\r\n        l = NULL;\r\n        r = NULL;\r\n        // if (s != e) {\r\n        //     l = new node(s, m);\r\n        //     r = new node(m + 1, e);\r\n        // }\r\n    }\r\n    \r\n    int query(int _s, int _e) {\r\n        propagate();\r\n        if (s == _s and e == _e) {\r\n            return val;\r\n        }\r\n        else if (_e <= m) {\r\n            return l -> query(_s, _e);\r\n        }\r\n        else if (_s > m) {\r\n            return r-> query(_s, _e);\r\n        }\r\n        else {\r\n            return l -> query(_s, m) + r -> query(m + 1, _e);\r\n        }\r\n    }\r\n    \r\n    void update(int _s, int _e, int v) {\r\n\t\tpropagate();\r\n        if (s == _s and e == _e) {\r\n            lazy += v;\r\n        }\r\n        else {\r\n            if (_e <= m) l -> update(_s, _e, v);\r\n            else if (_s > m) r -> update(_s, _e, v);\r\n            else {\r\n                l -> update(_s, m, v); r -> update(m + 1, _e, v);\r\n            }\r\n            l -> propagate(); r -> propagate();\r\n            val = l -> val + r -> val;\r\n        }\r\n        \r\n    }\r\n    \r\n    void propagate() {\r\n\t\tif (!l) children();\r\n        if (lazy == 0) return;\r\n        val += (e - s + 1) * lazy;\r\n        if (s != e) {\r\n            l -> lazy += lazy;\r\n            r -> lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\n    void children() {\r\n        if (s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m + 1, e);\r\n        }\r\n    }\r\n\r\n} *root;\r\n\r\nint32_t main() {\r\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n\r\n            \r\n    cin >> N >> Q;\r\n    root = new node(0, N - 1);\r\n    for (int i = 0; i < Q; i++) {\r\n        int a, l, r; cin >> a >> l >> r;\r\n        l--; r--;\r\n        if (a == 1) {\r\n            int k; cin >> k;\r\n            root -> update(l, r, k);\r\n        }\r\n        else {\r\n            cout << root -> query(l, r) << \"\\n\";\r\n        }\r\n    }\r\n    \r\n    return 0;\r\n\r\n}\r\n"
    },
    {
        "username": "haydendoo",
        "id": 188028,
        "date": "2022-12-08 19:22:47",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int mxN=1e9;\r\n\r\ntypedef long long ll;\r\n#define int ll\r\n\r\n#define sus int m=(s+e)>>1;\r\n\r\nstruct node {\r\n\tint s,e,v;\r\n\tint lz;\r\n\tnode *l, *r;\r\n\tnode(int _S, int _E): s(_S), e(_E), v(0), lz(0), l(NULL), r(NULL) {}\r\n\tinline void push() {\r\n\t\tif(lz==0 || s==e) return;\r\n\t\tl->lz += lz; l->v += lz*(l->e - l->s + 1);\r\n\t\tr->lz += lz; r->v += lz*(r->e - r->s + 1); lz=0;\r\n\t}\r\n\tinline void create() {\r\n\t\tif(s==e || l!=NULL) return;\r\n\t\tsus\r\n\t\tl = new node(s,m);\r\n\t\tr = new node(m+1,e);\r\n\t}\r\n\tvoid upd(int x, int y, int v2) {\r\n\t\tif(s==x && e==y) {\r\n\t\t\tlz += v2;\r\n\t\t\tv += v2*(e-s+1);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsus\r\n\t\tcreate(); push();\r\n\t\tif(x<=m) l->upd(x,min(y,m),v2);\r\n\t\tif(y>m) r->upd(max(x,m+1),y,v2);\r\n\t\tv = l->v + r->v;\r\n\t}\r\n\tint query(int x, int y) {\r\n\t\tif(s==x && e==y) return v;\r\n\t\tif(l==NULL) return (v / (e-s+1)) * (y-x+1);\r\n\t\tsus\r\n\t\tpush();\r\n\t\tif(y<=m) return l->query(x,y);\r\n\t\tif(x>m) return r->query(x,y);\r\n\t\treturn l->query(x,m) + r->query(m+1,y);\r\n\t}\r\n} *root;\r\n\r\nmain() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint q, n;\r\n\troot = new node(0, mxN);\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; ++i){\r\n\t\tint type;\r\n\t\tcin >> type;\r\n\t\tif(type==1){\r\n\t\t\tint l, r, v;\r\n\t\t\tcin >> l >> r >> v;\r\n\t\t\troot->upd(l-1,r-1,v);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->query(l-1,r-1) << '\\n';\r\n\t\t}\r\n\t}\r\n} \r\n/*\r\n5 5 \r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/"
    },
    {
        "username": "haydendoo",
        "id": 188027,
        "date": "2022-12-08 19:22:33",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int mxN=1e9;\r\n\r\ntypedef long long ll;\r\n#define int ll\r\n#define NULL nullptr\r\n#define sus int m=(s+e)>>1;\r\n\r\nstruct node {\r\n\tint s,e,v;\r\n\tint lz;\r\n\tnode *l, *r;\r\n\tnode(int _S, int _E): s(_S), e(_E), v(0), lz(0), l(NULL), r(NULL) {}\r\n\tinline void push() {\r\n\t\tif(lz==0 || s==e) return;\r\n\t\tl->lz += lz; l->v += lz*(l->e - l->s + 1);\r\n\t\tr->lz += lz; r->v += lz*(r->e - r->s + 1); lz=0;\r\n\t}\r\n\tinline void create() {\r\n\t\tif(s==e || l!=NULL) return;\r\n\t\tsus\r\n\t\tl = new node(s,m);\r\n\t\tr = new node(m+1,e);\r\n\t}\r\n\tvoid upd(int x, int y, int v2) {\r\n\t\tif(s==x && e==y) {\r\n\t\t\tlz += v2;\r\n\t\t\tv += v2*(e-s+1);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsus\r\n\t\tcreate(); push();\r\n\t\tif(x<=m) l->upd(x,min(y,m),v2);\r\n\t\tif(y>m) r->upd(max(x,m+1),y,v2);\r\n\t\tv = l->v + r->v;\r\n\t}\r\n\tint query(int x, int y) {\r\n\t\tif(s==x && e==y) return v;\r\n\t\tif(l==NULL) return (v / (e-s+1)) * (y-x+1);\r\n\t\tsus\r\n\t\tpush();\r\n\t\tif(y<=m) return l->query(x,y);\r\n\t\tif(x>m) return r->query(x,y);\r\n\t\treturn l->query(x,m) + r->query(m+1,y);\r\n\t}\r\n} *root;\r\n\r\nmain() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint q, n;\r\n\troot = new node(0, mxN);\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; ++i){\r\n\t\tint type;\r\n\t\tcin >> type;\r\n\t\tif(type==1){\r\n\t\t\tint l, r, v;\r\n\t\t\tcin >> l >> r >> v;\r\n\t\t\troot->upd(l-1,r-1,v);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->query(l-1,r-1) << '\\n';\r\n\t\t}\r\n\t}\r\n} \r\n/*\r\n5 5 \r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/"
    },
    {
        "username": "tux",
        "id": 188022,
        "date": "2022-12-08 19:15:26",
        "code": "#include <bits/stdc++.h>\r\n#define int long long int\r\n#define pi pair<int, int> \r\n#define pb push_back\r\n#define F first\r\n#define S second\r\n\r\nusing namespace std;\r\n\r\nint N, Q;\r\n\r\nstruct node {\r\n    int s, e, m, val, lazy;\r\n    node *l, *r;\r\n    node (int _s, int _e) {\r\n        s = _s; e = _e;\r\n        m = (s + e) / 2;\r\n        val = 0;\r\n        lazy = 0;\r\n        l = NULL;\r\n        r = NULL;\r\n        // if (s != e) {\r\n        //     l = new node(s, m);\r\n        //     r = new node(m + 1, e);\r\n        // }\r\n    }\r\n    \r\n    int query(int _s, int _e) {\r\n        if (!l) children();\r\n        propagate();\r\n        if (s == _s and e == _e) {\r\n            return val;\r\n        }\r\n        else if (_e <= m) {\r\n            return l -> query(_s, _e);\r\n        }\r\n        else if (_s > m) {\r\n            return r-> query(_s, _e);\r\n        }\r\n        else {\r\n            return l -> query(_s, m) + r -> query(m + 1, _e);\r\n        }\r\n    }\r\n    \r\n    void update(int _s, int _e, int v) {\r\n        if (!l) children();\r\n        if (s == _s and e == _e) {\r\n            lazy += v;\r\n        }\r\n        else {\r\n            if (_e <= m) l -> update(_s, _e, v);\r\n            else if (_s > m) r -> update(_s, _e, v);\r\n            else {\r\n                l -> update(_s, m, v); r -> update(m + 1, _e, v);\r\n            }\r\n            l -> propagate(); r -> propagate();\r\n            val = l -> val + r -> val;\r\n        }\r\n        \r\n    }\r\n    \r\n    void propagate() {\r\n        if (lazy == 0) return;\r\n        val += (e - s + 1) * lazy;\r\n        if (s != e) {\r\n\t\t\tif (!l) children();\r\n            l -> lazy += lazy;\r\n            r -> lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\n    void children() {\r\n        if (s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m + 1, e);\r\n        }\r\n    }\r\n\r\n} *root;\r\n\r\nint32_t main() {\r\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n\r\n            \r\n    cin >> N >> Q;\r\n    root = new node(0, N);\r\n    for (int i = 0; i < Q; i++) {\r\n        int a, l, r; cin >> a >> l >> r;\r\n        l; r;\r\n        if (a == 1) {\r\n            int k; cin >> k;\r\n            root -> update(l, r, k);\r\n        }\r\n        else {\r\n            cout << root -> query(l, r) << \"\\n\";\r\n        }\r\n    }\r\n    \r\n    return 0;\r\n\r\n}\r\n"
    },
    {
        "username": "bron",
        "id": 187982,
        "date": "2022-12-08 16:59:19",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long \r\nstruct node{\r\n\tint s,e,m,val=0,lazy=0;\r\n\tnode *l = nullptr,*r = nullptr;\r\n\tnode(int S, int E){\r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(l==nullptr){\r\n\t\t\tl = new node(s,m);\r\n\t\t\tr = new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif(lazy == 0) return;\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tcreate();\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid update(int S, int E, int V){\r\n\t\tpropogate();\r\n\t\tif(s==S && e==E) lazy+=V;\r\n\t\telse{\r\n\t\t\tcreate();\r\n\t\t\tif(E<=m) l->update(S,E,V);\r\n\t\t\telse if(S>m) r->update(S,E,V);\r\n\t\t\telse l->update(S,m,V), r->update(m+1,E,V);\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\tint query(int S, int E){\r\n\t\tpropogate();\r\n\t\tif((s==S&&e==E)||l==nullptr) return val;\r\n\t\tif(E<=m) return l->query(S,E);\r\n\t\tif(S>m) return r->query(S,E);\r\n\t\treturn l->query(S,m) + r->query(m+1,E);\r\n\t}\r\n}*root;\r\nmain(){\r\n\tcin.tie(0);\r\n\tios::sync_with_stdio(0);\r\n\tint n,q;\r\n\tcin>>n>>q;\r\n\troot = new node(0,n+3);\r\n\tfor(int i=0;i<q;i++){\r\n\t\tint a,b,c,d;\r\n\t\tcin>>a;\r\n\t\tif(a==1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "bron",
        "id": 187970,
        "date": "2022-12-08 16:45:30",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long \r\nstruct node{\r\n\tint s,m,e,val=0,lazy=0;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\tnode(int S, int E){\r\n\t\t s = S, e = E, m = (s+e)/2;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(l==nullptr){\r\n\t\t\tl = new node(s,m);\r\n\t\t\tr = new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif(lazy == 0) return;\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tcreate();\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy +=lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid update(int S, int E, int V){\r\n\t\tpropogate();\r\n\t\tif((s==S && e==E)) lazy+=V;\r\n\t\telse{\r\n\t\t\tcreate();\r\n\t\t\tif(E<=m) l->update(S,E,V);\r\n\t\t\telse if(S>m) r->update(S,E,V);\r\n\t\t\telse l->update(S,m,V), r->update(m+1,E,V);\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\tint query(int S, int E){\r\n\t\tpropogate();\r\n\t\tif((s==S && e==E) || l == nullptr) return val;\r\n\t\telse if(E<=m) return l->query(S,E);\r\n\t\telse if(S>m) return r->query(S,E);\r\n\t\telse return l->query(S,m) + r->query(m+1,E);\r\n\t\t\r\n\t}\r\n}*root;\r\nmain(){\r\n\tcin.tie(0);\r\n\tios::sync_with_stdio(0);\r\n\tint n,q;\r\n\tcin>>n>>q;\r\n\troot = new node(0,n+3);\r\n\tfor(int i=0;i<q;i++){\r\n\t\tint a,b,c,d;\r\n\t\tcin>>a;\r\n\t\tif(a==1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "bron",
        "id": 187952,
        "date": "2022-12-08 16:30:52",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n\tint s,e,m,val=0;\r\n\tint lazy = 0;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\tnode(int S, int E){\r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(l == nullptr){\r\n\t\t\tl = new node(s,m);\r\n\t\t\tr = new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif(lazy == 0) return;\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tcreate();\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid update(int S, int E, int V){\r\n\t\tpropogate();\r\n\t\tif(s==S && e==E) lazy+=V;\r\n\t\telse{\r\n\t\t\tcreate();\r\n\t\t\tif(E<=m) l->update(S,E,V);\r\n\t\t\telse if(S>m) r->update(S,E,V);\r\n\t\t\telse l->update(S,m,V), r->update(m+1,E,V);\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\tint query(int S, int E){\r\n\t\tpropogate();\r\n\t\tif((s==S && e==E) || l == nullptr) return val;\r\n\t\telse if(E<=m) return l->query(S,E);\r\n\t\telse if(S>m) return r->query(S,E);\r\n\t\telse return l->query(S,m) + r->query(m+1,E);\r\n\t}\r\n}*root;\r\nmain(){\r\n\tint N,Q;\r\n\tcin>>N>>Q;\r\n\tcin.tie(0);\r\n\tios::sync_with_stdio(0);\r\n\troot = new node(0,N+3);\r\n\tfor(int i=0;i<Q;i++){\r\n\t\tint a,b,c,d;\r\n\t\tcin>>a;\r\n\t\tif(a==1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "kxd",
        "id": 187666,
        "date": "2022-12-08 01:45:33",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define ll long long\r\n#define pb push_back\r\n#define p_q priority_queue\r\n#define m_p make_pair\r\n#define pii pair<int,int>\r\n#define endl '\\n'\r\n#define INIT ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define FOR(i, a, b) for(int i = a; i < b; i++)\r\n#define forn(i, n) for (int i = 0; i < n; i++)\r\n#define f first\r\n#define s second\r\n\r\nusing namespace std;\r\nconst int N = 5e6+5;\r\nconst int INF = 1e18;\r\n\r\nstruct node {\r\n    int s, e, m, v;\r\n    int lazy; //lazy value storage\r\n    node *l, *r;\r\n    node(int _s, int _e) {\r\n        s = _s;\r\n        e = _e;\r\n        v = lazy = 0;\r\n        if (s == e) return;\r\n        m = (s + e) / 2;\r\n        //Do not create the children here\r\n    }\r\n    void propo() { \r\n        //Create before propo\r\n        if (s != e && l == nullptr) {\r\n        \tl = new node(s, m);\r\n        \tr = new node(m+1, e);\r\n\t\t}\r\n        if (lazy != 0) {\r\n            //Update value base on range\r\n            v += lazy * (e - s + 1);\r\n            //Propogate\r\n            if (s != e){\r\n                r -> lazy += lazy;\r\n                l -> lazy += lazy;\r\n            }\r\n            //Reset value\r\n            lazy = 0;\r\n        }\r\n    }\r\n    void up(int x, int y, int c) {\r\n        //Propo before update\r\n        if (s >= x && e <= y) {\r\n            lazy += c;\r\n            return;\r\n        }\r\n        else {\r\n        \tpropo();\r\n            if (y <= m) l -> up(x, y, c);\r\n            else if (x > m) r -> up(x, y, c);\r\n            else {\r\n\t\t\t\tl -> up(x, y, c);\r\n\t\t\t\tr -> up(x, y, c);\r\n\t\t\t}\r\n            //Reminder to propo before updating cur node value\r\n            l -> propo(); r -> propo();\r\n            v = l -> v + r -> v;\r\n        }\r\n    }\r\n    int query(int x, int y) {\r\n        //Propo before processing query\r\n        propo();\r\n        if (s >= x && e <= y) return v;\r\n        if (x > m) return r -> query(x, y);\r\n        if (y <= m) return l -> query(x, y);\r\n        else return l -> query(x, y) + r -> query(x, y);\r\n    }\r\n} *root;\r\n\r\nsigned main() {\r\n\tINIT\r\n    int n; cin >> n;\r\n    root = new node(0, n);\r\n    int q; cin >> q;\r\n    int t, l, r, k;\r\n    while(q--) {\r\n        cin >> t;\r\n        if (t == 1) {\r\n            cin >> l >> r >> k;\r\n            root -> up(l, r, k);\r\n        } else {\r\n            cin >> l >> r;\r\n            cout << root -> query(l, r) << endl;\r\n        }\r\n    }\r\n}   "
    },
    {
        "username": "kxd",
        "id": 187665,
        "date": "2022-12-08 01:43:05",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define ll long long\r\n#define pb push_back\r\n#define p_q priority_queue\r\n#define m_p make_pair\r\n#define pii pair<int,int>\r\n#define endl '\\n'\r\n#define INIT ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define FOR(i, a, b) for(int i = a; i < b; i++)\r\n#define forn(i, n) for (int i = 0; i < n; i++)\r\n#define f first\r\n#define s second\r\n\r\nusing namespace std;\r\nconst int N = 5e6+5;\r\nconst int INF = 1e18;\r\n\r\nstruct node {\r\n    int s, e, m, v;\r\n    int lazy; //lazy value storage\r\n    node *l, *r;\r\n    node(int _s, int _e) {\r\n        s = _s;\r\n        e = _e;\r\n        v = lazy = 0;\r\n        if (s == e) return;\r\n        m = (s + e) / 2;\r\n        //Do not create the children here\r\n    }\r\n    void propo() { \r\n        //Create before propo\r\n        if (s != e && l == nullptr) {\r\n        \tl = new node(s, m);\r\n        \tr = new node(m+1, e);\r\n\t\t}\r\n        if (lazy != 0) {\r\n            //Update value base on range\r\n            v += lazy * (e - s + 1);\r\n            //Propogate\r\n            if (s != e){\r\n                r -> lazy += lazy;\r\n                l -> lazy += lazy;\r\n            }\r\n            //Reset value\r\n            lazy = 0;\r\n        }\r\n    }\r\n    void up(int x, int y, int c) {\r\n        //Propo before update\r\n        if (x == s && y == e) {\r\n            lazy += c;\r\n            return;\r\n        }\r\n        else {\r\n        \tpropo();\r\n            if (y <= m) l -> up(x, y, c);\r\n            else if (x > m) r -> up(x, y, c);\r\n            else {\r\n\t\t\t\tl -> up(x, m, c);\r\n\t\t\t\tr -> up(m+1, y, c);\r\n\t\t\t}\r\n            //Reminder to propo before updating cur node value\r\n            l -> propo(); r -> propo();\r\n            v = l -> v + r -> v;\r\n        }\r\n    }\r\n    int query(int x, int y) {\r\n        //Propo before processing query\r\n        propo();\r\n        if (s >= x && e <= y) return v;\r\n        if (x > m) return r -> query(x, y);\r\n        if (y <= m) return l -> query(x, y);\r\n        else return l -> query(x, y) + r -> query(x, y);\r\n    }\r\n} *root;\r\n\r\nsigned main() {\r\n\tINIT\r\n    int n; cin >> n;\r\n    root = new node(0, n);\r\n    int q; cin >> q;\r\n    int t, l, r, k;\r\n    while(q--) {\r\n        cin >> t;\r\n        if (t == 1) {\r\n            cin >> l >> r >> k;\r\n            root -> up(l, r, k);\r\n        } else {\r\n            cin >> l >> r;\r\n            cout << root -> query(l, r) << endl;\r\n        }\r\n    }\r\n}   "
    },
    {
        "username": "kxd",
        "id": 187663,
        "date": "2022-12-08 01:30:12",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define ll long long\r\n#define pb push_back\r\n#define p_q priority_queue\r\n#define m_p make_pair\r\n#define pii pair<int,int>\r\n#define endl '\\n'\r\n#define INIT ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define FOR(i, a, b) for(int i = a; i < b; i++)\r\n#define forn(i, n) for (int i = 0; i < n; i++)\r\n#define f first\r\n#define s second\r\n\r\nusing namespace std;\r\nconst int N = 5e6+5;\r\nconst int INF = 1e18;\r\n\r\nstruct node {\r\n    int s, e, m, v;\r\n    int lazy; //lazy value storage\r\n    node *l, *r;\r\n    node(int _s, int _e) {\r\n        s = _s;\r\n        e = _e;\r\n        v = lazy = 0;\r\n        if (s == e) return;\r\n        m = (s + e) / 2;\r\n        //Do not create the children here\r\n    }\r\n    void propo() { \r\n        //Create before propo\r\n        if (s != e&& l == nullptr) {\r\n        \tl = new node(s, m);\r\n        \tr = new node(m+1, e);\r\n\t\t}\r\n        if (lazy != 0) {\r\n            //Update value base on range\r\n            v += lazy * (e - s + 1);\r\n            //Propogate\r\n            if (s != e){\r\n                r -> lazy += lazy;\r\n                l -> lazy += lazy;\r\n            }\r\n            //Reset value\r\n            lazy = 0;\r\n        }\r\n    }\r\n    void up(int x, int y, int c) {\r\n        //Propo before update\r\n        if (x == s && y == e) {\r\n            lazy += c;\r\n            return;\r\n        }\r\n        else {\r\n        \tpropo();\r\n            if (y <= m) l -> up(x, y, c);\r\n            else if (x > m) r -> up(x, y, c);\r\n            else {\r\n\t\t\t\tl -> up(x, m, c);\r\n\t\t\t\tr -> up(m+1, y, c);\r\n\t\t\t}\r\n            //Reminder to propo before updating cur node value\r\n            l -> propo(); r -> propo();\r\n            v = l -> v + r -> v;\r\n        }\r\n    }\r\n    int query(int x, int y) {\r\n        //Propo before processing query\r\n        propo();\r\n        if (s == x && e == y) return v;\r\n        if (x > m) return r -> query(x, y);\r\n        if (y <= m) return l -> query(x, y);\r\n        else return l -> query(x, m) + r -> query(m + 1, y);\r\n    }\r\n} *root;\r\n\r\nsigned main() {\r\n\tINIT\r\n    int n; cin >> n;\r\n    root = new node(0, n);\r\n    int q; cin >> q;\r\n    int t, l, r, k;\r\n    while(q--) {\r\n        cin >> t;\r\n        if (t == 1) {\r\n            cin >> l >> r >> k;\r\n            root -> up(l, r, k);\r\n        } else {\r\n            cin >> l >> r;\r\n            cout << root -> query(l, r) << endl;\r\n        }\r\n    }\r\n}   "
    },
    {
        "username": "kxd",
        "id": 187661,
        "date": "2022-12-08 01:27:37",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define ll long long\r\n#define pb push_back\r\n#define p_q priority_queue\r\n#define m_p make_pair\r\n#define pii pair<int,int>\r\n#define endl '\\n'\r\n#define INIT ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define FOR(i, a, b) for(int i = a; i < b; i++)\r\n#define forn(i, n) for (int i = 0; i < n; i++)\r\n#define f first\r\n#define s second\r\n\r\nusing namespace std;\r\nconst int N = 5e6+5;\r\nconst int INF = 1e18;\r\n\r\nstruct node {\r\n    int s, e, m, v;\r\n    int lazy; //lazy value storage\r\n    node *l, *r;\r\n    node(int _s, int _e) {\r\n        s = _s;\r\n        e = _e;\r\n        v = lazy = 0;\r\n        if (s == e) return;\r\n        m = (s + e) / 2;\r\n        //Do not create the children here\r\n    }\r\n    void create() { \r\n        if (s == e) return;       //No children\r\n        if (l != nullptr) return; //exists\r\n        //Create if non-existent and has children\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n    }\r\n    void propo() { \r\n        //Create before propo\r\n        create(); \r\n        if (lazy != 0) {\r\n            //Update value base on range\r\n            v += lazy * (e - s + 1);\r\n            //Propogate\r\n            if (s != e){\r\n                r -> lazy += lazy;\r\n                l -> lazy += lazy;\r\n            }\r\n            //Reset value\r\n            lazy = 0;\r\n        }\r\n    }\r\n    void up(int x, int y, int c) {\r\n        //Propo before update\r\n        if (x == s && y == e) {\r\n            lazy += c;\r\n            return;\r\n        }\r\n        else {\r\n        \tpropo();\r\n            if (y <= m) l -> up(x, y, c);\r\n            else if (x > m) r -> up(x, y, c);\r\n            else { l -> up(x, m, c); r -> up(m + 1, y, c); }\r\n            //Reminder to propo before updating cur node value\r\n            l -> propo(); r -> propo();\r\n            v = l -> v + r -> v;\r\n        }\r\n    }\r\n    int query(int x, int y) {\r\n        //Propo before processing query\r\n        propo();\r\n        if (s == x && e == y) return v;\r\n        if (x > m) return r -> query(x, y);\r\n        if (y <= m) return l -> query(x, y);\r\n        else return l -> query(x, m) + r -> query(m + 1, y);\r\n    }\r\n} *root;\r\n\r\nsigned main() {\r\n\tINIT\r\n    int n; cin >> n;\r\n    root = new node(0, n);\r\n    int q; cin >> q;\r\n    int t, l, r, k;\r\n    while(q--) {\r\n        cin >> t;\r\n        if (t == 1) {\r\n            cin >> l >> r >> k;\r\n            root -> up(l, r, k);\r\n        } else {\r\n            cin >> l >> r;\r\n            cout << root -> query(l, r) << endl;\r\n        }\r\n    }\r\n}   "
    },
    {
        "username": "kxd",
        "id": 187654,
        "date": "2022-12-08 01:19:31",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define ll long long\r\n#define pb push_back\r\n#define p_q priority_queue\r\n#define m_p make_pair\r\n#define pii pair<int,int>\r\n#define endl '\\n'\r\n#define INIT ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define FOR(i, a, b) for(int i = a; i < b; i++)\r\n#define forn(i, n) for (int i = 0; i < n; i++)\r\n#define f first\r\n#define s second\r\n\r\nusing namespace std;\r\nconst int N = 5e6+5;\r\nconst int INF = 1e18;\r\n\r\nstruct node {\r\n    long long s, e, m, v;\r\n    long long lazy; //lazy value storage\r\n    \r\n    node *l, *r;\r\n\r\n    node(long long _s, long long _e) {\r\n        s = _s;\r\n        e = _e;\r\n        v = lazy = 0;\r\n        \r\n        if (s == e) return;\r\n\r\n        m = (s + e) / 2;\r\n        \r\n        //Do not create the children here\r\n    }\r\n\r\n    void create() { \r\n    \r\n        if (s == e) return;       //No children\r\n        if (l != nullptr) return; //exists\r\n        \r\n        //Create if non-existent and has children\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n        \r\n    }\r\n    \r\n    void propo() { \r\n    \r\n        //Create before propo\r\n        create(); \r\n        \r\n        if (lazy != 0) {\r\n            //Update value base on range\r\n            v += lazy * (e - s + 1);\r\n            \r\n            //Propogate\r\n            if (s != e){\r\n                r -> lazy += lazy;\r\n                l -> lazy += lazy;\r\n            }\r\n            \r\n            //Reset value\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    void up(long long x, long long y, long long c) {\r\n        //Propo before update\r\n        \r\n        if (x == s && y == e) {\r\n            lazy += c;\r\n            return;\r\n        }\r\n        else {\r\n        \tpropo();\r\n            if (y <= m) l -> up(x, y, c);\r\n            else if (x > m) r -> up(x, y, c);\r\n            else { l -> up(x, m, c); r -> up(m + 1, y, c); }\r\n            \r\n            //Reminder to propo before updating cur node value\r\n            l -> propo(); r -> propo();\r\n            v = l -> v + r -> v;\r\n        }\r\n\r\n    }\r\n\r\n    long long query(long long x, long long y) {\r\n        //Propo before processing query\r\n        propo();\r\n\r\n        if (s == x && e == y) return v;\r\n        if (x > m) return r -> query(x, y);\r\n        if (y <= m) return l -> query(x, y);\r\n        else return l -> query(x, m) + r -> query(m + 1, y);\r\n    }\r\n} *root;\r\n\r\nsigned main() {\r\n\tINIT\r\n    int n; cin >> n;\r\n    root = new node(0, n);\r\n    int q; cin >> q;\r\n    int t, l, r, k;\r\n    while(q--) {\r\n        cin >> t;\r\n        if (t == 1) {\r\n            cin >> l >> r >> k;\r\n            root -> up(l, r, k);\r\n        } else {\r\n            cin >> l >> r;\r\n            cout << root -> query(l, r) << endl;\r\n        }\r\n    }\r\n}   "
    },
    {
        "username": "kxd",
        "id": 187653,
        "date": "2022-12-08 01:19:13",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define ll long long\r\n#define pb push_back\r\n#define p_q priority_queue\r\n#define m_p make_pair\r\n#define pii pair<int,int>\r\n#define endl '\\n'\r\n#define INIT ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define FOR(i, a, b) for(int i = a; i < b; i++)\r\n#define forn(i, n) for (int i = 0; i < n; i++)\r\n#define f first\r\n#define s second\r\n\r\nusing namespace std;\r\nconst int N = 5e6+5;\r\nconst int INF = 1e18;\r\n\r\nstruct node {\r\n    long long s, e, m, v;\r\n    long long lazy; //lazy value storage\r\n    \r\n    node *l, *r;\r\n\r\n    node(long long _s, long long _e) {\r\n        s = _s;\r\n        e = _e;\r\n        v = lazy = 0;\r\n        \r\n        if (s == e) return;\r\n\r\n        m = (s + e) / 2;\r\n        \r\n        //Do not create the children here\r\n    }\r\n\r\n    void create() { \r\n    \r\n        if (s == e) return;       //No children\r\n        if (l != nullptr) return; //exists\r\n        \r\n        //Create if non-existent and has children\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n        \r\n    }\r\n    \r\n    void propo() { \r\n    \r\n        //Create before propo\r\n        create(); \r\n        \r\n        if (lazy != 0) {\r\n            //Update value base on range\r\n            v += lazy * (e - s + 1);\r\n            \r\n            //Propogate\r\n            if (s != e){\r\n                r -> lazy += lazy;\r\n                l -> lazy += lazy;\r\n            }\r\n            \r\n            //Reset value\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    void up(long long x, long long y, long long c) {\r\n        //Propo before update\r\n        \r\n        if (x == s && y == e) {\r\n            lazy += c;\r\n            return;\r\n        }\r\n        else {\r\n        \tpropo();\r\n            if (y <= m) l -> up(x, y, c);\r\n            else if (x > m) r -> up(x, y, c);\r\n            else { l -> up(x, m, c); r -> up(m + 1, y, c); }\r\n            \r\n            //Reminder to propo before updating cur node value\r\n            l -> propo(); r -> propo();\r\n            v = l -> v + r -> v;\r\n        }\r\n\r\n    }\r\n\r\n    long long query(long long x, long long y) {\r\n        //Propo before processing query\r\n        propo();\r\n\r\n        if (s == x && e == y) return v;\r\n        if (x > m) return r -> query(x, y);\r\n        if (y <= m) return l -> query(x, y);\r\n        else return l -> query(x, m) + r -> query(m + 1, y);\r\n    }\r\n} *root;\r\n\r\nsigned main() {\r\n\tINIT\r\n    int n; cin >> n;\r\n    root = new node(0, n);\r\n    int q; cin >> q;\r\n    int t, l, r, k;\r\n    while(q--) {\r\n        cin >> t;\r\n        if (t == 1) {\r\n            cin >> l >> r >> k;\r\n            root -> up(l, r, k);\r\n        } else {\r\n            cin >> l >> r;\r\n            cout << root -> query(l, r) << endl;\r\n        }\r\n    }\r\n}   "
    },
    {
        "username": "kxd",
        "id": 187652,
        "date": "2022-12-08 01:17:04",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define ll long long\r\n#define pb push_back\r\n#define p_q priority_queue\r\n#define m_p make_pair\r\n#define pii pair<int,int>\r\n#define endl '\\n'\r\n#define INIT ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define FOR(i, a, b) for(int i = a; i < b; i++)\r\n#define forn(i, n) for (int i = 0; i < n; i++)\r\n#define f first\r\n#define s second\r\n\r\nusing namespace std;\r\nconst int N = 5e6+5;\r\nconst int INF = 1e18;\r\n\r\nstruct node {\r\n    long long s, e, m, v;\r\n    long long lazy; //lazy value storage\r\n    \r\n    node *l, *r;\r\n\r\n    node(long long _s, long long _e) {\r\n        s = _s;\r\n        e = _e;\r\n        v = lazy = 0;\r\n        \r\n        if (s == e) return;\r\n\r\n        m = (s + e) / 2;\r\n        \r\n        //Do not create the children here\r\n    }\r\n\r\n    void create() { \r\n    \r\n        if (s == e) return;       //No children\r\n        if (l != nullptr) return; //exists\r\n        \r\n        //Create if non-existent and has children\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n        \r\n    }\r\n    \r\n    void propo() { \r\n    \r\n        //Create before propo\r\n        create(); \r\n        \r\n        if (lazy != 0) {\r\n            //Update value base on range\r\n            v += lazy * (e - s + 1);\r\n            \r\n            //Propogate\r\n            if (s != e){\r\n                r -> lazy += lazy;\r\n                l -> lazy += lazy;\r\n            }\r\n            \r\n            //Reset value\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    void up(long long x, long long y, long long c) {\r\n        //Propo before update\r\n        \r\n        if (x == s && y == e) {\r\n            lazy += c;\r\n            return;\r\n        }\r\n        else {\r\n        \tpropo();\r\n            if (y <= m) l -> up(x, y, c);\r\n            else if (x > m) r -> up(x, y, c);\r\n            else { l -> up(x, m, c); r -> up(m + 1, y, c); }\r\n            \r\n            //Reminder to propo before updating cur node value\r\n            l -> propo(); r -> propo();\r\n            v = l -> v + r -> v;\r\n        }\r\n\r\n    }\r\n\r\n    long long query(long long x, long long y) {\r\n        //Propo before processing query\r\n        propo();\r\n\r\n        if (s == x && e == y) return v;\r\n        if (x > m) return r -> query(x, y);\r\n        if (y <= m) return l -> query(x, y);\r\n        else return l -> query(x, m) + r -> query(m + 1, y);\r\n    }\r\n} *root;\r\n\r\nsigned main() {\r\n\tINIT\r\n    int n; cin >> n;\r\n    root = new node(0, 1000000005);\r\n    int q; cin >> q;\r\n    int t, l, r, k;\r\n    while(q--) {\r\n        cin >> t;\r\n        if (t == 1) {\r\n            cin >> l >> r >> k;\r\n            root -> up(l, r, k);\r\n        } else {\r\n            cin >> l >> r;\r\n            cout << root -> query(l, r) << endl;\r\n        }\r\n    }\r\n}   "
    },
    {
        "username": "kxd",
        "id": 187651,
        "date": "2022-12-08 01:16:39",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define ll long long\r\n#define pb push_back\r\n#define p_q priority_queue\r\n#define m_p make_pair\r\n#define pii pair<int,int>\r\n#define endl '\\n'\r\n#define INIT ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define FOR(i, a, b) for(int i = a; i < b; i++)\r\n#define forn(i, n) for (int i = 0; i < n; i++)\r\n#define f first\r\n#define s second\r\n\r\nusing namespace std;\r\nconst int N = 5e6+5;\r\nconst int INF = 1e18;\r\n\r\nstruct node {\r\n    long long s, e, m, v;\r\n    long long lazy; //lazy value storage\r\n    \r\n    node *l, *r;\r\n\r\n    node(long long _s, long long _e) {\r\n        s = _s;\r\n        e = _e;\r\n        v = lazy = 0;\r\n        \r\n        if (s == e) return;\r\n\r\n        m = (s + e) / 2;\r\n        \r\n        //Do not create the children here\r\n    }\r\n\r\n    void create() { \r\n    \r\n        if (s == e) return;       //No children\r\n        if (l != nullptr) return; //exists\r\n        \r\n        //Create if non-existent and has children\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n        \r\n    }\r\n    \r\n    void propo() { \r\n    \r\n        //Create before propo\r\n        create(); \r\n        \r\n        if (lazy != 0) {\r\n            //Update value base on range\r\n            v += lazy * (e - s + 1);\r\n            \r\n            //Propogate\r\n            if (s != e){\r\n                r -> lazy += lazy;\r\n                l -> lazy += lazy;\r\n            }\r\n            \r\n            //Reset value\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    void up(long long x, long long y, long long c) {\r\n        //Propo before update\r\n        \r\n        if (x == s && y == e) {\r\n            lazy += c;\r\n            return;\r\n        }\r\n        else {\r\n        \tpropo();\r\n            if (y <= m) l -> up(x, y, c);\r\n            else if (x > m) r -> up(x, y, c);\r\n            else { l -> up(x, m, c); r -> up(m + 1, y, c); }\r\n            \r\n            //Reminder to propo before updating cur node value\r\n            l -> propo(); r -> propo();\r\n            v = l -> v + r -> v;\r\n        }\r\n\r\n    }\r\n\r\n    long long query(long long x, long long y) {\r\n        //Propo before processing query\r\n        propo();\r\n\r\n        if (s == x && e == y) return v;\r\n        if (x > m) return r -> query(x, y);\r\n        if (y <= m) return l -> query(x, y);\r\n        else return l -> query(x, m) + r -> query(m + 1, y);\r\n    }\r\n} *root;\r\n\r\nsigned main() {\r\n    int n; cin >> n;\r\n    root = new node(0, 1000000005);\r\n    int q; cin >> q;\r\n    int t, l, r, k;\r\n    while(q--) {\r\n        cin >> t;\r\n        if (t == 1) {\r\n            cin >> l >> r >> k;\r\n            root -> up(l, r, k);\r\n        } else {\r\n            cin >> l >> r;\r\n            cout << root -> query(l, r) << endl;\r\n        }\r\n    }\r\n}   "
    },
    {
        "username": "kxd",
        "id": 187650,
        "date": "2022-12-08 01:14:22",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nstruct node {\r\n    long long s, e, m, v;\r\n    long long lazy; //lazy value storage\r\n    \r\n    node *l, *r;\r\n\r\n    node(long long _s, long long _e) {\r\n        s = _s;\r\n        e = _e;\r\n        v = lazy = 0;\r\n        \r\n        if (s == e) return;\r\n\r\n        m = (s + e) / 2;\r\n        \r\n        //Do not create the children here\r\n    }\r\n\r\n    void create() { \r\n    \r\n        if (s == e) return;       //No children\r\n        if (l != nullptr) return; //exists\r\n        \r\n        //Create if non-existent and has children\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n        \r\n    }\r\n    \r\n    void propo() { \r\n    \r\n        //Create before propo\r\n        create(); \r\n        \r\n        if (lazy != 0) {\r\n            //Update value base on range\r\n            v += lazy * (e - s + 1);\r\n            \r\n            //Propogate\r\n            if (s != e){\r\n                r -> lazy += lazy;\r\n                l -> lazy += lazy;\r\n            }\r\n            \r\n            //Reset value\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    void up(long long x, long long y, long long c) {\r\n        //Propo before update\r\n        \r\n        if (x == s && y == e) {\r\n            lazy += c;\r\n            return;\r\n        }\r\n        else {\r\n        \tpropo();\r\n            if (y <= m) l -> up(x, y, c);\r\n            else if (x > m) r -> up(x, y, c);\r\n            else { l -> up(x, m, c); r -> up(m + 1, y, c); }\r\n            \r\n            //Reminder to propo before updating cur node value\r\n            l -> propo(); r -> propo();\r\n            v = l -> v + r -> v;\r\n        }\r\n\r\n    }\r\n\r\n    long long query(long long x, long long y) {\r\n        //Propo before processing query\r\n        propo();\r\n\r\n        if (s == x && e == y) return v;\r\n        if (x > m) return r -> query(x, y);\r\n        if (y <= m) return l -> query(x, y);\r\n        else return l -> query(x, m) + r -> query(m + 1, y);\r\n    }\r\n} *root;\r\n\r\nint main() {\r\n    long long N; scanf(\"%lld\", &N);\r\n    root = new node(0, 1000000005);\r\n    long long Q; scanf(\"%lld\", &Q);\r\n    \r\n    for (long long i = 0; i < Q; i++) {\r\n        long long cmd; scanf(\"%lld\", &cmd);\r\n        if (cmd == 1) {\r\n            long long a, b, c; \r\n            scanf(\"%lld %lld %lld\", &a, &b, &c); \r\n            root -> up(a, b, c);\r\n        }\r\n        if (cmd == 2) {\r\n            long long x, y; scanf(\"%lld %lld\", &x, &y);\r\n            printf(\"%lld\\n\", root -> query(x, y));\r\n        }\r\n    }\r\n}   "
    },
    {
        "username": "kxd",
        "id": 187631,
        "date": "2022-12-08 00:29:03",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define ll long long\r\n#define pb push_back\r\n#define p_q priority_queue\r\n#define m_p make_pair\r\n#define pii pair<int,int>\r\n#define endl '\\n'\r\n#define INIT ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define FOR(i, a, b) for(int i = a; i < b; i++)\r\n#define forn(i, n) for (int i = 0; i < n; i++)\r\n#define f first\r\n#define s second\r\n\r\nusing namespace std;\r\nconst int N = 5e6+5;\r\nconst int INF = 1e18;\r\n\r\nstruct node {\r\n\tint s, e, m, v, lazy;\r\n\tnode *l, *r;\r\n\tnode(int _s, int _e) {\r\n\t\ts = _s;\r\n\t\te = _e;\r\n\t\tm = (s + e) / 2;\r\n\t\tv = 0;\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid subnode() {\r\n\t\tif (s == e) return;\r\n\t\tif (l == NULL || r == NULL) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t\tif (lazy != 0) {\r\n\t\t\tl->v += lazy * (l->e - l->s + 1);\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->v += lazy * (r->e - r->s + 1);\r\n\t\t\tr->lazy += lazy;\r\n\t\t\tlazy = 0;\r\n\t\t}\r\n\t}\r\n\tvoid update(int _l, int _r, int _k) {\r\n\t\tif (_l <= s && _r >= e) {\r\n\t\t\tv += _k * (e - s + 1);\r\n\t\t\tlazy += _k;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsubnode();\r\n\t\tif (_l <= m) l->update(_l, _r, _k);\r\n\t\tif (_r >= m+1) r->update(_l, _r, _k);\r\n\t\tv = l->v + r->v;\r\n\t}\r\n\tint query(int _l, int _r) {\r\n\t\tif (_l <= s && _r >= e) \r\n\t\t\treturn v;\r\n\t\tsubnode();\r\n\t\tint ans = 0;\r\n\t\tif (_l <= m) ans += l->query(_l, _r);\t\t\r\n\t\tif (_r >= m+1) ans += r->query(_l, _r);\r\n\t\treturn ans;\r\n\t}\r\n} *root;\r\n\r\nsigned main() {\r\n\tINIT\r\n\tint N, Q, op, l, r, k;\r\n\tcin >> N >> Q;\r\n\troot = new node(1, N);\r\n\twhile (Q--) {\r\n\t\tcin >> op >> l >> r;\r\n\t\tif (op == 1) {\r\n\t\t\tcin >> k;\r\n\t\t\troot->update(l, r, k);\r\n\t\t} else {\r\n\t\t\tcout << root->query(l, r) << endl;\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "bisp",
        "id": 187630,
        "date": "2022-12-08 00:28:26",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node {\r\n\tint s, e, m, v, lazy;\r\n\tnode *l, *r;\r\n\t\r\n\tnode(int _s, int _e) {\r\n\t\ts = _s;\r\n\t\te = _e;\r\n\t\tm = (s + e) / 2;\r\n\t\tv = 0;\r\n\t\tlazy = 0;\r\n\t\tl = 0;\r\n\t\tr = 0;\r\n\t}\r\n\t\r\n\tvoid subnode() {\r\n\t\tif (s == e) return;\r\n\t\t\r\n\t\tif (l == NULL) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t\tif (lazy != 0) {\r\n\t\t\tl->v += lazy * (l->e - l->s + 1);\r\n\t\t\tl->lazy += lazy;\r\n\t\t\t\r\n\t\t\tr->v += lazy * (r->e - r->s + 1);\r\n\t\t\tr->lazy += lazy;\r\n\t\t\t\r\n\t\t\tlazy = 0;\r\n\t\t}\r\n\t}\r\n\tvoid update(int _l, int _r, int _k) {\r\n\t\tif (_l <= s && _r >= e) {\r\n\t\t\tv += _k * (e - s + 1);\r\n\t\t\tlazy += _k;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tsubnode();\r\n\t\t\r\n\t\tif (_l <= m) \tl->update(_l, _r, _k);\r\n\t\tif (_r >= m+1) \tr->update(_l, _r, _k);\r\n\t\tv = l->v + r->v;\r\n\t}\r\n\t\r\n\tint query(int _l, int _r) {\r\n\t\tif (_l <= s && _r >= e) \r\n\t\t\treturn v;\r\n\t\t\r\n\t\tsubnode();\r\n\t\t\r\n\t\tint ans = 0;\r\n\t\tif (_l <= m) \tans += l->query(_l, _r);\t\t\r\n\t\tif (_r >= m+1)\tans += r->query(_l, _r);\r\n\t\treturn ans;\r\n\t}\r\n} *root;\r\n\r\nsigned main() {\r\n\tios_base::sync_with_stdio(0);  cin.tie(0); cout.tie(0);\r\n\t\r\n\tint N, Q, op, l, r, k;\r\n\tcin >> N >> Q;\r\n\t\r\n\troot = new node(1, N);\r\n\twhile (Q--) {\r\n\t\tcin >> op >> l >> r;\r\n\t\tif (op == 1) {\r\n\t\t\tcin >> k;\r\n\t\t\troot->update(l, r, k);\r\n\t\t} else {\r\n\t\t\tcout << root->query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn 0;\r\n}"
    },
    {
        "username": "leyi",
        "id": 187506,
        "date": "2022-12-07 20:50:27",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node{\r\n\tint s,e,m,val,lazy;\r\n\tnode *l, *r;\r\n\t\r\n\tnode(int S, int E){\r\n\t\ts=S, e=E, m=(s+e)/2;\r\n\t\tval=0;\r\n\t\tlazy=0;\r\n\t}\r\n\t\r\n\tvoid create(){\r\n\t\tif(s!=e){\r\n\t\t\tl = new node(s,m);\r\n\t\t\tr = new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid propo(){\r\n\t\tif(l==nullptr) create();\r\n\t\tif(lazy==0) return;\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\t\r\n\tvoid update(int S, int E, int V){\r\n\t\tif(s==S and e==E) lazy+=V;\r\n\t\telse{\r\n\t\t\tif(l==nullptr) create();\r\n\t\t\tif(E<=m) l->update(S,E,V);\r\n\t\t\telse if(S>m) r->update(S,E,V);\r\n\t\t\telse l->update(S,m,V), r->update(m+1,E,V);\r\n\t\t\t\r\n\t\t\tl->propo(); r->propo();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\t\r\n\tint query(int S, int E){\r\n\t\tif(l==nullptr) create();\r\n\t\tpropo();\r\n\t\tif(s==S and e==E) return val;\r\n\t\telse if(E<=m) return l->query(S,E);\r\n\t\telse if(S>m) return r->query(S,E);\r\n\t\telse return l->query(S,m) + r->query(m+1,E);\r\n\t}\r\n} *root;\r\n\r\nsigned main(){\r\n\tios::sync_with_stdio(0); cin.tie(0);\r\n\t\r\n\tint n,q; cin>>n>>q;\r\n\troot = new node(1,n);\r\n\tfor(int i=0; i<q; i++){\r\n\t\tint a; cin>>a;\r\n\t\tif(a==1){\r\n\t\t\tint b,c,d; cin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}else{\r\n\t\t\tint b,c; cin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn 0;\r\n}"
    },
    {
        "username": "wy",
        "id": 187409,
        "date": "2022-12-07 17:52:22",
        "code": "// solving segmenttree2\r\n#include <bits/stdc++.h>\r\n#define int long long\r\n#define endl '\\n'\r\n#define fast ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n#define ping cout << \"pong\\n\";\r\nusing namespace std;\r\nstruct node {\r\n    int s, e, m, val, lazy;\r\n    node *l = nullptr, *r = nullptr;\r\n\r\n    node (int S, int E) {\r\n        s = S, e = E, m = (s + e) / 2;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n\r\n    void create() {\r\n        if (s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n\r\n    void propagate() {\r\n        if (lazy == 0) return;\r\n        val += lazy * (e - s + 1);\r\n        if (s != e) {\r\n            if (l == nullptr) create();\r\n            l -> lazy += lazy;\r\n            r -> lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\n    void update(int S, int E, int V) {\r\n        if (l == nullptr) create();\r\n        if (s == S && e == E) {\r\n            lazy += V; return;\r\n        } else {\r\n            if (S > m) r -> update(S, E, V);\r\n            else if (E < m+1) l -> update(S, E, V);\r\n            else {\r\n                l -> update(S, m, V);\r\n                r -> update(m+1, E, V);\r\n            }\r\n            l -> propagate(); r -> propagate();\r\n            val = l -> val + r -> val;\r\n        }\r\n    }\r\n\r\n    int query(int S, int E) {\r\n        if (l == nullptr) create();\r\n        propagate();\r\n        if (s == S && e == E) return val;\r\n        else if (S > m) return r -> query(S, E);\r\n        else if (E <= m) return l -> query(S, E);\r\n        else return l -> query(S, m) + r -> query(m+1, E);\r\n    }\r\n} * root;\r\n\r\nsigned main() {\r\n    fast;\r\n    int n, q; cin >> n >> q;\r\n    root = new node(1, n+1);\r\n    while (q--) {\r\n        int que, l, r; cin >> que >> l >> r;\r\n        if (que == 1) {\r\n            int v; cin >> v;\r\n            root -> update(l, r, v);\r\n        } else if (que == 2) {\r\n            cout << root -> query(l, r) << endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "bobthebill1",
        "id": 187277,
        "date": "2022-12-07 16:11:13",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define endl \"\\n\"\r\n#define FOR(i,a,n) for(int i=a;i<n;i++)\r\n#define f first\r\n#define se second\r\ntypedef pair<int, int> pi;\r\ntypedef pair<pi, int> pii;\r\n\r\nint N, Q, cmd, a, b,c;\r\n\r\nstruct node{\r\n\tint s,e,m, val,lazy;\r\n\tnode *l, *r;\r\n\t\r\n\tnode(int S, int E){\r\n\t\ts=S, e=E, m = (s+e)/2;\r\n\t\tval = 0;\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(s!=e){\r\n\t\t\tl=new node(s,m);\r\n\t\t\tr=new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\tvoid propagate(){\r\n\t\tif (l==nullptr) create();\r\n\t\tif(lazy==0) return;\r\n\t\t\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif (s!=e){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\t\r\n\t\r\n\tvoid update(int S, int E, int V){\r\n\t\tif (l==nullptr) create();\r\n\t\tif (s==S&&e==E) lazy+=V;\r\n\t\telse{\r\n\t\t\tif (E <= m) l->update(S,E,V);\r\n\t\t\telse if (m<S) r->update(S,E,V);\r\n\t\t\telse l->update(S,m,V), r->update(m+1,E,V);\r\n\t\t\t\r\n\t\t\tl->propagate(), r->propagate();\r\n\t\t\tval = l->val+r->val;\r\n\t\t}\r\n\t}\t\r\n\t\r\n\tint query(int S, int E){\r\n\t\tif (l==nullptr) create();\r\n\t\tpropagate();\r\n\t\t\r\n\t\tif(S==s&&E==e) return val;\r\n\t\telse if (E <=m) return l->query(S,E);\r\n\t\telse if (S>m) return r->query(S, E);\r\n\t\telse return l->query(S, m)+r->query(m+1, E);\r\n\t}\r\n\t\r\n}*root;\r\n\r\nint32_t main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\t\r\n\tcin >> N >> Q;\r\n\troot = new node(1,N);\r\n\tFOR(i,0,Q){\r\n\t\tcin >> cmd;\r\n\t\tif (cmd == 1){\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\troot->update(a,b,c);\r\n\t\t}\r\n\t\telse if (cmd == 2){\r\n\t\t\tcin >> a >> b;\r\n\t\t\tint A = root->query(a,b);\r\n\t\t\tcout << A << endl;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n"
    },
    {
        "username": "zyh255",
        "id": 187268,
        "date": "2022-12-07 16:05:40",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n// lazy propagation for RURQ segment tree\r\nstruct node {\r\n    int s, e, m; // range + split point\r\n    int val, lazy; // sum of [s, e]\r\n    node *l, *r;\r\n\r\n    void create() {\r\n        if (s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n\r\n    void propogate() {\r\n        if (l == nullptr) create();\r\n        if (lazy == 0) return;\r\n\r\n        val += lazy * (e - s + 1);\r\n        if (s != e) {\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n    node (int S, int E) {\r\n        s = S, e = E; m = (s+e) / 2, lazy = 0;\r\n        val = 0;\r\n    }\r\n\r\n    void update (int S, int E, int V) {\r\n        if (l == nullptr) create();\r\n\r\n        if (s == S && e == E) lazy += V;\r\n        else {\r\n            if (E <= m) l->update(S, E, V);\r\n            else if (m < S) r->update(S, E, V);\r\n            else l->update(S, m, V), r->update(m+1, E, V);\r\n\r\n            l->propogate(), r->propogate();\r\n\r\n            val = l->val + r->val;\r\n        }\r\n    }\r\n    \r\n    int query (int S, int E) {\r\n        if (l == nullptr) create();\r\n\r\n        propogate();\r\n\r\n        if (s == S && e == E) return val;\r\n        else if (E <= m) return l->query(S, E);\r\n        else if (S >= m+1) return r->query(S, E);\r\n        else return l->query(S, m) + r->query(m+1, E);\r\n    }\r\n};\r\nint32_t main() {\r\n    ios_base::sync_with_stdio(0); cin.tie(0);\r\n\r\n    int n, q; cin >> n >> q;\r\n    node* root = new node(1, n);\r\n\r\n    for (int i = 0; i < q; i++) {\r\n        int t; cin >> t;\r\n\r\n        if (t == 2) {\r\n            int x, y; cin >> x >> y;\r\n            cout << root->query(x, y) << \"\\n\";\r\n        } else {\r\n            int a, b, c; cin >> a >> b >> c;\r\n            root->update(a, b, c);\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "Celenium",
        "id": 187264,
        "date": "2022-12-07 16:01:42",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long \r\nstruct node{\r\n    int s,e,m;\r\n    int val,lazy;\r\n    node *l,*r;\r\n\t\r\n    node(int S, int E){\r\n        s=S,e=E,m=(s+e)/2;\r\n        val=lazy=0;\r\n        l=r=nullptr;\r\n    }\r\n    void create(){\r\n\t\t\r\n        if(s!=e){\r\n            l=new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n    void propogate(){\r\n        if(lazy==0)return;\r\n        val+=lazy*(e-s+1);\r\n        if(s!=e){\r\n\t\t\tif(l==nullptr)create();\r\n\t\t\t\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n\r\n        lazy=0;\r\n    }\r\n    void update(int S, int E, int V){\r\n        if(l==nullptr)create();\r\n        if(s==S&&e==E)lazy+=V;\r\n        else{\r\n            if(E<=m)l->update(S,E,V);\r\n            else if(m<S)r->update(S,E,V);\r\n            else l->update(S,m,V),r->update(m+1,E,V);\r\n            l->propogate(),r->propogate();\r\n            val=l->val+r->val;\r\n        }\r\n    }\r\n    int query(int S, int E){\r\n\t\tif(l==nullptr)create();\r\n        propogate();\r\n        if(s==S&&e==E)return val;\r\n        else if(E<=m)return l->query(S,E);\r\n        else if(S>m)return r->query(S,E);\r\n        else return l->query(S,m)+r->query(m+1,E);\r\n    }\r\n} *root;\r\nint32_t main(){\r\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\r\n    int n,q;\r\n    cin>>n>>q;\r\n    root=new node(1,n+1);\r\n    while(q--){\r\n        int t,l,r,v;\r\n        cin>>t>>l>>r;\r\n        if(t==1){\r\n            cin>>v;\r\n            root->update(l,r,v);\r\n        }\r\n        else cout<<root->query(l,r)<<endl;\r\n    }\r\n}"
    },
    {
        "username": "jeongwonho64",
        "id": 187254,
        "date": "2022-12-07 15:58:29",
        "code": "#pragma GCC optimize(\"O3,unroll-loops\")\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define double long double\r\n#define endl '\\n'\r\n#define all(x) (x).begin(), (x).end()\r\n#define pb push_back\r\n#define fi first\r\n#define se second\r\n#define sz(x) (int)(x).size()\r\n#define speed                     \\\r\n\tios_base::sync_with_stdio(0); \\\r\n\tcin.tie(0);                   \\\r\n\tcout.tie(0)\r\n#define pi pair<long long, long long>\r\n#define pii pair<long long, pi>\r\ntemplate <class T>\r\nusing v = vector<T>;\r\n#ifdef DEBUG\r\ntemplate <typename T>\r\ninline void debug(T x)\r\n{\r\n\tcout << x << \" \";\r\n}\r\ntemplate <typename T, typename... Args>\r\ninline void debug(T x, Args... args)\r\n{\r\n\tcout << x << \" | \";\r\n\tdebug(args...);\r\n}\r\n#define debug(...)                         \\\r\n\tcout << \"[\" << #__VA_ARGS__ << \"] : \"; \\\r\n\tdebug(__VA_ARGS__);                    \\\r\n\tcout << endl\r\n#endif\r\n#ifndef DEBUG\r\ntemplate <typename T>\r\ninline void debug(T x){}\r\ntemplate <typename T, typename... Args>\r\ninline void debug(T x, Args... args) {}\r\n#define debug(...)\r\n#endif\r\nostream &operator<<(ostream &o_str, const v<int> &p)\r\n{\r\n\to_str << \"{ \";\r\n\tfor (auto i = 0; i < (int)p.size(); i++)\r\n\t{\r\n\t\to_str << p[i];\r\n\t\tif (i < (int)p.size() - 1)\r\n\t\t{\r\n\t\t\to_str << \", \";\r\n\t\t}\r\n\t}\r\n\treturn o_str << \" }\";\r\n}\r\n\r\nstruct node\r\n{\r\n\tint start, end, middle, val, lazy;\r\n\tnode *left = nullptr;\r\n\tnode *right = nullptr;\r\n\tnode(int s, int e)\r\n\t{\r\n\t\tstart = s, end = e, middle = (start + end) / 2;\r\n\t\tval = 0;\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid create()\r\n\t{\r\n\t\tif (start != end){\r\n\t\t\tleft = new node(start, middle);\r\n\t\t\tright = new node(middle + 1, end);\r\n\t\t}\r\n\t}\r\n\tvoid propogate()\r\n\t{\r\n\t\tif (lazy == 0)return;\r\n\t\tval += (end - start + 1) * lazy;\r\n\t\tif (start != end){\r\n\t\t\tif(left == nullptr)create();\r\n\t\t\tleft->lazy += lazy;\r\n\t\t\tright->lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid update(int s,int e, int value)\r\n\t{\r\n\t\tif(left == nullptr)create();\r\n\t\tif(start == s && end == e){\r\n\t\t\tlazy += value;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tif(s > middle)right->update(s,e,value);\r\n\t\t\telse if(e <= middle)left->update(s,e,value);\r\n\t\t\telse{\r\n\t\t\t\tleft->update(s,middle,value);\r\n\t\t\t\tright->update(middle+1,e,value);\r\n\t\t\t}\r\n\t\t\tleft->propogate();\r\n\t\t\tright->propogate();\r\n\t\t\tval = left->val + right->val;\r\n\t\t}\r\n\t}\r\n\tint query(int s, int e)\r\n\t{\r\n\t\tif(left == nullptr)create();\r\n\t\tpropogate();\r\n\t\tif(start == s && end == e)return val;\r\n\t\telse if (s > middle)return right->query(s, e);\r\n\t\telse if (e <= middle)return left->query(s, e);\r\n\t\telse return left->query(s, middle) + right->query(middle + 1, e);\r\n\t}\r\n} * root;\r\n\r\nsigned main(int32_t argc, char *argv[])\r\n{\r\n\t// FILE *in = freopen(argv[1], \"r\", stdin);\r\n\t#ifdef DEBUG\r\n\t\tauto start = chrono::steady_clock::now();\r\n\t#endif\r\n\tspeed;\r\n\tint n, q;\r\n\tcin >> n >> q;\r\n\troot = new node(1, n+1);\r\n\twhile (q--)\r\n\t{\r\n\t\tint t, l, r;\r\n\t\tcin >> t >> l >> r;\r\n\t\tif (t == 1)\r\n\t\t{\r\n\t\t\tint x;\r\n\t\t\tcin >> x;\r\n\t\t\troot->update(l, r, x);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << root->query(l, r) << endl;\r\n\t\t}\r\n\t}\r\n\t#ifdef DEBUG\r\n\t\tauto end = chrono::steady_clock::now();\r\n\t\tauto diff = end - start;\r\n\t\tcout << chrono::duration<double, milli>(diff).count() << \" ms\" << endl;\r\n\t#endif\r\n}"
    },
    {
        "username": "Gladius3482",
        "id": 187252,
        "date": "2022-12-07 15:56:35",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n\tint s,e,m,lazy; \r\n\tint val;\r\n\tnode *l,*r;\r\n\tnode(int S,int E){\r\n\t\ts=S;e=E;m=(s+e)/2;\r\n\t\tval=0;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(s!=e){\r\n\t\t\tl = new node(s,m);\r\n\t\t\tr =new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif(l==nullptr)create();\r\n\t\tif(lazy==0)return;\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\tvoid update(int S,int E,int V){\r\n\t\tpropogate();\r\n\t\tif(s==S&&e==E)lazy+=V;\r\n\t\telse{\r\n\t\t\tif(E<=m)l->update(S,E,V);\r\n\t\t\telse if(m<S)r->update(S,E,V);\r\n\t\t\telse l->update(S,m,V),r->update(m+1,E,V);\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\tval=l->val+r->val;\r\n\t\t}\r\n\t}\r\n\tint query(int S, int E){\r\n\t\tpropogate();\r\n\t\tif(s==S&e==E)return val;\r\n\t\telse if (E<=m)return l->query(S,E);\r\n\t\telse if (S>=m+1)return r->query(S,E);\r\n\t\telse return l->query(S,m)+r->query(m+1,E);\r\n\t}\r\n}*root;\r\nsigned main(){\r\n\tios::sync_with_stdio(0);cin.tie(0);\r\n\tint n,q;cin>>n>>q;\r\n\troot = new node(1,n);\r\n\tfor(int i=0;i<q;++i){\r\n\t\tint a;cin>>a;\r\n\t\tint b,c;cin>>b>>c;\r\n\t\tif(a==1){\r\n\t\t\tint d;cin>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout<<root->query(b,c)<<'\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "tux",
        "id": 187157,
        "date": "2022-12-07 15:14:39",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define FOR(a,b,c)for(int a=b;a<c;a++)\r\n#define mp make_pair\r\n#define pb push_back\r\n#define pii pair<int,int>\r\n\r\nstruct ST {\r\n\tint s,m,e;\r\n\tint v,lazy;\r\n\tstruct ST *l, *r;\r\n\r\n\tST(int _s, int _e)\r\n\t{\r\n\t\ts=_s;e=_e;m=s+e>>1;\r\n\t\tv=0;\r\n\t\tlazy=0;\r\n\t\tl=r=NULL;\r\n\t}\r\n\r\n\tint force()\r\n\t{\r\n\t\tif(s!=e)if(!l)l=new ST(s,m),r=new ST(m+1,e);\r\n\t\tif(!lazy)return v;\r\n\t\tv+=lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t\treturn v;\r\n\t}\r\n\r\n\tvoid update(int _s, int _e, int x)\r\n\t{\r\n\t\tforce();\r\n\t\tif(s==_s&&e==_e) lazy+=x;\r\n\t\telse if (_e <= m) l->update(_s,_e,x);\r\n\t\telse if (_s > m) r->update(_s,_e,x);\r\n\t\telse {\r\n\t\t\tl->update(_s,m,x);\r\n\t\t\tr->update(m+1,_e,x);\r\n\t\t}\r\n\t\tif(s!=e)v=l->force() + r->force();\r\n\t}\r\n\r\n\tint query(int _s, int _e)\r\n\t{\r\n\t\tforce();\r\n\t\tif(s==e||(s==_s&&e==_e)) return v;\r\n\t\telse if (_e <= m) return l->query(_s,_e);\r\n\t\telse if (_s > m) return r->query(_s,_e);\r\n\t\telse {\r\n\t\t\treturn l->query(_s,m)+r->query(m+1,_e);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nint N,Q;\r\nsigned main(void)\r\n{\r\n\tios_base::sync_with_stdio(0);cin.tie(0);\r\n\tcin>>N>>Q;\r\n\tstruct ST *st = new ST(1,1e9+5);\r\n\tFOR(i,0,Q){\r\n\t\tint t;cin>>t;\r\n\t\tif(t==1){int l,r,k;cin>>l>>r>>k;st->update(l,r,k);}\r\n\t\telse {int l,r;cin>>l>>r;cout<<st->query(l,r)<<'\\n';}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "lolbeast",
        "id": 187132,
        "date": "2022-12-07 15:01:52",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node {\r\n    node *l, *r;\r\n    int val, lazy;\r\n    node(): val(0), l(NULL), r(NULL), lazy(0){}\r\n    int value(int s, int e){\r\n        val += (e-s+1) * lazy;\r\n        if (s==e){\r\n            lazy = 0;\r\n            return val;\r\n        }\r\n        if (l == NULL) l = new node();\r\n        l->lazy += lazy;\r\n        if (r == NULL) r = new node();\r\n        r->lazy += lazy;\r\n        lazy = 0;\r\n        return val;\r\n    }\r\n    void update(int s, int e, int x, int y, int v) {\r\n        int m = (s + e) / 2;\r\n        if (s==x && e==y){\r\n           lazy += v;\r\n           return;\r\n        }\r\n        if (y <= m){\r\n            if (l == NULL) l = new node();\r\n            l->update(s, m, x, y, v);\r\n        } else if (x > m){\r\n            if (r == NULL) r = new node();\r\n            r->update(m+1, e, x, y, v);\r\n        } else {\r\n            if (l==NULL) l = new node();\r\n            if (r==NULL) r = new node();\r\n            l->update(s, m, x, m, v);\r\n            r->update(m+1, e, m+1, y, v);\r\n        }\r\n        val = (l==NULL?0:l->value(s, m)) + (r==NULL?0:r->value(m+1, e));\r\n    }\r\n    int query(int s, int e, int x, int y) {\r\n        value(s, e);\r\n        if (s == x && e == y) return val;\r\n        int m = (s + e) / 2;\r\n        if (x > m) return (r==NULL)? 0:r->query(m + 1, e, x, y);\r\n        if (y <= m) return (l==NULL)? 0:l->query(s, m, x, y);\r\n        if (l == NULL && r != NULL) return r->query(m+1, e, m+1, y);\r\n        if (l != NULL && r == NULL) return l->query(s, m, x, m);\r\n        if (l != NULL && r != NULL) return l->query(s, m, x, m) + r->query(m+1, e, m+1, y); //Change here for max\r\n        return 0;\r\n    }\r\n} *root;\r\nmain(){\r\n    int n, q; cin >> n >> q;\r\n    root = new node();\r\n    while (q--){\r\n        int t; cin >> t;\r\n        if (t == 1){\r\n            int a, b, c; cin >> a >> b >> c;\r\n            root->update(1, n, a, b, c);\r\n        } else {\r\n            int a, b; cin >> a >> b;\r\n            cout << root->query(1, n, a, b) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "haydendoo",
        "id": 187115,
        "date": "2022-12-07 14:53:21",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int mxN=1e9;\r\n\r\ntypedef long long ll;\r\n#define int ll\r\n\r\n#define sus int m=(s+e)>>1;\r\n\r\nstruct node {\r\n\tint s,e,v;\r\n\tint lz;\r\n\tnode *l, *r;\r\n\tnode(int _S, int _E): s(_S), e(_E), v(0), lz(0), l(NULL), r(NULL) {}\r\n\tinline void push() {\r\n\t\tif(lz==0 || s==e) return;\r\n\t\tl->lz += lz; l->v += lz*(l->e - l->s + 1);\r\n\t\tr->lz += lz; r->v += lz*(r->e - r->s + 1); lz=0;\r\n\t}\r\n\tinline void create() {\r\n\t\tif(s==e || l!=NULL) return;\r\n\t\tsus\r\n\t\tl = new node(s,m);\r\n\t\tr = new node(m+1,e);\r\n\t}\r\n\tvoid upd(int x, int y, int v2) {\r\n\t\tif(s==x && e==y) {\r\n\t\t\tlz += v2;\r\n\t\t\tv += v2*(e-s+1);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tsus\r\n\t\tcreate(); push();\r\n\t\tif(x<=m) l->upd(x,min(y,m),v2);\r\n\t\tif(y>m) r->upd(max(x,m+1),y,v2);\r\n\t\tv = l->v + r->v;\r\n\t}\r\n\tint query(int x, int y) {\r\n\t\tif(s==x && e==y) return v;\r\n\t\tif(l==NULL) return (v / (e-s+1)) * (y-x+1);\r\n\t\tsus\r\n\t\tpush();\r\n\t\tif(y<=m) return l->query(x,y);\r\n\t\tif(x>m) return r->query(x,y);\r\n\t\treturn l->query(x,m) + r->query(m+1,y);\r\n\t}\r\n} *root;\r\n\r\nmain() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint q, n;\r\n\troot = new node(0, mxN);\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; ++i){\r\n\t\tint type;\r\n\t\tcin >> type;\r\n\t\tif(type==1){\r\n\t\t\tint l, r, v;\r\n\t\t\tcin >> l >> r >> v;\r\n\t\t\troot->upd(l-1,r-1,v);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->query(l-1,r-1) << '\\n';\r\n\t\t}\r\n\t}\r\n} \r\n/*\r\n5 5 \r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/"
    },
    {
        "username": "ThePwo",
        "id": 187089,
        "date": "2022-12-07 14:38:06",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node {\r\n\tint s, e, m, val, lazy;\r\n\tnode *l, *r;\r\n\t\r\n\tnode(int S, int E) {\r\n\t\ts = S, e = E, m = (s + e) / 2;\r\n\t\tval = lazy = 0;\r\n\t}\r\n\t\r\n\tvoid create() {\r\n\t\tif (s != e) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m + 1, e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid propogate() {\r\n\t\tif (l == nullptr) create();\r\n\t\tif (lazy == 0) return;\r\n\t\tval += lazy * (e - s + 1);\r\n\t\tif (s != e) {\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\t\r\n\tvoid update(int S, int E, int V) {\r\n\t\tif (l == nullptr) create();\r\n\t\tif (s == S && e == E) lazy += V;\r\n\t\telse {\r\n\t\t\tif (E <= m) l->update(S, E, V);\r\n\t\t\telse if (m < S) r->update(S, E, V);\r\n\t\t\telse l->update(S, m, V), r->update(m + 1, E, V);\r\n\t\t\tl->propogate(), r->propogate();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\t\r\n\tint query(int S, int E) {\r\n\t\tif (l == nullptr) create();\r\n\t\tpropogate();\r\n\t\tif (s == S && e == E) return val;\r\n\t\telse if (E <= m) return l->query(S, E);\r\n\t\telse if (S >= m + 1) return r->query(S, E);\r\n\t\telse return l->query(S, m) + r->query(m + 1, E);\r\n\t}\r\n} *root;\r\n\r\nint32_t main() {\r\n\tios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n\tint n, q; cin >> n >> q;\r\n\troot = new node(1, n);\r\n\twhile (q--) {\r\n\t\tint t, a, b, c; cin >> t;\r\n\t\tif (t == 1) {\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\troot->update(a, b, c);\r\n\t\t} else {\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << root->query(a, b) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "hmm",
        "id": 181237,
        "date": "2022-11-29 22:36:26",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define INF 1000000000000000000\r\n#define MOD 1000000007\r\n\r\nstruct node {\r\n\tint s, e, m, v, lz;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\tnode(int _s, int _e) {\r\n\t\ts = _s, e = _e, m = (s+e)/2, v = 0, lz = 0;\r\n\t}\r\n\tvoid create() {\r\n\t\tif(s != e) {\r\n\t\t\tif(l == nullptr) l = new node(s, m);\r\n\t\t\tif(r == nullptr) r = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\tvoid prop() {\r\n\t\tif(lz == 0) return;\r\n\t\tv += lz*(e-s+1);\r\n\t\tif(s != e) {\r\n\t\t\tcreate();\r\n\t\t\tl->lz += lz;\r\n\t\t\tr->lz += lz;\r\n\t\t}\r\n\t\tlz = 0;\r\n\t}\r\n\tvoid update(int x, int y, int val) {\r\n\t\tif(x <= s && e <= y) lz += val;\r\n\t\telse {\r\n\t\t\tcreate();\r\n\t\t\tif(x > m) r->update(x, y, val);\r\n\t\t\telse if(y <= m) l->update(x, y, val);\r\n\t\t\telse l->update(x, y, val), r->update(x, y, val);\r\n\t\t\tl->prop(), r->prop();\r\n\t\t\tv = l->v + r->v;\r\n\t\t}\r\n\t}\r\n\tint rsum(int x, int y) {\r\n\t\tprop();\r\n\t\tif(x <= s && e <= y) return v;\r\n\t\telse if(x > m) return r==nullptr?0:r->rsum(x, y);\r\n\t\telse if(y <= m) return l==nullptr?0:l->rsum(x, y);\r\n\t\telse return (l==nullptr?0:l->rsum(x, y))+(r==nullptr?0:r->rsum(x, y));\r\n\t}\r\n} *root;\r\n\r\nint32_t main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0); cout.tie(0);\r\n\tint n, q, a, b, c;\r\n\tcin >> n >> q;\r\n\troot = new node(1, n);\r\n\tfor(int i = 0; i < q; i++) {\r\n\t\tcin >> a;\r\n\t\tif(a == 1) {\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\troot->update(a, b, c);\r\n\t\t} else {\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << root->rsum(a, b) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "chenweilian",
        "id": 179803,
        "date": "2022-11-28 20:13:46",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint n;\r\nunordered_map<long, long> f1, f2;\r\nvoid add(int p, long x) {\r\n    for(int i = p; i <= n; i += i & -i) {\r\n        f1[i] += x; f2[i] += x*p;\r\n    }\r\n}\r\nlong sum(int p) {\r\n    long res = 0;\r\n    for(int i = p; i; i -= i & -i) {\r\n        res += (p+1)*f1[i] - f2[i];\r\n    }\r\n    return res;\r\n}\r\nint main() {\r\n    ios::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n    int comm, q, a = 0, b = 0, c = 0;\r\n    cin>>n>>comm;\r\n    for(int i = 1; i <= comm; i++) {\r\n        cin>>q;\r\n        if(q == 1) {\r\n            cin>>a>>b>>c;\r\n            add(a, c);\r\n            add(b+1, -c);\r\n        }\r\n        else if(q == 2) {\r\n            cin>>a>>b;\r\n            cout<<sum(b)-sum(a-1)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "aufan",
        "id": 176054,
        "date": "2022-11-24 21:43:15",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define fi first\r\n#define se second\r\n#define all(x) (x).begin(), (x).end()\r\n\r\nusing namespace std;\r\nint n, q;\r\nstruct node {\r\n        int val, lazy, len;\r\n        int st, en;\r\n        node *left, *right;\r\n        void build(int start, int end) {\r\n                st = start;\r\n                en = end;\r\n                len = en - st + 1;\r\n                val = 0;\r\n                return;\r\n        }\r\n        void lz() {\r\n                if (left == NULL) {\r\n                        int md = (st + en)/2;\r\n                        left = new node();\r\n                        right = new node();\r\n                        left->build(st, md);\r\n                        right->build(md + 1, en);\r\n                }\r\n                if (lazy != 0) {\r\n                        if (st != en) {\r\n                                left->lazy += lazy;\r\n                                left->val += lazy*left->len;\r\n                                right->lazy += lazy;\r\n                                right->val += lazy*right->len;\r\n                        }\r\n                        lazy = 0;\r\n                }\r\n        }\r\n        int query(int lf, int rg) {\r\n                if (st > rg || en < lf) return 0;\r\n                if (lf <= st && en <= rg) return val;\r\n                lz();\r\n                return left->query(lf, rg) + right->query(lf, rg);\r\n        }\r\n        void update(int lf, int rg, int x) {\r\n                if (st > rg || en < lf) return;\r\n                if (lf <= st && en <= rg) {\r\n                        lazy += x;\r\n                        val += x*len;\r\n                        return;\r\n                }\r\n                lz();\r\n                left->update(lf, rg, x);\r\n                right->update(lf, rg, x);\r\n                val = left->val + right->val;\r\n        }       \r\n} sg;\r\n\r\nint32_t main()\r\n{\r\n        ios_base::sync_with_stdio(false);\r\n        cin.tie(NULL);\r\n        cin >> n >> q;\r\n        sg.build(1, n);\r\n        for (int i = 0; i < q; i++) {\r\n                int t, l, r;\r\n                cin >> t >> l >> r;\r\n                if (t == 1) {\r\n                        int k;\r\n                        cin >> k;\r\n                        sg.update(l, r, k);\r\n                } else {\r\n                        cout << sg.query(l, r) << '\\n';\r\n                }\r\n        }\r\n        return 0;\r\n}"
    },
    {
        "username": "TheRaptor",
        "id": 174202,
        "date": "2022-11-22 15:10:44",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nstruct node{\r\n\tnode *l,*r;\r\n\tlong long val,lazy;\r\n\tint s,e,mid;\r\n\tnode(int S, int E){\r\n\t\ts=S; e=E; mid=(S+E)/2; lazy=val=0;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(s!=e&&l==NULL){\r\n\t\t\tl=new node(s,mid);\r\n\t\t\tr=new node(mid+1,e);\r\n\t\t}\r\n\t}\r\n\tvoid propagate(){\r\n\t\tcreate();\r\n\t\tval += lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\t\r\n\tvoid update(int S, int E, long long V){\r\n\t\tif(S==s&&E==e) lazy+=V;\r\n\t\telse{\r\n\t\t\tcreate();\r\n\t\t\tif(E<=mid) l->update(S,E,V);\r\n\t\t\telse if(S>mid) r->update(S,E,V);\r\n\t\t\telse{\r\n\t\t\t\tl->update(S,mid,V);\r\n\t\t\t\tr->update(mid+1,E,V);\r\n\t\t\t}\r\n\t\t\tl->propagate();\r\n\t\t\tr->propagate();\r\n\t\t\tval=l->val+r->val;\r\n\t\t}\r\n\t}\r\n\tlong long query(int S, int E){\r\n\t\tpropagate();\r\n\t\tcreate();\r\n\t\tif(S==s&&E==e) return val;\r\n\t\telse if(E<=mid) return l->query(S,E);\r\n\t\telse if(S>mid) return r->query(S,E);\r\n\t\telse return l->query(S,mid)+r->query(mid+1,E);\r\n\t}\r\n} *root;\r\nint main(){\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(nullptr);\r\n\troot=new node(1,1e9);\r\n\tint n,q;\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; i++){\r\n\t\tint a,b,c;\r\n\t\tcin >> a >> b >> c;\r\n\t\tif(a==1){\r\n\t\t\tint d;\r\n\t\t\tcin >> d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << root->query(b,c) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "aufan",
        "id": 171927,
        "date": "2022-11-19 23:02:59",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define fi first\r\n#define se second\r\n#define all(x) (x).begin(), (x).end()\r\n#define N 222222\r\nconst int INF = 1e9;\r\nusing namespace std;\r\nvector<int> a;\r\nint n, q;\r\nstruct node {\r\n        int val, lazy, len;\r\n        int st, en;\r\n        node *left, *right;\r\n        void build(int start, int end) {\r\n                st = start;\r\n                en = end;\r\n                if (st == en) {\r\n                        len = a[en] - a[st-1];\r\n                        return;\r\n                }\r\n                int m = (st + en)/2;\r\n                left = new node();\r\n                right = new node();\r\n                left->build(st, m);\r\n                right->build(m + 1, en);\r\n                len = left->len + right->len;\r\n                return;\r\n        }\r\n        int qr(int lf, int rg) {\r\n                if (lazy != 0) {\r\n                        val += lazy*len;\r\n                        if (st != en) {\r\n                                left->lazy += lazy;\r\n                                right->lazy += lazy;\r\n                        }\r\n                        lazy = 0;\r\n                }\r\n                if (st > rg || en < lf) return 0;\r\n                if (lf <= st && en <= rg) return val;\r\n                return left->qr(lf, rg) + right->qr(lf, rg);\r\n        }\r\n        void ud(int lf, int rg, int x) {\r\n                if (lazy != 0) {\r\n                        val += lazy*len;\r\n                        if (st != en) {\r\n                                left->lazy += lazy;\r\n                                right->lazy += lazy;\r\n                        }\r\n                        lazy = 0;\r\n                }\r\n                if (st > rg || en < lf) return;\r\n                if (lf <= st && en <= rg) {\r\n                        val += x*len;\r\n                        if (st != en) {\r\n                                left->lazy += x;\r\n                                right->lazy += x;\r\n                        }\r\n                        return;\r\n                }\r\n                left->ud(lf, rg, x);\r\n                right->ud(lf, rg, x);\r\n                val = left->val + right->val;\r\n        }       \r\n} sg;\r\n\r\nint32_t main()\r\n{\r\n        ios_base::sync_with_stdio(false);\r\n        cin.tie(NULL);\r\n        cin >> n >> q;\r\n        vector<pair<pair<int, int>, int>> zz;\r\n        for (int i = 0; i < q; i++) {\r\n                int t, l, r;\r\n                cin >> t >> l >> r;\r\n                if (t == 1) {\r\n                        int k;\r\n                        cin >> k;\r\n                        zz.push_back({{l, r}, k});\r\n                } else {\r\n                        zz.push_back({{l, r}, INF});\r\n                }\r\n                a.push_back(l - 1);\r\n                a.push_back(r);\r\n        }\r\n        a.push_back(0);\r\n        a.push_back(n);\r\n        sort(all(a));\r\n        a.erase(unique(all(a)), a.end());\r\n        int sz = a.size() - 1;\r\n        sg.build(1, sz);\r\n        // 0 1 2 3 4\r\n        // 0 1 2 3 5\r\n        //  1 2 3 4\r\n        // 3 4\r\n        // \r\n        for (auto z : zz) {\r\n                int l = lower_bound(all(a), z.fi.fi - 1) - a.begin() + 1;\r\n                int r = lower_bound(all(a), z.fi.se) - a.begin();\r\n                // cout << l << \" \" << r << '\\n';\r\n                if (z.se == INF) {\r\n                        cout << sg.qr(l, r) << '\\n';\r\n                } else {\r\n                        sg.ud(l, r, z.se);\r\n                }\r\n        }\r\n        return 0;\r\n}"
    },
    {
        "username": "aufan",
        "id": 171903,
        "date": "2022-11-19 22:16:16",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\n#define fi first\r\n#define se second\r\n#define all(x) (x).begin(), (x).end()\r\n#define N 222222\r\nconst int INF = 1e9;\r\nusing namespace std;\r\nvector<int> zx(5*N, 0);\r\nvector<int> sumtree(5*N);\r\nvector<int> lazy(5*N);\r\nvector<int> szs(5*N);\r\nvector<int> a;\r\nint n, q;\r\nvoid build(int idx, int st, int en) {\r\n        if (st == en) {\r\n                sumtree[idx] = zx[st];\r\n                return;\r\n        }\r\n        int l = 2*idx + 1;\r\n        int r = l + 1;\r\n        int m = st + (en - st)/2;\r\n        build(l, st, m);\r\n        build(r, m + 1, en);\r\n        sumtree[idx] = sumtree[l] + sumtree[r];\r\n        return;\r\n}\r\nint qr(int lf, int rg, int idx, int st, int en) {\r\n        int m = st + (en - st)/2;\r\n        if (lazy[idx] != 0) {\r\n                sumtree[idx] += lazy[idx]*(a[en] - a[st-1]);\r\n                if (st != en) {\r\n                        lazy[2*idx] += lazy[idx];\r\n                        lazy[2*idx + 1] += lazy[idx];\r\n                }\r\n                lazy[idx] = 0;\r\n        }\r\n        if (st > rg || en < lf) return 0;\r\n        if (lf <= st && en <= rg) return sumtree[idx];\r\n        return qr(lf, rg, 2*idx, st, m) + qr(lf, rg, 2*idx + 1, m + 1, en);\r\n}\r\nvoid ud(int lf, int rg, int x, int idx, int st, int en) {\r\n        int m = st + (en - st)/2;\r\n        if (lazy[idx] != 0) {\r\n                sumtree[idx] += lazy[idx]*(a[en] - a[st-1]);\r\n                if (st != en) {\r\n                        lazy[2*idx] += lazy[idx];\r\n                        lazy[2*idx + 1] += lazy[idx];\r\n                }\r\n                lazy[idx] = 0;\r\n        }\r\n        if (st > rg || en < lf) return;\r\n        if (lf <= st && en <= rg) {\r\n                sumtree[idx] += x*(a[en] - a[st-1]);\r\n                if (st != en) {\r\n                        lazy[2*idx] += x;\r\n                        lazy[2*idx + 1] += x;\r\n                }\r\n                return;\r\n        }\r\n        ud(lf, rg, x, 2*idx, st, m);\r\n        ud(lf, rg, x, 2*idx + 1, m + 1, en);\r\n        sumtree[idx] = sumtree[2*idx] + sumtree[2*idx + 1];\r\n}\r\n\r\nint32_t main()\r\n{\r\n        ios_base::sync_with_stdio(false);\r\n        cin.tie(NULL);\r\n        cin >> n >> q;\r\n        vector<pair<pair<int, int>, int>> zz;\r\n        for (int i = 0; i < q; i++) {\r\n                int t, l, r;\r\n                cin >> t >> l >> r;\r\n                if (t == 1) {\r\n                        int k;\r\n                        cin >> k;\r\n                        zz.push_back({{l, r}, k});\r\n                } else {\r\n                        zz.push_back({{l, r}, INF});\r\n                }\r\n                a.push_back(l - 1);\r\n                a.push_back(r);\r\n        }\r\n        a.push_back(0);\r\n        a.push_back(n);\r\n        sort(all(a));\r\n        a.erase(unique(all(a)), a.end());\r\n        int sz = a.size() - 1;\r\n        build(1, 1, sz);\r\n        // 0 1 2 3 4\r\n        // 0 1 2 3 5\r\n        //  1 2 3 4\r\n        // 3 4\r\n        // \r\n        for (auto z : zz) {\r\n                int l = lower_bound(all(a), z.fi.fi - 1) - a.begin() + 1;\r\n                int r = lower_bound(all(a), z.fi.se) - a.begin();\r\n                // cout << l << \" \" << r << '\\n';\r\n                if (z.se == INF) {\r\n                        cout << qr(l, r, 1, 1, sz) << '\\n';\r\n                } else {\r\n                        ud(l, r, z.se, 1, 1, sz);\r\n                }\r\n        }\r\n        return 0;\r\n}"
    },
    {
        "username": "Tyx2019",
        "id": 157101,
        "date": "2022-11-04 15:22:29",
        "code": "#include <bits/stdc++.h>\r\n#define ll long long\r\nusing namespace std;\r\nint A[100005];\r\nint N,M;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\n\r\n// root = new node(0, N-1, array); //creates a segment tree with elements 0 to N - 1. The array parameter is optional.\r\n// root = new node(0, 1000000000); //this tree supports lazy node creation and propagation too, declare as much as you like :)\r\n\r\n\r\n// root->add(0, 5000, 3);    //add 3 to range [0, 5000]\r\n// root->add(3000, 9000, -2); //minus 2 to range [3000, 9000]\r\n// root->set(7000, 10000, 5);    //set range [7000, 10000] to 5\r\n\r\n// /* at this point, 0 to 2999 is 3, 3000 to 5000 is 1, 5001 to 6999 is -2, 7000 to 10000 is 5 */\r\n// root->range_max(0, 10000);    //returns 5\r\n// root->range_min(0, 10000);    //returns -2\r\n// root->range_sum(0, 10000);    //returns 22008\r\nint main(){\r\n    cin >> N;\r\n    root=new node(0,1000000000);\r\n    cin >> M;\r\n    for(int i=0;i<M;i++){\r\n        int op;\r\n        cin >> op;\r\n        if(op==2){\r\n            int x,y;\r\n            cin >> x >> y;\r\n            cout << root->range_sum(x,y) << \"\\n\";\r\n        }\r\n        else{\r\n            int a,b,c;\r\n            cin >> a >> b >> c;\r\n            root->add(a,b,c);\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "WH8",
        "id": 154139,
        "date": "2022-10-26 16:09:36",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define FASTIO               \\\r\n    ios::sync_with_stdio(0); \\\r\n    cin.tie(0);              \\\r\n    cout.tie(0);\r\n#define loop(i, n) for (int i = 0; i < n; ++i)\r\n#define INF 1000000100\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n\tint n, q, curr, l, r, k;\r\n\tcin >> n >> q;\r\n\troot = new node(1, n);\r\n\tloop(i, q){\r\n\t\tcin >> curr;\r\n\t\tif (curr == 1){\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\troot->add(l, r, k);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->range_sum(l, r) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "Sans12345",
        "id": 152859,
        "date": "2022-10-20 01:56:46",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll sum;\r\n    ll add_val;\r\n    node *l, *r;\r\n    node (int _s, int _e): s(_s), e(_e), sum(0), add_val(0), l(NULL), r(NULL) {\r\n    }\r\n\r\n    inline void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n\r\n\r\n//self_add already updates sum. So lazy_propagate only needs to change lazy and sum for offsprings.\r\n    inline void self_add(ll v) {\r\n        add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    void add(int x, int y, ll v) {\r\n        //[s,e] and [x,y] must overlap. here is when exact match.\r\n        if (s == x && e == y) { self_add(v); return; }\r\n\r\n        //[s,e] and [x,y] must overlap. here is when partial match, meaning this node cannot be a leaf\r\n        int m = (s+e)>>1;\r\n        create_children(); \r\n        lazy_propagate();\r\n\r\n        //if [first,last] overlaps with both branches, these two recursions both are executed.\r\n        //This means: if one branch is a leaf, it will exactly match.\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n\r\n        //backtracking to root to update node sum values\r\n        sum = l->sum + r->sum;\r\n    }\r\n\r\n    ll range_sum(int x, int y) {\r\n        //[s,e] and [x,y] must overlap. here is when exact match.\r\n        if (s == x && e == y) return sum;//OK to use sum directly because self_add and lazy_propagate functions change both sum and lazy.\r\n\r\n        //[s,e] and [x,y] must overlap. here is when partial match AND this node has no offsprings.\r\n        if (l == NULL) return (sum / (e-s+1)) * (y-x+1);\r\n\r\n        //[s,e] and [x,y] must overlap. here is when partial match AND this node has offsprings.\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n\r\n    //case 1: [x,y] overlaps left branch only [s,m], no need to search right\r\n    //case 2: [x,y] overlaps right branch only [m+1,e], no need to search left\r\n    //case 3: overlap with both branches, search both\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n\r\n\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    int N, Q;\r\n\tcin>>N>>Q;\r\n\t\r\n\troot = new node(1,N);//1-indexed in update and query\r\n\t\r\n    int op, l, r, k;\r\n    while (Q--){\r\n        cin>>op>>l>>r;\r\n        if (op==1) {\r\n            cin>>k;\r\n            root->add(l, r, k);// increase [l,r] by k \r\n        } else cout<< root->range_sum(l, r) <<'\\n';\r\n    }\r\n\r\n    return 0;\r\n\t\r\n}"
    },
    {
        "username": "Sans12345",
        "id": 152857,
        "date": "2022-10-20 01:08:42",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst long long defval = 0; //0 for sum, INT_MAX for min, INT_MIN for max\r\n#define lazyChange (e-s+1)//interval of changes for sum;\r\n\r\nstruct node {\r\n    int s,e,m;\r\n    node *l, *r;\r\n    long long v;\r\n    long long lazyUpd;\r\n\r\n    node(int S_, int E_): s(S_), e(E_), m((s+e)>>1), l(NULL), r(NULL), v(defval), lazyUpd(0) {\r\n\t\t//if(s!=e) { l = new node(s,m); r = new node(m+1,e); }\r\n    }\r\n    \r\n    inline void instL(){\r\n\t\tif (l == NULL) l = new node(s,m);\r\n\t}\r\n\t\r\n\tinline void instR(){\r\n\t\tif (r == NULL) r = new node(m+1,e);\r\n\t}\r\n    \r\n   inline long long forceProp(){\r\n\t\tif (s==e) {//a leaf node\r\n\t\t\tv+=lazyUpd; lazyUpd = 0; return v;\r\n\t\t}\r\n\t\tif (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n\t\treturn v;\r\n\t}\r\n    \r\n    \r\n    void rangeUpd(int first, int last, int c){\r\n        \r\n        //node seg [s,e] in query range [first,last]\r\n        //add increament in lazy when searching path, propagate value when backtracking\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazyUpd += c;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n        //node seg [s,e] partially overlaps query range [first,last]\r\n\t\tinstL(); instR();\r\n\t\tforceProp();\r\n        \r\n        //if [first,last] overlaps with both branches, these two recursions both are executed.\r\n        //This means: if one branch is a leaf, it will exactly match.\r\n\t\tif (first <= m){ \r\n            l->rangeUpd(first, last, c); \r\n        }\r\n\t\tif (last >= m+1){ \r\n            r->rangeUpd(first, last, c); \r\n            }\r\n        \r\n        //backtracking to root to update node values\r\n        long long lv = l->forceProp();\r\n        long long rv = r->forceProp();\r\n\t\tv = lv + rv;\r\n\t}\r\n\t\r\n\r\n    \r\n    long long query(int x, int y){\t\r\n        forceProp();\r\n\r\n        //node [s,e] is within query range [x,y]\r\n\t\tif (x <= s && y >= e){ \r\n\t\t\treturn v;\r\n\t\t}\r\n\r\n        //partially overlap\r\n\t\tinstL(); instR();\r\n        if(y<=m) { \r\n            return l->query(x, y);//case 1: within left branch only, no need to search right\r\n            }\r\n        if(x>m) { \r\n            return r->query(x, y);//case 2: within right branch only, no need to search left\r\n            }\r\n        long long lv = l->query(x, m);//case 3: overlap with both branches, search both\r\n        long long rv = r->query(m+1, y);\r\n        return lv+rv;\r\n    }\r\n};\r\n\r\nint main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    int N, Q;\r\n\tcin>>N>>Q;\r\n\t\r\n\tnode st(1, N);//1-indexed in update and query\r\n\t\r\n    int op, l, r, k;\r\n    while (Q--){\r\n        cin>>op>>l>>r;\r\n        if (op==1) {\r\n            cin>>k;\r\n            st.rangeUpd(l, r, k);// increase [l,r] by k \r\n        } else cout<< st.query(l, r) <<'\\n';\r\n    }\r\n\r\n    return 0;\r\n\t\r\n}"
    },
    {
        "username": "Sans12345",
        "id": 152796,
        "date": "2022-10-19 00:43:03",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nlong long combine(long long a, long long b){\r\n\treturn a + b;//min(a,b);\r\n}\r\n\r\nconst long long defval = 0; //0 for sum, INT_MAX for min, INT_MIN for max\r\n#define lazyChange (e-s+1)//interval of changes for sum;\r\n\r\nstruct node {\r\n    int s,e,m;\r\n    node *l, *r;\r\n    long long v;\r\n    long long lazyUpd;\r\n\r\n    node(int S_, int E_): s(S_), e(E_), m((s+e)>>1), l(NULL), r(NULL), v(defval), lazyUpd(0) {\r\n\t\t//if(s!=e) { l = new node(s,m); r = new node(m+1,e); }\r\n    }\r\n    \r\n    inline void instL(){\r\n\t\tif (l == NULL) l = new node(s,m);\r\n\t}\r\n\t\r\n\tinline void instR(){\r\n\t\tif (r == NULL) r = new node(m+1,e);\r\n\t}\r\n    \r\n   inline long long forceProp(){\r\n\t\tif (s==e) {\r\n\t\t\tv+=lazyUpd; lazyUpd = 0; return v;\r\n\t\t}\r\n\t\tif (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n\t\treturn v;\r\n\t}\r\n    \r\n    \r\n    void rangeUpd(int first, int last, int c){\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazyUpd += c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tinstL(); instR();\r\n\t\tforceProp();\r\n\t\tif (first <= m){ l->rangeUpd(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeUpd(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n\t\r\n\r\n    \r\n    long long query(int x, int y){\t\r\n\t\tif (s==e) {\r\n\t\t\tv += lazyUpd; lazyUpd = 0; return v;\r\n\t\t}\r\n\t\tif (x <= s && y >= e){ \r\n\t\t\tforceProp(); return v;\r\n\t\t}\r\n\t\tinstL(); instR();\r\n\t\tforceProp();\r\n        if(y<=m) { return l->query(x, y);}\r\n        if(x>m) { return r->query(x, y);}\r\n        return combine(l->query(x, m), r->query(m+1, y));\r\n    }\r\n};\r\n\r\nint main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    int N, Q;\r\n\tcin>>N>>Q;\r\n\t\r\n\tnode st(1, N);//1-indexed in update and query\r\n\t\r\n    int op, l, r, k;\r\n    while (Q--){\r\n        cin>>op>>l>>r;\r\n        if (op==1) {\r\n            cin>>k;\r\n            st.rangeUpd(l, r, k);// increase [l,r] by k \r\n        } else cout<< st.query(l, r) <<'\\n';\r\n    }\r\n\r\n    return 0;\r\n\t\r\n}"
    },
    {
        "username": "Sans12345",
        "id": 152795,
        "date": "2022-10-19 00:40:31",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nlong long combine(long long a, long long b){\r\n\treturn a + b;//min(a,b);\r\n}\r\n\r\nconst long long defval = 0; //0 for sum, INT_MAX for min, INT_MIN for max\r\n#define lazyChange (e-s+1)//interval of changes for sum;\r\n\r\nstruct node {\r\n    long long s,e,m;\r\n    node *l, *r;\r\n    long long v;\r\n    long long lazyUpd;\r\n\r\n    node(long long S_, long long E_): s(S_), e(E_), m((s+e)>>1), l(NULL), r(NULL), v(defval), lazyUpd(0) {\r\n\t\t//if(s!=e) { l = new node(s,m); r = new node(m+1,e); }\r\n    }\r\n    \r\n    inline void instL(){\r\n\t\tif (l == NULL) l = new node(s,m);\r\n\t}\r\n\t\r\n\tinline void instR(){\r\n\t\tif (r == NULL) r = new node(m+1,e);\r\n\t}\r\n    \r\n   inline long long forceProp(){\r\n\t\tif (s==e) {\r\n\t\t\tv+=lazyUpd; lazyUpd = 0; return v;\r\n\t\t}\r\n\t\tif (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n\t\treturn v;\r\n\t}\r\n    \r\n    \r\n    void rangeUpd(int first, int last, int c){\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazyUpd += c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tinstL(); instR();\r\n\t\tforceProp();\r\n\t\tif (first <= m){ l->rangeUpd(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeUpd(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n\t\r\n\r\n    \r\n    long long query(int x, int y){\t\r\n\t\tif (s==e) {\r\n\t\t\tv += lazyUpd; lazyUpd = 0; return v;\r\n\t\t}\r\n\t\tif (x <= s && y >= e){ \r\n\t\t\tforceProp(); return v;\r\n\t\t}\r\n\t\tinstL(); instR();\r\n\t\tforceProp();\r\n        if(y<=m) { return l->query(x, y);}\r\n        if(x>m) { return r->query(x, y);}\r\n        return combine(l->query(x, m), r->query(m+1, y));\r\n    }\r\n};\r\n\r\nint main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    int N, Q;\r\n\tcin>>N>>Q;\r\n\t\r\n\tnode st(1, N);//1-indexed in update and query\r\n\t\r\n    int op, l, r, k;\r\n    while (Q--){\r\n        cin>>op>>l>>r;\r\n        if (op==1) {\r\n            cin>>k;\r\n            st.rangeUpd(l, r, k);// increase [l,r] by k \r\n        } else cout<< st.query(l, r) <<'\\n';\r\n    }\r\n\r\n    return 0;\r\n\t\r\n}"
    },
    {
        "username": "Sans12345",
        "id": 152794,
        "date": "2022-10-19 00:36:57",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nlong long combine(long long a, long long b){\r\n\treturn a + b;//min(a,b);\r\n}\r\n\r\nconst long long defval = 0; //0 for sum, INT_MAX for min, INT_MIN for max\r\n#define lazyChange (e-s+1)//interval of changes for sum;\r\n\r\nstruct node {\r\n    long long s,e,m;\r\n    node *l, *r;\r\n    long long v;\r\n    long long lazyUpd;\r\n\r\n    node(long long S_, long long E_): s(S_), e(E_), m((s+e)>>1), l(NULL), r(NULL), v(defval), lazyUpd(0) {\r\n\t\t//if(s!=e) { l = new node(s,m); r = new node(m+1,e); }\r\n    }\r\n    \r\n    inline void instL(){\r\n\t\tif (l == NULL) l = new node(s,m);\r\n\t}\r\n\t\r\n\tinline void instR(){\r\n\t\tif (r == NULL) r = new node(m+1,e);\r\n\t}\r\n    \r\n   inline long long forceProp(){\r\n\t\tif (s==e) {\r\n\t\t\tv+=lazyUpd; lazyUpd = 0; return v;\r\n\t\t}\r\n\t\tif (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n\t\treturn v;\r\n\t}\r\n    \r\n    \r\n    void rangeUpd(long long first, long long last, long long c){\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazyUpd += c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tinstL(); instR();\r\n\t\tforceProp();\r\n\t\tif (first <= m){ l->rangeUpd(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeUpd(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n\t\r\n\r\n    \r\n    long long query(long long x, long long y){\t\r\n\t\tif (s==e) {\r\n\t\t\tv += lazyUpd; lazyUpd = 0; return v;\r\n\t\t}\r\n\t\tif (x <= s && y >= e){ \r\n\t\t\tforceProp(); return v;\r\n\t\t}\r\n\t\tinstL(); instR();\r\n\t\tforceProp();\r\n        if(y<=m) { return l->query(x, y);}\r\n        if(x>m) { return r->query(x, y);}\r\n        return combine(l->query(x, m), r->query(m+1, y));\r\n    }\r\n};\r\n\r\nint main(){\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    long long N, Q;\r\n\tcin>>N>>Q;\r\n\t\r\n\tnode st(1, N);//1-indexed in update and query\r\n\t\r\n    int op;\r\n\tlong long l, r, k;\r\n    while (Q--){\r\n        cin>>op>>l>>r;\r\n        if (op==1) {\r\n            cin>>k;\r\n            st.rangeUpd(l, r, k);// increase [l,r] by k \r\n        } else cout<< st.query(l, r) <<'\\n';\r\n    }\r\n\r\n    return 0;\r\n\t\r\n}"
    },
    {
        "username": "geometric",
        "id": 152236,
        "date": "2022-10-15 13:08:21",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nint sum = 0;\r\ntypedef long long ll;\r\nstruct node {\r\n  int s, e;\r\n  ll mn, mx, sum;\r\n  bool lset;\r\n  ll add_val, set_val;\r\n  node *l, *r;\r\n  node(int _s, int _e, int A[] = NULL)\r\n      : s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0),\r\n        l(NULL), r(NULL) {\r\n    if (A == NULL)\r\n      return;\r\n    if (s == e)\r\n      mn = mx = sum = A[s];\r\n    else {\r\n      l = new node(s, (s + e) >> 1, A), r = new node((s + e + 2) >> 1, e, A);\r\n      combine();\r\n    }\r\n  }\r\n  void create_children() {\r\n    if (s == e)\r\n      return;\r\n    if (l != NULL)\r\n      return;\r\n    int m = (s + e) >> 1;\r\n    l = new node(s, m);\r\n    r = new node(m + 1, e);\r\n  }\r\n  void self_set(ll v) {\r\n    lset = 1;\r\n    mn = mx = set_val = v;\r\n    sum = v * (e - s + 1);\r\n    add_val = 0;\r\n  }\r\n  void self_add(ll v) {\r\n    if (lset) {\r\n      self_set(v + set_val);\r\n      return;\r\n    }\r\n    mn += v, mx += v, add_val += v;\r\n    sum += v * (e - s + 1);\r\n  }\r\n  void lazy_propagate() {\r\n    if (s == e)\r\n      return;\r\n    if (lset) {\r\n      l->self_set(set_val), r->self_set(set_val);\r\n      lset = set_val = 0;\r\n    }\r\n    if (add_val != 0) {\r\n      l->self_add(add_val), r->self_add(add_val);\r\n      add_val = 0;\r\n    }\r\n  }\r\n  void combine() {\r\n    if (l == NULL)\r\n      return;\r\n    sum = l->sum + r->sum;\r\n    mn = min(l->mn, r->mn);\r\n    mx = max(l->mx, r->mx);\r\n  }\r\n  void add(int x, int y, ll v) {\r\n    if (s == x && e == y) {\r\n      self_add(v);\r\n      return;\r\n    }\r\n    int m = (s + e) >> 1;\r\n    create_children();\r\n    lazy_propagate();\r\n    if (x <= m)\r\n      l->add(x, min(y, m), v);\r\n    if (y > m)\r\n      r->add(max(x, m + 1), y, v);\r\n    combine();\r\n  }\r\n  void set(int x, int y, ll v) {\r\n    if (s == x && e == y) {\r\n      self_set(v);\r\n      return;\r\n    }\r\n    int m = (s + e) >> 1;\r\n    create_children();\r\n    lazy_propagate();\r\n    if (x <= m)\r\n      l->set(x, min(y, m), v);\r\n    if (y > m)\r\n      r->set(max(x, m + 1), y, v);\r\n    combine();\r\n  }\r\n  ll range_sum(int x, int y) {\r\n    if (s == x && e == y)\r\n      return sum;\r\n    if (l == NULL || lset)\r\n      return (sum / (e - s + 1)) * (y - x + 1);\r\n    int m = (s + e) >> 1;\r\n    lazy_propagate();\r\n    if (y <= m)\r\n      return l->range_sum(x, y);\r\n    if (x > m)\r\n      return r->range_sum(x, y);\r\n    return l->range_sum(x, m) + r->range_sum(m + 1, y);\r\n  }\r\n  ll range_min(int x, int y) {\r\n    if (s == x && e == y)\r\n      return mn;\r\n    if (l == NULL || lset)\r\n      return mn;\r\n    int m = (s + e) >> 1;\r\n    lazy_propagate();\r\n    if (y <= m)\r\n      return l->range_min(x, y);\r\n    if (x > m)\r\n      return r->range_min(x, y);\r\n    return min(l->range_min(x, m), r->range_min(m + 1, y));\r\n  }\r\n  ll range_max(int x, int y) {\r\n    if (s == x && e == y)\r\n      return mx;\r\n    if (l == NULL || lset)\r\n      return mx;\r\n    int m = (s + e) >> 1;\r\n    lazy_propagate();\r\n    if (y <= m)\r\n      return l->range_max(x, y);\r\n    if (x > m)\r\n      return r->range_max(x, y);\r\n    return max(l->range_max(x, m), r->range_max(m + 1, y));\r\n  }\r\n  ~node() {\r\n    if (l != NULL)\r\n      delete l;\r\n    if (r != NULL)\r\n      delete r;\r\n  }\r\n} * root;\r\nint32_t main() {\r\n  ios::sync_with_stdio(0);\r\n  cin.tie(NULL);\r\n  cout.tie(NULL);\r\n  int n, q;\r\n  cin >> n >> q;\r\n  root = new node(0, 10000000000);\r\n  int a, b, c;\r\n  for (int i = 0; i < q; ++i) {\r\n    cin >> a >> b >> c;\r\n    if (a == 1) {\r\n      int d;\r\n      cin >> d;\r\n      root->add(b, c, d);\r\n    } else {\r\n      sum = 0;\r\n      root->range_sum(b, c);\r\n      cout << root->range_sum(b,c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "LCJLY",
        "id": 150979,
        "date": "2022-10-07 14:32:53",
        "code": "#include <bits/stdc++.h>\r\n#include <bits/extc++.h>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n \r\n#define ull unsigned long long\r\n#define unint unsigned int\r\n#define sint short int\r\n#define usint unsigned short int\r\n#define ll long long\r\n#define ld long double\r\n#define vt vector\r\n#define pb push_back\r\n#define mp make_pair\r\n#define PI 3.14159265358979323\r\n#define F first\r\n#define S second \r\n#define all(a) (a).begin(), (a).end()\r\n#define sz(a) ((int)a.size())\r\n#define clr(x,a) memset(x, a, sizeof(x))\r\n#define len(a) ((int)a.length())\r\n#define E 2.7182818284590452353602874713527\r\n#define FOR(i, x) for(int i=0; i<x; ++i)\r\n#define For(i, x) for(auto& i: x)\r\n#define RFOR(i, x) for(int i=x-1; i>=0; --i) \r\n#define FORS(x, s, e, n) for(int x=s; x<=e; x+=n) \r\n#define int long long\r\n\r\ntypedef pair<int, int> pii;\r\n \r\nvoid solve(){\r\n    \r\n}\r\n\r\n//code segtree\r\nstruct node{\r\n    int s,e,m,v,lazyUpd=0;\r\n    node *l, *r;\r\n    node(int _s,int _e){\r\n        s=_s; e=_e; m=(s+e)/2; v=0;\r\n        l = NULL;\r\n        r = NULL;\r\n        lazyUpd=0;\r\n    }\r\n\r\n    int forceprop(){\r\n        if(s==e){\r\n            v+=lazyUpd;\r\n            lazyUpd=0;\r\n            return v;\r\n        }\r\n        if(lazyUpd!=0){\r\n            v+=((e-s+1)*lazyUpd);\r\n            if(l==NULL){\r\n                l= new node(s,m);\r\n            }\r\n            if(r==NULL){\r\n                r=new node(m+1,e);\r\n            }\r\n            l->lazyUpd+=lazyUpd;\r\n            r->lazyUpd+=lazyUpd;\r\n            lazyUpd=0;\r\n            return v;\r\n        }\r\n    }\r\n\r\n    void ru(int x, int y, int c){\r\n        forceprop();\r\n        if(x <= s && y >= e){\r\n            lazyUpd+=c;\r\n            return;\r\n        }\r\n        if(l==NULL){\r\n            l= new node(s,m);\r\n        }\r\n        if(r==NULL){\r\n            r=new node(m+1,e);\r\n        }\r\n        if(x>m){\r\n            r->ru(x,y,c);\r\n        }\r\n        else if(y<=m){\r\n            l->ru(x,y,c);\r\n        }\r\n        else{\r\n            l->ru(x,y,c);r->ru(x,y,c);\r\n        }\r\n\r\n        // if (x <= m){ l->ru(x, y, c); }\r\n\t\t// if (y >= m+1){ r->ru(x, y, c); }\r\n        v=l->forceprop()+r->forceprop();\r\n    }\r\n\r\n    int rq(int x, int y){\r\n        // cout << x << \" \" << y << \"\\n\";\r\n        forceprop();\r\n        if(x <= s && y >= e){\r\n            return v;\r\n        }\r\n        if(l==NULL){\r\n            l= new node(s,m);\r\n        }\r\n        if(r==NULL){\r\n            r=new node(m+1,e);\r\n        }\r\n        if(y<=m){\r\n            return l->rq(x,y);\r\n        }\r\n        if(x>m){\r\n            return r->rq(x,y);\r\n        }\r\n        return l->rq(x,m)+r->rq(m+1,y);\r\n    }\r\n}*root;\r\n \r\nint32_t main() {\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    int a,b;\r\n    cin >> a >> b;\r\n    root = new node(0,a+1);\r\n    int temp,temp2,temp3,temp4;\r\n    for(int x=0;x<b;x++){\r\n        cin >> temp >> temp2 >> temp3;\r\n        if(temp==1){\r\n            cin >> temp4;\r\n            root->ru(temp2,temp3,temp4);\r\n        }\r\n        else{\r\n            cout << root->rq(temp2,temp3) << \"\\n\";\r\n        }\r\n    }   \r\n    return 0;\r\n}"
    },
    {
        "username": "LCJLY",
        "id": 150973,
        "date": "2022-10-07 14:27:46",
        "code": "#include <bits/stdc++.h>\r\n#include <bits/extc++.h>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n \r\n#define ull unsigned long long\r\n#define unint unsigned int\r\n#define sint short int\r\n#define usint unsigned short int\r\n#define ll long long\r\n#define ld long double\r\n#define vt vector\r\n#define pb push_back\r\n#define mp make_pair\r\n#define PI 3.14159265358979323\r\n#define F first\r\n#define S second \r\n#define all(a) (a).begin(), (a).end()\r\n#define sz(a) ((int)a.size())\r\n#define clr(x,a) memset(x, a, sizeof(x))\r\n#define len(a) ((int)a.length())\r\n#define E 2.7182818284590452353602874713527\r\n#define FOR(i, x) for(int i=0; i<x; ++i)\r\n#define For(i, x) for(auto& i: x)\r\n#define RFOR(i, x) for(int i=x-1; i>=0; --i) \r\n#define FORS(x, s, e, n) for(int x=s; x<=e; x+=n) \r\n#define int long long\r\n\r\ntypedef pair<int, int> pii;\r\n \r\nvoid solve(){\r\n    \r\n}\r\n\r\n//code segtree\r\nstruct node{\r\n    int s,e,m,v,lazyUpd=0;\r\n    node *l, *r;\r\n    node(int _s,int _e){\r\n        s=_s; e=_e; m=(s+e)/2; v=0;\r\n        l = NULL;\r\n        r = NULL;\r\n        lazyUpd=0;\r\n    }\r\n\r\n    int forceprop(){\r\n        if(s==e){\r\n            v+=lazyUpd;\r\n            lazyUpd=0;\r\n            return v;\r\n        }\r\n        if(lazyUpd!=0){\r\n            v+=((e-s+1)*lazyUpd);\r\n            if(l==NULL){\r\n                l= new node(s,m);\r\n            }\r\n            if(r==NULL){\r\n                r=new node(m+1,e);\r\n            }\r\n            l->lazyUpd+=lazyUpd;\r\n            r->lazyUpd+=lazyUpd;\r\n            lazyUpd=0;\r\n            return v;\r\n        }\r\n    }\r\n\r\n    void ru(int x, int y, int c){\r\n        forceprop();\r\n        if(x <= s && y >= e){\r\n            lazyUpd+=c;\r\n            return;\r\n        }\r\n        if(l==NULL){\r\n            l= new node(s,m);\r\n        }\r\n        if(r==NULL){\r\n            r=new node(m+1,e);\r\n        }\r\n        // if(x>m){\r\n        //     r->ru(x,y,c);\r\n        // }\r\n        // else if(y<=m){\r\n        //     l->ru(x,y,c);\r\n        // }\r\n        // else{\r\n        //     l->ru(x,m,c);r->ru(m+1,y,c);\r\n        // }\r\n\r\n        if (x <= m){ l->ru(x, y, c); }\r\n\t\tif (y >= m+1){ r->ru(x, y, c); }\r\n        v=l->forceprop()+r->forceprop();\r\n    }\r\n\r\n    int rq(int x, int y){\r\n        // cout << x << \" \" << y << \"\\n\";\r\n        forceprop();\r\n        if(x <= s && y >= e){\r\n            return v;\r\n        }\r\n        if(l==NULL){\r\n            l= new node(s,m);\r\n        }\r\n        if(r==NULL){\r\n            r=new node(m+1,e);\r\n        }\r\n        if(y<=m){\r\n            return l->rq(x,y);\r\n        }\r\n        if(x>m){\r\n            return r->rq(x,y);\r\n        }\r\n        return l->rq(x,m)+r->rq(m+1,y);\r\n    }\r\n}*root;\r\n \r\nint32_t main() {\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    int a,b;\r\n    cin >> a >> b;\r\n    root = new node(0,a+1);\r\n    int temp,temp2,temp3,temp4;\r\n    for(int x=0;x<b;x++){\r\n        cin >> temp >> temp2 >> temp3;\r\n        if(temp==1){\r\n            cin >> temp4;\r\n            root->ru(temp2,temp3,temp4);\r\n        }\r\n        else{\r\n            cout << root->rq(temp2,temp3) << \"\\n\";\r\n        }\r\n    }   \r\n    return 0;\r\n}"
    },
    {
        "username": "haydendoo",
        "id": 150886,
        "date": "2022-10-07 10:30:41",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int mxN=1e9;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll sum;\r\n    ll add_val;\r\n    node *l, *r;\r\n    node (int _s, int _e): s(_s), e(_e), sum(0), add_val(0), l(NULL), r(NULL) {\r\n    }\r\n    inline void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    inline void self_add(ll v) {\r\n        add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    inline void combine() {\r\n        sum = l->sum + r->sum;\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n        \r\nint main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint q, n;\r\n\troot = new node(0, mxN);\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; ++i){\r\n\t\tint type;\r\n\t\tcin >> type;\r\n\t\tif(type==1){\r\n\t\t\tint l, r, v;\r\n\t\t\tcin >> l >> r >> v;\r\n\t\t\troot->add(l-1,r-1,v);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->range_sum(l-1,r-1) << '\\n';\r\n\t\t}\r\n\t}\r\n} \r\n/*\r\n5 5 \r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/"
    },
    {
        "username": "haydendoo",
        "id": 150884,
        "date": "2022-10-07 10:09:56",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int mxN=1e9;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        \r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    \r\n} *root;\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint q, n;\r\n\troot = new node(0, mxN);\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; ++i){\r\n\t\tint type;\r\n\t\tcin >> type;\r\n\t\tif(type==1){\r\n\t\t\tint l, r, v;\r\n\t\t\tcin >> l >> r >> v;\r\n\t\t\troot->add(l-1,r-1,v);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->range_sum(l-1,r-1) << '\\n';\r\n\t\t}\r\n\t}\r\n} \r\n/*\r\n5 5 \r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/"
    },
    {
        "username": "haydendoo",
        "id": 150883,
        "date": "2022-10-07 10:09:26",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int mxN=1e9;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e, m;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), m((s+e)>>1), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        \r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        \r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        \r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        \r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        \r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint q, n;\r\n\troot = new node(0, mxN);\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; ++i){\r\n\t\tint type;\r\n\t\tcin >> type;\r\n\t\tif(type==1){\r\n\t\t\tint l, r, v;\r\n\t\t\tcin >> l >> r >> v;\r\n\t\t\troot->add(l-1,r-1,v);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->range_sum(l-1,r-1) << '\\n';\r\n\t\t}\r\n\t}\r\n} \r\n/*\r\n5 5 \r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/"
    },
    {
        "username": "haydendoo",
        "id": 150881,
        "date": "2022-10-07 10:07:33",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int mxN=1e9;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        \r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint q, n;\r\n\troot = new node(0, mxN);\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; ++i){\r\n\t\tint type;\r\n\t\tcin >> type;\r\n\t\tif(type==1){\r\n\t\t\tint l, r, v;\r\n\t\t\tcin >> l >> r >> v;\r\n\t\t\troot->add(l-1,r-1,v);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->range_sum(l-1,r-1) << '\\n';\r\n\t\t}\r\n\t}\r\n} \r\n/*\r\n5 5 \r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/"
    },
    {
        "username": "haydendoo",
        "id": 150868,
        "date": "2022-10-07 09:31:30",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int mxN=1e9;\r\n\r\ntypedef long long ll;\r\n#define int ll\r\n\r\n    struct node {\r\n\tint s, e, m, sum, lz;\r\n\tnode *l, *r;\r\n\tnode(int _S, int _E): s(_S), e(_E), m((s+e)>>1), l(NULL), r(NULL), lz(0), sum(0) {}\r\n\tint push(){\r\n\t\tsum+=(e-s+1)*lz;\r\n\t\tif(s==e) { lz=0; return sum; } \r\n\t\tif(l==NULL){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t} \r\n\t\tl->lz+=lz; r->lz+=lz;\r\n\t\tlz=0;\r\n\t\treturn sum;\r\n\t} \r\n\tvoid add(int x, int y, int v){\r\n\t\tif(s==x && e==y){\r\n\t\t\tlz+=v; return;\r\n\t\t} \r\n\t\tif(s!=e&&l==NULL) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t} \r\n\t\tif(y<=m) l->add(x, y, v);\r\n\t\telse if(x>m) r->add(x, y, v);\r\n\t\telse { l->add(x, m, v); r->add(m+1, y, v); } \r\n\t\tsum = l->push() + r->push();\r\n\t} \r\n\tint range_sum(int x, int y){\r\n\t\tpush();\r\n\t\tif(s==x && e==y) return sum;\r\n\t\tif (l == NULL) return (sum / (e-s+1)) * (y-x+1);\r\n      \r\n\t\tif(y<=m) return l->range_sum(x, y);\r\n\t\tif(x>m) return r->range_sum(x, y);\r\n\t\treturn l->range_sum(x, m) + r->range_sum(m+1, y);\r\n\t} \r\n} *root;\r\n    \r\n\r\nint32_t main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint q, n;\r\n\troot = new node(0, mxN);\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; ++i){\r\n\t\tint type;\r\n\t\tcin >> type;\r\n\t\tif(type==1){\r\n\t\t\tint l, r, v;\r\n\t\t\tcin >> l >> r >> v;\r\n\t\t\troot->add(l-1,r-1,v);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->range_sum(l-1,r-1) << '\\n';\r\n\t\t}\r\n\t}\r\n} \r\n/*\r\n5 5 \r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/"
    },
    {
        "username": "haydendoo",
        "id": 150866,
        "date": "2022-10-07 09:28:51",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int mxN=1e9;\r\n\r\ntypedef long long ll;\r\n#define int ll\r\n\r\n    struct node {\r\n\tint s, e, m, sum, lz;\r\n\tnode *l, *r;\r\n\tnode(int _S, int _E): s(_S), e(_E), m((s+e)>>1), l(NULL), r(NULL), lz(0), sum(0) {}\r\n\tint push(){\r\n\t\tsum+=(e-s+1)*lz;\r\n\t\tif(s==e) { lz=0; return sum; } \r\n\t\tif(l==NULL){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t} \r\n\t\tl->lz+=lz; r->lz+=lz;\r\n\t\tlz=0;\r\n\t\treturn sum;\r\n\t} \r\n\tvoid add(int x, int y, int v){\r\n\t\tif(s==x && e==y){\r\n\t\t\tlz+=v; return;\r\n\t\t} \r\n\t\tif(l==NULL) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t} \r\n\t\tif(y<=m) l->add(x, y, v);\r\n\t\telse if(x>m) r->add(x, y, v);\r\n\t\telse { l->add(x, m, v); r->add(m+1, y, v); } \r\n\t\tsum = l->push() + r->push();\r\n\t} \r\n\tint range_sum(int x, int y){\r\n\t\tpush();\r\n\t\tif(s==x && e==y) return sum;\r\n\t\tif (l == NULL) return (sum / (e-s+1)) * (y-x+1);\r\n      \r\n\t\tif(y<=m) return l->range_sum(x, y);\r\n\t\tif(x>m) return r->range_sum(x, y);\r\n\t\treturn l->range_sum(x, m) + r->range_sum(m+1, y);\r\n\t} \r\n} *root;\r\n    \r\n\r\nint32_t main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint q, n;\r\n\troot = new node(0, mxN);\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; ++i){\r\n\t\tint type;\r\n\t\tcin >> type;\r\n\t\tif(type==1){\r\n\t\t\tint l, r, v;\r\n\t\t\tcin >> l >> r >> v;\r\n\t\t\troot->add(l-1,r-1,v);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->range_sum(l-1,r-1) << '\\n';\r\n\t\t}\r\n\t}\r\n} \r\n/*\r\n5 5 \r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/"
    },
    {
        "username": "haydendoo",
        "id": 150865,
        "date": "2022-10-07 09:27:36",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int mxN=1e9;\r\n\r\ntypedef long long ll;\r\n#define int ll\r\n\r\n    struct node {\r\n\tint s, e, m, sum, lz;\r\n\tnode *l, *r;\r\n\tnode(int _S, int _E): s(_S), e(_E), m((s+e)>>1), l(NULL), r(NULL), lz(0), sum(0) {}\r\n\tint push(){\r\n\t\tsum+=(e-s+1)*lz;\r\n\t\tif(s==e) { lz=0; return sum; } \r\n\t\tif(l==NULL){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t} \r\n\t\tl->lz+=lz; r->lz+=lz;\r\n\t\tlz=0;\r\n\t\treturn sum;\r\n\t} \r\n\tvoid add(int x, int y, int v){\r\n\t\tif(s==x && e==y){\r\n\t\t\tlz+=v; return;\r\n\t\t} \r\n\t\tif(l==NULL) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t} \r\n\t\tif(y<=m) l->add(x, y, v);\r\n\t\telse if(x>m) r->add(x, y, v);\r\n\t\telse { l->add(x, m, v); r->add(m+1, y, v); } \r\n\t\tsum = l->push() + r->push();\r\n\t} \r\n\tint range_sum(int x, int y){\r\n\t\tpush();\r\n\t\tif(s==x && e==y) return sum;\r\n\t\tif(y<=m) return l->range_sum(x, y);\r\n\t\tif(x>m) return r->range_sum(x, y);\r\n\t\treturn l->range_sum(x, m) + r->range_sum(m+1, y);\r\n\t} \r\n} *root;\r\n    \r\n\r\nint32_t main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint q, n;\r\n\troot = new node(0, mxN);\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; ++i){\r\n\t\tint type;\r\n\t\tcin >> type;\r\n\t\tif(type==1){\r\n\t\t\tint l, r, v;\r\n\t\t\tcin >> l >> r >> v;\r\n\t\t\troot->add(l-1,r-1,v);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->range_sum(l-1,r-1) << '\\n';\r\n\t\t}\r\n\t}\r\n} \r\n/*\r\n5 5 \r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/"
    },
    {
        "username": "shoryu386",
        "id": 148386,
        "date": "2022-09-21 22:47:38",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long stdata;\r\ninline stdata combine(stdata a, stdata b){\r\n\treturn a+b;\r\n}\r\n\r\nconst stdata defval = 0; //0 for sum, maximum potential value for min, minimum potential value for max, UNLESS there is a specified default value\r\n#define lazyChange (e-s+1)\r\n#define setSentinel -1 //the value that WILL NEVER be used in rangeSet\r\n//if using lazy prop with min or max operations, change lazyChange to 1, otherwise leave as (e-s+1)\r\nstruct node {\r\n    long long s,e,m;\r\n    node *l, *r;\r\n    stdata v;\r\n    stdata lazyUpd, lazySet; //if doing extreme segtree modification with weird lazy, change this, can't be bothered to overcomplicate\r\n    //set applies first always, but please for your sanity do NOT use both at the same time.\r\n    node(int S_, int E_): s(S_), e(E_), m((s+e)>>1), l(NULL), r(NULL), v(defval), lazyUpd(0), lazySet(setSentinel) {\r\n\t\t//if(s!=e) { l = new node(s,m); r = new node(m+1,e); }\r\n    }\r\n    \r\n    inline void instL(){\r\n\t\tif (l == NULL) l = new node(s,m);\r\n\t}\r\n\t\r\n\tinline void instR(){\r\n\t\tif (r == NULL) r = new node(m+1,e);\r\n\t}\r\n    \r\n   inline stdata forceProp(){\r\n\t\tif (s==e) {if (lazySet != setSentinel){v=lazySet; lazySet = setSentinel;} v+=lazyUpd; lazyUpd = 0; return v;}\r\n\t\tif (lazySet != setSentinel) v = lazyChange*lazySet, instL(), instR(), l->lazySet = lazySet, r->lazySet = lazySet, lazySet = setSentinel;\r\n\t\tif (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n\t\treturn v;\r\n\t}\r\n    \r\n    void set(int x, stdata y){\r\n        if(s==e) { v=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->set(x,y);\r\n        else l->set(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    void upd(int x, stdata y){\r\n        if(s==e) { v+=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->upd(x,y);\r\n        else l->upd(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    \r\n    //range operations assume stdata is a numeric type. (yes, floats work :D)\r\n    //comment out all range operations to ignore it all\r\n    void rangeUpd(int first, int last, stdata c){\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazyUpd += c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tinstL(); instR();\r\n\t\tforceProp();\r\n\t\tif (first <= m){ l->rangeUpd(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeUpd(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n\t\r\n\tvoid rangeSet(int first, int last, stdata c){\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazySet = c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tinstL(); instR();\r\n\t\tforceProp();\r\n\t\tif (first <= m){ l->rangeSet(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeSet(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n    \r\n    stdata query(int x, int y){\r\n\t\t\r\n\t\tif (s==e) {if (lazySet != setSentinel){v = lazySet; lazySet = setSentinel;} v += lazyUpd; lazyUpd = 0; return v;}\r\n\t\tif (x <= s && y >= e){ forceProp(); return v;}\r\n\t\tinstL(); instR();\r\n\t\tforceProp();\r\n        if(y<=m) { return l->query(x, y);}\r\n        if(x>m) { return r->query(x, y);}\r\n        return combine(l->query(x, m), r->query(m+1, y));\r\n    }\r\n};\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n\tint n, q; cin >> n >> q;\r\n\tnode st(1, n);\r\n\t\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint com, a, b, c; cin >> com >> a >> b;\r\n\t\tif (com == 1){\r\n\t\t\tcin >> c;\r\n\t\t\tst.rangeUpd(a, b, c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << st.query(a, b) << '\\n';\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n"
    },
    {
        "username": "shoryu386",
        "id": 148384,
        "date": "2022-09-21 22:45:55",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long stdata;\r\ninline stdata combine(stdata a, stdata b){\r\n\treturn a+b;\r\n}\r\n\r\nconst stdata defval = 0; //0 for sum, maximum potential value for min, minimum potential value for max, UNLESS there is a specified default value\r\n#define lazyChange (e-s+1)\r\n#define setSentinel -1 //the value that WILL NEVER be used in rangeSet\r\n//if using lazy prop with min or max operations, change lazyChange to 1, otherwise leave as (e-s+1)\r\nstruct node {\r\n    long long s,e,m;\r\n    node *l, *r;\r\n    stdata v;\r\n    stdata lazyUpd, lazySet; //if doing extreme segtree modification with weird lazy, change this, can't be bothered to overcomplicate\r\n    //set applies first always, but please for your sanity do NOT use both at the same time.\r\n    node(int S_, int E_): s(S_), e(E_), m((s+e)>>1), l(NULL), r(NULL), v(defval), lazyUpd(0), lazySet(setSentinel) {\r\n\t\t//if(s!=e) { l = new node(s,m); r = new node(m+1,e); }\r\n    }\r\n    \r\n    inline void instL(){\r\n\t\tif (l == NULL) l = new node(s,m);\r\n\t}\r\n\t\r\n\tinline void instR(){\r\n\t\tif (r == NULL) r = new node(m+1,e);\r\n\t}\r\n    \r\n   inline stdata forceProp(){\r\n\t\tif (s==e) {if (lazySet != setSentinel){v=lazySet; lazySet = setSentinel;} v+=lazyUpd; lazyUpd = 0; return v;}\r\n\t\tif (lazySet != setSentinel) v = lazyChange*lazySet, instL(), instR(), l->lazySet = lazySet, r->lazySet = lazySet, lazySet = setSentinel;\r\n\t\tif (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n\t\tinstL(); instR();\r\n\t\treturn v;\r\n\t}\r\n    \r\n    void set(int x, stdata y){\r\n        if(s==e) { v=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->set(x,y);\r\n        else l->set(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    void upd(int x, stdata y){\r\n        if(s==e) { v+=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->upd(x,y);\r\n        else l->upd(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    \r\n    //range operations assume stdata is a numeric type. (yes, floats work :D)\r\n    //comment out all range operations to ignore it all\r\n    void rangeUpd(int first, int last, stdata c){\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazyUpd += c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tforceProp();\r\n\t\tif (first <= m){ l->rangeUpd(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeUpd(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n\t\r\n\tvoid rangeSet(int first, int last, stdata c){\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazySet = c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tforceProp();\r\n\t\tif (first <= m){ l->rangeSet(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeSet(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n    \r\n    stdata query(int x, int y){\r\n\t\t\r\n\t\tif (s==e) {if (lazySet != setSentinel){v = lazySet; lazySet = setSentinel;} v += lazyUpd; lazyUpd = 0; return v;}\r\n\t\tif (x <= s && y >= e){ forceProp(); return v;}\r\n\t\tforceProp();\r\n        if(y<=m) { return l->query(x, y);}\r\n        if(x>m) { return r->query(x, y);}\r\n        return combine(l->query(x, m), r->query(m+1, y));\r\n    }\r\n};\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n\tint n, q; cin >> n >> q;\r\n\tnode st(1, n);\r\n\t\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint com, a, b, c; cin >> com >> a >> b;\r\n\t\tif (com == 1){\r\n\t\t\tcin >> c;\r\n\t\t\tst.rangeUpd(a, b, c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << st.query(a, b) << '\\n';\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n"
    },
    {
        "username": "shoryu386",
        "id": 148155,
        "date": "2022-09-20 19:17:25",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long stdata;\r\ninline stdata combine(stdata a, stdata b){\r\n\treturn a+b;\r\n}\r\nconst stdata defval = 0; //0 for sum, maximum potential value for min, minimum potential value for max, UNLESS there is a specified default value\r\n#define lazyChange (e-s+1)\r\n//if using lazy prop with min or max operations, change lazyChange to 1, otherwise leave as (e-s+1)\r\nstruct node {\r\n    long long s,e,m;\r\n    node *l, *r;\r\n    stdata v;\r\n    stdata lazyUpd; //if doing extreme segtree modification with weird lazy, change this, can't be bothered to overcomplicate\r\n    node(int S_, int E_): s(S_), e(E_), m((s+e)>>1), l(NULL), r(NULL), v(defval), lazyUpd(0) {\r\n\t\t//if(s!=e) { l = new node(s,m); r = new node(m+1,e); }\r\n    }\r\n    \r\n    inline void instL(){\r\n\t\tif (l == NULL) l = new node(s,m);\r\n\t}\r\n\t\r\n\tinline void instR(){\r\n\t\tif (r == NULL) r = new node(m+1,e);\r\n\t}\r\n    \r\n   inline stdata forceProp(){\r\n\t\tif (s==e) {v+=lazyUpd; lazyUpd = 0; return v;}\r\n\t\tif (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n\t\treturn v;\r\n\t}\r\n    \r\n    void set(int x, stdata y){\r\n        if(s==e) { v=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->set(x,y);\r\n        else l->set(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    void upd(int x, stdata y){\r\n        if(s==e) { v+=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->upd(x,y);\r\n        else l->upd(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    //range operations assume stdata is a numeric type. (yes, floats work :D)\r\n    void rangeUpd(int first, int last, stdata c){\r\n\t\t\r\n\t\t\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazyUpd += c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tinstL(); instR();\r\n\t\tif (first <= m){ l->rangeUpd(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeUpd(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n    \r\n    stdata query(int x, int y){\r\n\t\tif (s==e) {v += lazyUpd; lazyUpd = 0; return v;}\r\n        if (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n        if(x==s && y==e) {return v;}\r\n        instL(); instR();\r\n        if(y<=m) {return l->query(x, y);}\r\n        if(x>m) {return r->query(x, y);}\r\n        return combine(l->query(x, m), r->query(m+1, y));\r\n    }\r\n};\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n\tint n, q; cin >> n >> q;\r\n\tnode st(1, n);\r\n\t\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint com, a, b, c; cin >> com >> a >> b;\r\n\t\tif (com == 1){\r\n\t\t\tcin >> c;\r\n\t\t\tst.rangeUpd(a, b, c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << st.query(a, b) << '\\n';\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n"
    },
    {
        "username": "shoryu386",
        "id": 148154,
        "date": "2022-09-20 19:16:13",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long stdata;\r\ninline stdata combine(stdata a, stdata b){\r\n\treturn a+b;\r\n}\r\nconst stdata defval = 0; //0 for sum, maximum potential value for min, minimum potential value for max, UNLESS there is a specified default value\r\n#define lazyChange (e-s+1)\r\n//if using lazy prop with min or max operations, change lazyChange to 1, otherwise leave as (e-s+1)\r\nstruct node {\r\n    long long s,e,m;\r\n    node *l, *r;\r\n    stdata v;\r\n    stdata lazyUpd; //if doing extreme segtree modification with weird lazy, change this, can't be bothered to overcomplicate\r\n    node(int S_, int E_): s(S_), e(E_), m((s+e)>>1), l(NULL), r(NULL), v(defval), lazyUpd(0) {\r\n\t\t//if(s!=e) { l = new node(s,m); r = new node(m+1,e); }\r\n    }\r\n    \r\n    inline void instL(){\r\n\t\tif (l == NULL) l = new node(s,m);\r\n\t}\r\n\t\r\n\tinline void instR(){\r\n\t\tif (r == NULL) r = new node(m+1,e);\r\n\t}\r\n    \r\n    stdata forceProp(){\r\n\t\tif (s==e) {v+=lazyUpd; lazyUpd = 0; return v;}\r\n\t\tif (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n\t\treturn v;\r\n\t}\r\n    \r\n    void set(int x, stdata y){\r\n        if(s==e) { v=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->set(x,y);\r\n        else l->set(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    void upd(int x, stdata y){\r\n        if(s==e) { v+=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->upd(x,y);\r\n        else l->upd(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    //range operations assume stdata is a numeric type. (yes, floats work :D)\r\n    void rangeUpd(int first, int last, stdata c){\r\n\t\t\r\n\t\t\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazyUpd += c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tinstL(); instR();\r\n\t\tif (first <= m){ l->rangeUpd(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeUpd(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n    \r\n    stdata query(int x, int y){\r\n\t\tif (s==e) {v += lazyUpd; lazyUpd = 0; return v;}\r\n        if (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n        if(x==s && y==e) {return v;}\r\n        instL(); instR();\r\n        if(y<=m) {return l->query(x, y);}\r\n        if(x>m) {return r->query(x, y);}\r\n        return combine(l->query(x, m), r->query(m+1, y));\r\n    }\r\n};\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n\tint n, q; cin >> n >> q;\r\n\tnode st(0, n);\r\n\t\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint com, a, b, c; cin >> com >> a >> b;\r\n\t\tif (com == 1){\r\n\t\t\tcin >> c;\r\n\t\t\tst.rangeUpd(a, b, c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << st.query(a, b) << '\\n';\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n"
    },
    {
        "username": "shoryu386",
        "id": 148150,
        "date": "2022-09-20 18:44:30",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long stdata;\r\ninline stdata combine(stdata a, stdata b){\r\n\treturn a+b;\r\n}\r\nconst stdata defval = 0; //0 for sum, maximum potential value for min, minimum potential value for max, UNLESS there is a specified default value\r\n#define lazyChange (e-s+1)\r\n//if using lazy prop with min or max operations, change lazyChange to 1, otherwise leave as (e-s+1)\r\nstruct node {\r\n    long long s,e,m;\r\n    node *l, *r;\r\n    stdata v;\r\n    stdata lazyUpd; //if doing extreme segtree modification with weird lazy, change this, can't be bothered to overcomplicate\r\n    node(int S_, int E_): s(S_), e(E_), m((s+e)>>1), l(NULL), r(NULL), v(defval), lazyUpd(0) {\r\n\t\t//if(s!=e) { l = new node(s,m); r = new node(m+1,e); }\r\n    }\r\n    \r\n    inline void instL(){\r\n\t\tif (l == NULL) l = new node(s,m);\r\n\t}\r\n\t\r\n\tinline void instR(){\r\n\t\tif (r == NULL) r = new node(m+1,e);\r\n\t}\r\n    \r\n    stdata forceProp(){\r\n\t\tif (s==e) {v+=lazyUpd; lazyUpd = 0; return v;}\r\n\t\tif (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n\t\treturn v;\r\n\t}\r\n    \r\n    void set(int x, stdata y){\r\n        if(s==e) { v=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->set(x,y);\r\n        else l->set(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    void upd(int x, stdata y){\r\n        if(s==e) { v+=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->upd(x,y);\r\n        else l->upd(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    //range operations assume stdata is a numeric type. (yes, floats work :D)\r\n    void rangeUpd(int first, int last, stdata c){\r\n\t\t\r\n\t\t\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazyUpd += c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tinstL(); instR();\r\n\t\tif (first <= m){ l->rangeUpd(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeUpd(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n    \r\n    stdata query(int x, int y){\r\n\t\tif (s==e) {v += lazyUpd; lazyUpd = 0; return v;}\r\n        if (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n        if(x==s && y==e) {return v;}\r\n        if(y<=m) {instL(); return l->query(x, y);}\r\n        if(x>m) {instR(); return r->query(x, y);}\r\n        instL(); instR();\r\n        return combine(l->query(x, m), r->query(m+1, y));\r\n    }\r\n};\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n\tint n, q; cin >> n >> q;\r\n\tnode st(0, n);\r\n\t\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint com, a, b, c; cin >> com >> a >> b;\r\n\t\tif (com == 1){\r\n\t\t\tcin >> c;\r\n\t\t\tst.rangeUpd(a, b, c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << st.query(a, b) << '\\n';\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n"
    },
    {
        "username": "shoryu386",
        "id": 148147,
        "date": "2022-09-20 18:42:15",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long stdata;\r\ninline stdata combine(stdata a, stdata b){\r\n\treturn a+b;\r\n}\r\nconst stdata defval = 0; //0 for sum, maximum potential value for min, minimum potential value for max, UNLESS there is a specified default value\r\n#define lazyChange (e-s+1)\r\n//if using lazy prop with min or max operations, change lazyChange to 1, otherwise leave as (e-s+1)\r\nstruct node {\r\n    long long s,e,m;\r\n    node *l, *r;\r\n    stdata v;\r\n    stdata lazyUpd; //if doing extreme segtree modification with weird lazy, change this, can't be bothered to overcomplicate\r\n    node(int S_, int E_): s(S_), e(E_), m((s+e)>>1), l(NULL), r(NULL), v(defval), lazyUpd(0) {\r\n\t\t//if(s!=e) { l = new node(s,m); r = new node(m+1,e); }\r\n    }\r\n    \r\n    inline void instL(){\r\n\t\tif (l == NULL) l = new node(s,m);\r\n\t}\r\n\t\r\n\tinline void instR(){\r\n\t\tif (r == NULL) r = new node(m+1,e);\r\n\t}\r\n    \r\n    stdata forceProp(){\r\n\t\tif (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n\t\treturn v;\r\n\t}\r\n    \r\n    void set(int x, stdata y){\r\n        if(s==e) { v=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->set(x,y);\r\n        else l->set(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    void upd(int x, stdata y){\r\n        if(s==e) { v+=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->upd(x,y);\r\n        else l->upd(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    //range operations assume stdata is a numeric type. (yes, floats work :D)\r\n    void rangeUpd(int first, int last, stdata c){\r\n\t\t\r\n\t\t\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazyUpd += c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tinstL(); instR();\r\n\t\tif (first <= m){ l->rangeUpd(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeUpd(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n    \r\n    stdata query(int x, int y){\r\n\t\tif (s==e) {v += lazyUpd; lazyUpd = 0; return v;}\r\n        if (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n        if(x==s && y==e) {return v;}\r\n        if(y<=m) {instL(); return l->query(x, y);}\r\n        if(x>m) {instR(); return r->query(x, y);}\r\n        instL(); instR();\r\n        return combine(l->query(x, m), r->query(m+1, y));\r\n    }\r\n};\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n\tint n, q; cin >> n >> q;\r\n\tnode st(0, n);\r\n\t\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint com, a, b, c; cin >> com >> a >> b;\r\n\t\tif (com == 1){\r\n\t\t\tcin >> c;\r\n\t\t\tst.rangeUpd(a, b, c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << st.query(a, b) << '\\n';\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n"
    },
    {
        "username": "shoryu386",
        "id": 148146,
        "date": "2022-09-20 18:41:28",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long stdata;\r\ninline stdata combine(stdata a, stdata b){\r\n\treturn a+b;\r\n}\r\nconst stdata defval = 0; //0 for sum, maximum potential value for min, minimum potential value for max, UNLESS there is a specified default value\r\n#define lazyChange (e-s+1)\r\n//if using lazy prop with min or max operations, change lazyChange to 1, otherwise leave as (e-s+1)\r\nstruct node {\r\n    long long s,e,m;\r\n    node *l, *r;\r\n    stdata v;\r\n    stdata lazyUpd; //if doing extreme segtree modification with weird lazy, change this, can't be bothered to overcomplicate\r\n    node(int S_, int E_): s(S_), e(E_), m((s+e)>>1), l(NULL), r(NULL), v(defval), lazyUpd(0) {\r\n\t\t//if(s!=e) { l = new node(s,m); r = new node(m+1,e); }\r\n    }\r\n    \r\n    inline void instL(){\r\n\t\tif (l == NULL) l = new node(s,m);\r\n\t}\r\n\t\r\n\tinline void instR(){\r\n\t\tif (r == NULL) r = new node(m+1,e);\r\n\t}\r\n    \r\n    stdata forceProp(){\r\n\t\tif (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n\t\treturn v;\r\n\t}\r\n    \r\n    void set(int x, stdata y){\r\n        if(s==e) { v=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->set(x,y);\r\n        else l->set(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    void upd(int x, stdata y){\r\n        if(s==e) { v+=y; return; }\r\n        instL(), instR();\r\n        if(x>m) r->upd(x,y);\r\n        else l->upd(x,y);\r\n        v = combine(l->v, r->v);\r\n    }\r\n    //range operations assume stdata is a numeric type. (yes, floats work :D)\r\n    void rangeUpd(int first, int last, stdata c){\r\n\t\t\r\n\t\t\r\n\t\tif (first <= s && last >= e){\r\n\t\t\tlazyUpd += c;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tinstL(); instR();\r\n\t\tif (first <= m){ l->rangeUpd(first, last, c); }\r\n\t\tif (last >= m+1){ r->rangeUpd(first, last, c); }\r\n\t\tv = combine(l->forceProp(), r->forceProp());\r\n\t}\r\n    \r\n    stdata query(int x, int y){\r\n\t\tif (s==e) {v += lazyUpd; lazyUpd = 0; return v;}\r\n        if (lazyUpd != 0) v += lazyChange*lazyUpd, instL(), instR(), l->lazyUpd += lazyUpd, r->lazyUpd += lazyUpd, lazyUpd = 0;\r\n        if(x==s && y==e) {return v;}\r\n        if(y<=m) {instL(); return l->query(x, y);}\r\n        if(x>m) {instR(); return r->query(x, y);}\r\n        instL(); instR();\r\n        return combine(l->query(x, m), r->query(m+1, y));\r\n    }\r\n};\r\n\r\nint main(){\r\n\t//ios_base::sync_with_stdio(0); cin.tie(0);\r\n\tint n, q; cin >> n >> q;\r\n\tnode st(0, n);\r\n\t\r\n\tfor (int x = 0; x < q; x++){\r\n\t\tint com, a, b, c; cin >> com >> a >> b;\r\n\t\tif (com == 1){\r\n\t\t\tcin >> c;\r\n\t\t\tst.rangeUpd(a, b, c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcout << st.query(a, b) << '\\n';\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n"
    },
    {
        "username": "Hhw48",
        "id": 145646,
        "date": "2022-09-07 12:26:31",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define ll long long\r\n#define ull unsigned long long int\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint32_t main(){\r\nios_base::sync_with_stdio(0);\r\ncin.tie(0);\r\nint n,q;\r\ncin>>n>>q;\r\nroot=new node(0,INT_MAX);\r\nroot->set(0,n-1,0);\r\nfor(int i=0;i<q;i++){\r\n    int x,l,r,k;\r\n    cin>>x;\r\n    if(x==1){\r\n      cin>>l>>r>>k;\r\n      root->add(l,r,k);  \r\n    }\r\n    else{\r\n        cin>>l>>r;\r\n        cout<<root->range_sum(l, r)<<'\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "hmm",
        "id": 142755,
        "date": "2022-08-24 20:40:18",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define INF 1000000000000000000\r\n#define EPS 1e-9\r\n#define MOD 1000000007\r\n\r\nstruct node {\r\n\tint s, e, m, v, lz;\r\n\tnode *l, *r;\r\n\tnode(int _s, int _e) {\r\n\t\ts = _s, e = _e, v = 0, lz = 0;\r\n\t\tm = (s+e)/2;\r\n\t\tl = nullptr, r = nullptr;\r\n\t}\r\n\tvoid prop() {\r\n\t\tif(lz == 0) return;\r\n\t\tv += lz*(e-s+1);\r\n\t\tif(s != e) {\r\n\t\t\tif(l == nullptr) l = new node(s, m);\r\n\t\t\tif(r == nullptr) r = new node(m+1, e);\r\n\t\t\tl->lz += lz;\r\n\t\t\tr->lz += lz;\r\n\t\t}\r\n\t\tlz = 0;\r\n\t}\r\n\tvoid update(int x, int y, int val) {\r\n\t\tif(x <= s && e <= y) {lz += val; return;}\r\n\t\telse if(x > m) {\r\n\t\t\tif(r == nullptr) r = new node(m+1, e);\r\n\t\t\tr->update(x, y, val);\r\n\t\t} else if(y <= m) {\r\n\t\t\tif(l == nullptr) l = new node(s, m);\r\n\t\t\tl->update(x, y, val);\r\n\t\t} else {\r\n\t\t\tif(l == nullptr) l = new node(s, m);\r\n\t\t\tif(r == nullptr) r = new node(m+1, e);\r\n\t\t\tl->update(x, y, val);\r\n\t\t\tr->update(x, y, val);\r\n\t\t}\r\n\t\tv = 0;\r\n\t\tif(l != nullptr) l->prop(), v += l->v;\r\n\t\tif(r != nullptr) r->prop(), v += r->v;\r\n\t}\r\n\tint rsum(int x, int y) {\r\n\t\tprop();\r\n\t\tif(x <= s && e <= y) return v;\r\n\t\telse if(x > m) {\r\n\t\t\tif(r == nullptr) return 0;\r\n\t\t\treturn r->rsum(x, y);\r\n\t\t} else if(y <= m) {\r\n\t\t\tif(l == nullptr) return 0;\r\n\t\t\treturn l->rsum(x, y);\r\n\t\t} else {\r\n\t\t\tif(l == nullptr && r == nullptr) return 0;\r\n\t\t\telse if(l == nullptr) return r->rsum(x, y);\r\n\t\t\telse if(r == nullptr) return l->rsum(x, y);\r\n\t\t\telse return l->rsum(x, y) + r->rsum(x, y);\r\n\t\t}\r\n\t}\r\n} *root;\r\n\t\t\r\n\r\nint32_t main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0); cout.tie(0);\r\n\tint n, q, a, l, r, k;\r\n\tcin >> n >> q;\r\n\troot = new node(1, n);\r\n\tfor(int i = 0; i < q; i++) {\r\n\t\tcin >> a;\r\n\t\tif(a == 1) {\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\troot->update(l, r, k);\r\n\t\t} else if(a == 2) {\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->rsum(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "crapthecoder",
        "id": 140334,
        "date": "2022-08-11 22:22:13",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define endl '\\n'\r\n#define int long long\r\n\r\nconst int MOD = 1e9 + 7;\r\nconst int INF = LLONG_MAX >> 1;\r\n\r\nstruct Query {\r\n    int t, l, r, k;\r\n};\r\n\r\nclass SegTree {\r\n    int n;\r\n    vector<pair<int, int>> tree;\r\n    vector<int> lazy;\r\n\r\n    void push(int i, int l, int r) {\r\n        tree[i].first += tree[i].second * lazy[i];\r\n        if (l != r) {\r\n            int m = (l + r) >> 1;\r\n            int lc = i+1, rc = i + 2 * (m-l+1);\r\n            lazy[lc] += lazy[i]; lazy[rc] += lazy[i];\r\n        }\r\n\r\n        lazy[i] = 0;\r\n    }\r\n\r\n    void build(int i, int l, int r, const vector<pair<int, int>> &a) {\r\n        if (l == r) {\r\n            tree[i] = a[l];\r\n            return;\r\n        }\r\n\r\n        int m = (l + r) >> 1;\r\n        int lc = i+1, rc = i + 2 * (m-l+1);\r\n\r\n        build(lc, l, m, a);\r\n        build(rc, m+1, r, a);\r\n\r\n        tree[i] = unite(tree[lc], tree[rc]);\r\n    }\r\n\r\n    void update_range(int i, int l, int r, int a, int b, int v) {\r\n        push(i, l, r);\r\n\r\n        if (a <= l && r <= b) {\r\n            lazy[i] += v;\r\n            push(i, l, r);\r\n            return;\r\n        }\r\n\r\n        int m = (l + r) >> 1;\r\n        int lc = i+1, rc = i + 2 * (m-l+1);\r\n\r\n        if (a <= m) update_range(lc, l, m, a, b, v);\r\n        if (m < b) update_range(rc, m+1, r, a, b, v);\r\n\r\n        push(lc, l, m); push(rc, m+1, r);\r\n        tree[i] = unite(tree[lc], tree[rc]);\r\n    }\r\n\r\n    pair<int, int> query(int i, int l, int r, int a, int b) {\r\n        push(i, l, r);\r\n\r\n        if (a <= l && r <= b)\r\n            return tree[i];\r\n\r\n        int m = (l + r) >> 1;\r\n        int lc = i+1, rc = i + 2 * (m-l+1);\r\n\r\n        if (b <= m) return query(lc, l, m, a, b);\r\n        if (m < a) return query(rc, m+1, r, a, b);\r\n\r\n        return unite(query(lc, l, m, a, b), query(rc, m+1, r, a, b));\r\n    }\r\n\r\n    pair<int, int> unite(pair<int, int> a, pair<int, int> b) {\r\n        return {a.first + b.first, a.second + b.second};\r\n    }\r\n\r\npublic:\r\n    SegTree(vector<pair<int, int>> a): n(a.size()), tree(2 * a.size()), lazy(2 * a.size()) {\r\n        build(0, 0, n-1, a);\r\n    }\r\n\r\n    pair<int, int> query(int a, int b) {\r\n        return query(0, 0, n-1, a, b);\r\n    }\r\n\r\n    void update_range(int a, int b, int v) {\r\n        update_range(0, 0, n-1, a, b, v);\r\n    }\r\n};\r\n\r\nsigned main() {\r\n    ios::sync_with_stdio(false); cin.tie(NULL);\r\n\r\n    int n, qr; cin >> n >> qr;\r\n\r\n    set<int> ranges = {1, n};\r\n    vector<Query> queries;\r\n\r\n    while (qr--) {\r\n        Query q;\r\n        cin >> q.t >> q.l >> q.r;\r\n\r\n        if (q.t == 1)\r\n            cin >> q.k;\r\n\r\n        ranges.insert(q.l);\r\n        ranges.insert(q.l-1);\r\n        ranges.insert(q.l+1);\r\n        ranges.insert(q.r);\r\n        ranges.insert(q.r-1);\r\n        ranges.insert(q.r+1);\r\n        queries.push_back(q);\r\n    }\r\n\r\n    map<int, int> f; int cur = 0;\r\n    for (auto i: ranges)\r\n        f[i] = cur++;\r\n\r\n    vector<pair<int, int>> nodes;\r\n    for (auto it = ranges.begin(); it != --ranges.end(); ++it) {\r\n        auto jt = it;\r\n        int l = *jt, r = *(++jt);\r\n        nodes.push_back({0, r-l});\r\n    }\r\n\r\n    SegTree seg(nodes);\r\n\r\n    for (auto [t, l, r, k]: queries) {\r\n        if (t == 1) {\r\n            seg.update_range(f[l], f[r], k);\r\n\r\n        } else {\r\n            cout << seg.query(f[l], f[r]).first << endl;\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "Reverberate",
        "id": 139305,
        "date": "2022-08-07 18:55:18",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    int x,n,q,t,a,b,c;\r\n    cin>>n>>q;\r\n    root = new node(0, n);\r\n    for(x=0;x<q;x++){\r\n        cin>>t;\r\n        if(t==1){\r\n            cin>>a>>b>>c;\r\n            root->add(a, b, c);\r\n        }\r\n        else{\r\n            cin>>a>>b;\r\n            cout << root->range_sum(a, b) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "AlphanumericUsername",
        "id": 137139,
        "date": "2022-07-28 20:13:52",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nint sum = 0;\r\ntypedef long long ll;\r\nstruct node {\r\n  int s, e;\r\n  ll mn, mx, sum;\r\n  bool lset;\r\n  ll add_val, set_val;\r\n  node *l, *r;\r\n  node(int _s, int _e, int A[] = NULL)\r\n      : s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0),\r\n        l(NULL), r(NULL) {\r\n    if (A == NULL)\r\n      return;\r\n    if (s == e)\r\n      mn = mx = sum = A[s];\r\n    else {\r\n      l = new node(s, (s + e) >> 1, A), r = new node((s + e + 2) >> 1, e, A);\r\n      combine();\r\n    }\r\n  }\r\n  void create_children() {\r\n    if (s == e)\r\n      return;\r\n    if (l != NULL)\r\n      return;\r\n    int m = (s + e) >> 1;\r\n    l = new node(s, m);\r\n    r = new node(m + 1, e);\r\n  }\r\n  void self_set(ll v) {\r\n    lset = 1;\r\n    mn = mx = set_val = v;\r\n    sum = v * (e - s + 1);\r\n    add_val = 0;\r\n  }\r\n  void self_add(ll v) {\r\n    if (lset) {\r\n      self_set(v + set_val);\r\n      return;\r\n    }\r\n    mn += v, mx += v, add_val += v;\r\n    sum += v * (e - s + 1);\r\n  }\r\n  void lazy_propagate() {\r\n    if (s == e)\r\n      return;\r\n    if (lset) {\r\n      l->self_set(set_val), r->self_set(set_val);\r\n      lset = set_val = 0;\r\n    }\r\n    if (add_val != 0) {\r\n      l->self_add(add_val), r->self_add(add_val);\r\n      add_val = 0;\r\n    }\r\n  }\r\n  void combine() {\r\n    if (l == NULL)\r\n      return;\r\n    sum = l->sum + r->sum;\r\n    mn = min(l->mn, r->mn);\r\n    mx = max(l->mx, r->mx);\r\n  }\r\n  void add(int x, int y, ll v) {\r\n    if (s == x && e == y) {\r\n      self_add(v);\r\n      return;\r\n    }\r\n    int m = (s + e) >> 1;\r\n    create_children();\r\n    lazy_propagate();\r\n    if (x <= m)\r\n      l->add(x, min(y, m), v);\r\n    if (y > m)\r\n      r->add(max(x, m + 1), y, v);\r\n    combine();\r\n  }\r\n  void set(int x, int y, ll v) {\r\n    if (s == x && e == y) {\r\n      self_set(v);\r\n      return;\r\n    }\r\n    int m = (s + e) >> 1;\r\n    create_children();\r\n    lazy_propagate();\r\n    if (x <= m)\r\n      l->set(x, min(y, m), v);\r\n    if (y > m)\r\n      r->set(max(x, m + 1), y, v);\r\n    combine();\r\n  }\r\n  ll range_sum(int x, int y) {\r\n    if (s == x && e == y)\r\n      return sum;\r\n    if (l == NULL || lset)\r\n      return (sum / (e - s + 1)) * (y - x + 1);\r\n    int m = (s + e) >> 1;\r\n    lazy_propagate();\r\n    if (y <= m)\r\n      return l->range_sum(x, y);\r\n    if (x > m)\r\n      return r->range_sum(x, y);\r\n    return l->range_sum(x, m) + r->range_sum(m + 1, y);\r\n  }\r\n  ll range_min(int x, int y) {\r\n    if (s == x && e == y)\r\n      return mn;\r\n    if (l == NULL || lset)\r\n      return mn;\r\n    int m = (s + e) >> 1;\r\n    lazy_propagate();\r\n    if (y <= m)\r\n      return l->range_min(x, y);\r\n    if (x > m)\r\n      return r->range_min(x, y);\r\n    return min(l->range_min(x, m), r->range_min(m + 1, y));\r\n  }\r\n  ll range_max(int x, int y) {\r\n    if (s == x && e == y)\r\n      return mx;\r\n    if (l == NULL || lset)\r\n      return mx;\r\n    int m = (s + e) >> 1;\r\n    lazy_propagate();\r\n    if (y <= m)\r\n      return l->range_max(x, y);\r\n    if (x > m)\r\n      return r->range_max(x, y);\r\n    return max(l->range_max(x, m), r->range_max(m + 1, y));\r\n  }\r\n  ~node() {\r\n    if (l != NULL)\r\n      delete l;\r\n    if (r != NULL)\r\n      delete r;\r\n  }\r\n} * root;\r\nint32_t main() {\r\n  ios::sync_with_stdio(0);\r\n  cin.tie(NULL);\r\n  cout.tie(NULL);\r\n  int n, q;\r\n  cin >> n >> q;\r\n  root = new node(0, 10000000000);\r\n  int a, b, c;\r\n  for (int i = 0; i < q; ++i) {\r\n    cin >> a >> b >> c;\r\n    if (a == 1) {\r\n      int d;\r\n      cin >> d;\r\n      root->add(b, c, d);\r\n    } else {\r\n      sum = 0;\r\n      root->range_sum(b, c);\r\n      cout << root->range_sum(b,c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "Josh28acc2",
        "id": 135128,
        "date": "2022-07-21 20:24:01",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n  int leng;\r\n  int qNum;\r\n  cin >> leng;\r\n  cin >> qNum;\r\n  root = new node(0, 1000000000);\r\n  int hold1;\r\n  int hold2;\r\n  int hold3;\r\n  int hold4;\r\n  for (int q = 0; q < qNum; q++) {\r\n    cin >> hold1;\r\n    cin >> hold2;\r\n    cin >> hold3;\r\n    if (hold1 == 1) {\r\n      cin >> hold4;\r\n      root->add(hold2-1, hold3-1, hold4);\r\n    } else {\r\n      cout << root->range_sum(hold2-1, hold3-1) << \"\\n\";\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "elainagrey",
        "id": 134732,
        "date": "2022-07-19 15:47:06",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef pair<ll,ll> ii;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\n\r\nll n,q,k,a,b,v;\r\nint main(){\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n    cin>>n>>q;\r\n\troot = new node(0, 1100000000);\r\n    while(q--){\r\n    \tcin>>k;\r\n    \tif(k==1){\r\n    \t\tcin>>a>>b>>v;\r\n\t\t\troot->add(a, b, v);\r\n    \t}else{\r\n    \t\tcin>>a>>b;\r\n    \t\tcout<<root->range_sum(a, b)<<endl;\r\n    \t}\r\n    }\r\n}\r\n\r\n"
    },
    {
        "username": "beepbeepsheep",
        "id": 131977,
        "date": "2022-07-06 00:35:29",
        "code": "\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n#define ll long long\r\ntypedef pair<ll,ll> ii;\r\nconst ll inf=1e15;\r\n\r\nstruct node{\r\n    ll s,e,m,val,flag;\r\n    node *l,*r;\r\n    node(ll _s,ll _e):s(_s),e(_e),m((s+e)/2),val(0),flag(0){\r\n        l= nullptr;\r\n        r= nullptr;\r\n    }\r\n    ~node(){\r\n        delete l;\r\n        delete r;\r\n    }\r\n    void create(){\r\n        if (s!=e)\r\n            l=new node(s,m),r=new node(m+1,e);\r\n    }\r\n    void propagate(){\r\n        if (!flag) return;\r\n        val+=flag*(e-s+1);\r\n        if (e==s){\r\n            flag=0;\r\n            return;\r\n        }\r\n        if (!l) create();\r\n        l->flag+=flag;\r\n        r->flag+=flag;\r\n        flag=0;\r\n    }\r\n    void update(ll x, ll y, ll v){\r\n        if (x<=s && e<=y){\r\n            flag+=v;\r\n            return;\r\n        }\r\n        if (!r) create();\r\n        if (x>m){\r\n            r->update(x,y,v);\r\n        }\r\n        else if (y<=m){\r\n            l->update(x,y,v);\r\n        }\r\n        else{\r\n            l->update(x,y,v),r->update(x,y,v);\r\n        }\r\n        l->propagate(); r->propagate();\r\n        val=l->val+r->val;\r\n    }\r\n    ll query(ll x, ll y){\r\n        if (!l) create();\r\n        propagate();\r\n        if (x<=s && e<=y){\r\n            return val;\r\n        }\r\n        if (x>m){\r\n            return r->query(x,y);\r\n        } else if (y<=m){\r\n            return l->query(x,y);\r\n        } else{\r\n            return l->query(x,y)+r->query(x,y);\r\n        }\r\n    }\r\n}*root;\r\nint main(){\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    ll n,q,a,b,c,d;\r\n    cin>>n>>q;\r\n    root=new node(1,n);\r\n    for (int i=0;i<q;i++){\r\n        cin>>a;\r\n        if (a==1){\r\n            cin>>b>>c>>d;\r\n            root->update(b,c,d);\r\n        } else{\r\n            cin>>b>>c;\r\n            cout<<root->query(b,c)<<'\\n';\r\n        }\r\n    }\r\n    delete root;\r\n    return 0;\r\n}"
    },
    {
        "username": "Wenkai",
        "id": 131976,
        "date": "2022-07-06 00:29:39",
        "code": "#include <bits/stdc++.h>\r\n#define ll long long\r\n#define ull unsigned long long\r\n#define ii pair<int, int>\r\n#define llll pair<ll, ll>\r\n#define INF LLONG_MAX\r\n#define fast_input ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n\r\nusing namespace std;\r\n\r\n#define int ll\r\n\r\nstruct node {\r\n    int s, e, m;\r\n    node *l, *r;\r\n    int val;\r\n    int lazy;\r\n\r\n    void create_lr() {\r\n        if (s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m + 1, e);\r\n        }\r\n    }\r\n\r\n    node(int S, int E) { \r\n        s = S, e = E, m = (s + e) / 2;\r\n        val = 0; // change if necessary\r\n        lazy = 0;\r\n    }\r\n\r\n    void propogate() {\r\n        if (lazy == 0) return;\r\n        val += lazy * (e - s + 1);\r\n        if (s != e) { \r\n            if (l == nullptr) create_lr();\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\n    void update(int S, int E, int V) {\r\n        if (s == S && e == E) lazy += V;\r\n        else {\r\n            if (l == nullptr) create_lr();\r\n            if (E <= m) l->update(S, E, V);\r\n            else if (m < S) r->update(S, E, V);\r\n            else l->update(S, m, V), r->update(m + 1, E, V);\r\n\r\n            l->propogate();\r\n            r->propogate();\r\n            val = l->val + r->val; // change if necessary\r\n        }\r\n    }\r\n\r\n    int query(int S, int E) {\r\n        if (l == nullptr) create_lr();\r\n        propogate();\r\n        if (s == S && e == E) return val; \r\n        else if (E <= m) return l->query(S, E);\r\n        else if (S >= m+1) return r->query(S, E);\r\n        else return l->query(S, m) + r->query(m + 1, E); // change if necessary\r\n    }\r\n};\r\n\r\nint32_t main() {\r\n    fast_input;\r\n    int N, Q;\r\n    cin >> N >> Q;\r\n    node* root = new node(1, N);\r\n    int type = 0, a = 0, b = 0, x = 0;\r\n    for (int i = 0; i < Q; i++) {\r\n        cin >> type;\r\n        if (type == 1) {\r\n            cin >> a >> b >> x;\r\n            root->update(a, b, x);\r\n        } \r\n        else {\r\n            cin >> a >> b;\r\n            cout << root->query(a, b) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "LCJLY",
        "id": 124776,
        "date": "2022-06-09 22:40:43",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n \r\n#define ull unsigned long long\r\n#define unint unsigned int\r\n#define sint short int\r\n#define usint unsigned short int\r\n#define ll long long\r\n#define vt vector\r\n#define pb push_back\r\n#define mp make_pair\r\n#define PI 3.14159265358979323\r\n#define F first\r\n#define S second \r\n#define all(a) (a).begin(), (a).end()\r\n#define sz(a) ((int)a.size())\r\n#define clr(x,a) memset(x, a, sizeof(x))\r\n#define len(a) ((int)a.length())\r\n#define E 2.7182818284590452353602874713527\r\n#define FOR(i, x) for(int i=0; i<x; ++i)\r\n#define For(i, x) for(auto& i: x)\r\n#define RFOR(i, x) for(int i=x-1; i>=0; --i) \r\n#define FORS(x, s, e, n) for(int x=s; x<=e; x+=n) \r\n\r\ntypedef pair<int, int> pii;\r\n \r\nvoid solve(){\r\n}\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    int a,b;\r\n    cin >> a >> b;\r\n    root = new node(0, a+1);\r\n    for(int x=0;x<b;x++){\r\n        int temp;\r\n        cin >> temp;\r\n        if(temp==2){\r\n            int temp2,temp3;\r\n            cin >> temp2 >> temp3;\r\n            cout << root->range_sum(temp2,temp3) << \"\\n\";\r\n        }\r\n        else{\r\n            int temp2,temp3,temp4;\r\n            cin >> temp2 >> temp3 >> temp4;\r\n            root->add(temp2,temp3,temp4);\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "LCJLY",
        "id": 124775,
        "date": "2022-06-09 22:38:26",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n \r\n#define ull unsigned long long\r\n#define unint unsigned int\r\n#define sint short int\r\n#define usint unsigned short int\r\n#define ll long long\r\n#define vt vector\r\n#define pb push_back\r\n#define mp make_pair\r\n#define PI 3.14159265358979323\r\n#define F first\r\n#define S second \r\n#define all(a) (a).begin(), (a).end()\r\n#define sz(a) ((int)a.size())\r\n#define clr(x,a) memset(x, a, sizeof(x))\r\n#define len(a) ((int)a.length())\r\n#define E 2.7182818284590452353602874713527\r\n#define FOR(i, x) for(int i=0; i<x; ++i)\r\n#define For(i, x) for(auto& i: x)\r\n#define RFOR(i, x) for(int i=x-1; i>=0; --i) \r\n#define FORS(x, s, e, n) for(int x=s; x<=e; x+=n) \r\n\r\ntypedef pair<int, int> pii;\r\n \r\nvoid solve(){\r\n}\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n \r\nint main() {\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    int a,b;\r\n    cin >> a >> b;\r\n    root = new node(0, a+1);\r\n    for(int x=0;x<b;x++){\r\n        int temp;\r\n        cin >> temp;\r\n        if(temp==2){\r\n            int temp2,temp3;\r\n            cin >> temp2 >> temp3;\r\n            cout << root->range_sum(temp2,temp3) << \"\\n\";\r\n        }\r\n        else{\r\n            int temp2,temp3,temp4;\r\n            cin >> temp2 >> temp3 >> temp4;\r\n            root->add(temp2,temp3,temp4);\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "shoryu386",
        "id": 124548,
        "date": "2022-06-09 11:07:15",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n  ios_base::sync_with_stdio(0); cin.tie(0);\r\n  int n, q, a,b,c,d;; cin >> n >> q;\r\n  root = new node(1, n+2);\r\n  for (int x = 0; x < q; x++){\r\n    cin >> a;\r\n    if (a==1){\r\n      cin >> b>>c>>d;\r\n      root->add(b, c, d);\r\n    }\r\n    else{\r\n      cin >> b >> c;\r\n      cout << root->range_sum(b, c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "shoryu386",
        "id": 124547,
        "date": "2022-06-09 11:06:48",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n  int n, q, a,b,c,d;; cin >> n >> q;\r\n  root = new node(1, n+2);\r\n  for (int x = 0; x < q; x++){\r\n    cin >> a;\r\n    if (a==1){\r\n      cin >> b>>c>>d;\r\n      root->add(b, c, d);\r\n    }\r\n    else{\r\n      cin >> b >> c;\r\n      cout << root->range_sum(b, c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "shoryu386",
        "id": 124546,
        "date": "2022-06-09 11:06:06",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n  int n, q, a,b,c,d;; cin >> n >> q;\r\n  root = new node(1, n+2);\r\n  for (int x = 0; x < q; x++){\r\n    cin >> a;\r\n    if (a==1){\r\n      cin >> b>>c>>d;\r\n      root->add(b, c, d);\r\n    }\r\n    else{\r\n      cin >> b >> c;\r\n      cout << root->range_sum(b, c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "shoryu386",
        "id": 124536,
        "date": "2022-06-09 10:58:05",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n  ios_base::sync_with_stdio(0); cin.tie(0);\r\n  int n, q, a,b,c,d;; cin >> n >> q;\r\n  root = new node(1, n+2);\r\n  for (int x = 0; x < q; x++){\r\n    cin >> a;\r\n    if (a==1){\r\n      cin >> b>>c>>d;\r\n      root->add(b, c, d);\r\n    }\r\n    else{\r\n      cin >> b >> c;\r\n      cout << root->range_sum(b, c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "shoryu386",
        "id": 124535,
        "date": "2022-06-09 10:56:57",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n  ios_base::sync_with_stdio(0); cin.tie(0);\r\n  int n, q, a,b,c,d;; cin >> n >> q;\r\n  root = new node(1, 1000000000);\r\n  for (int x = 0; x < q; x++){\r\n    cin >> a;\r\n    if (a==1){\r\n      cin >> b>>c>>d;\r\n      root->add(b, c, d);\r\n    }\r\n    else{\r\n      cin >> b >> c;\r\n      cout << root->range_sum(b, c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "shoryu386",
        "id": 124534,
        "date": "2022-06-09 10:55:42",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n  int n, q; cin >> n >> q;\r\n  root = new node(1, 1000000000);\r\n  for (int x = 0; x < q; x++){\r\n    int a,b,c,d;\r\n    cin >> a;\r\n    if (a==1){\r\n      cin >> b>>c>>d;\r\n      root->add(b, c, d);\r\n    }\r\n    else{\r\n      cin >> b >> c;\r\n      cout << root->range_sum(b, c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "shoryu386",
        "id": 124533,
        "date": "2022-06-09 10:55:12",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(false); cin.tie(NULL);\r\n  int n, q; cin >> n >> q;\r\n  root = new node(1, 1000000000);\r\n  for (int x = 0; x < q; x++){\r\n    int a,b,c,d;\r\n    cin >> a;\r\n    if (a==1){\r\n      cin >> b>>c>>d;\r\n      root->add(b, c, d);\r\n    }\r\n    else{\r\n      cin >> b >> c;\r\n      cout << root->range_sum(b, c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "shoryu386",
        "id": 124532,
        "date": "2022-06-09 10:54:04",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n  int n, q; cin >> n >> q;\r\n  root = new node(1, 1000000000);\r\n  for (int x = 0; x < q; x++){\r\n    int a,b,c,d;\r\n    cin >> a;\r\n    if (a==1){\r\n      cin >> b>>c>>d;\r\n      root->add(b, c, d);\r\n    }\r\n    else{\r\n      cin >> b >> c;\r\n      cout << root->range_sum(b, c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "shoryu386",
        "id": 124529,
        "date": "2022-06-09 10:52:34",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n  int n, q; cin >> n >> q;\r\n  root = new node(0, INT_MAX/2);\r\n  for (int x = 0; x < q; x++){\r\n    int a,b,c,d;\r\n    cin >> a;\r\n    if (a==1){\r\n      cin >> b>>c>>d;\r\n      root->add(b, c, d);\r\n    }\r\n    else{\r\n      cin >> b >> c;\r\n      cout << root->range_sum(b, c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "shoryu386",
        "id": 124528,
        "date": "2022-06-09 10:52:03",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n  int n, q; cin >> n >> q;\r\n  root = new node(0, n+1);\r\n  for (int x = 0; x < q; x++){\r\n    int a,b,c,d;\r\n    cin >> a;\r\n    if (a==1){\r\n      cin >> b>>c>>d;\r\n      root->add(b, c, d);\r\n    }\r\n    else{\r\n      cin >> b >> c;\r\n      cout << root->range_sum(b, c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "shoryu386",
        "id": 121951,
        "date": "2022-06-02 21:58:32",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n  int n, q; cin >> n >> q;\r\n  root = new node(0, n+1);\r\n  for (int x = 0; x < q; x++){\r\n    int a,b,c,d;\r\n    cin >> a;\r\n    if (a==1){\r\n      cin >> b>>c>>d;\r\n      root->add(b, c, d);\r\n    }\r\n    else{\r\n      cin >> b >> c;\r\n      cout << root->range_sum(b, c) << '\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "Josh28",
        "id": 119748,
        "date": "2022-05-20 15:58:34",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n  int leng;\r\n  int qNum;\r\n  cin >> leng;\r\n  cin >> qNum;\r\n  root = new node(0, 1000000000);\r\n  int hold1;\r\n  int hold2;\r\n  int hold3;\r\n  int hold4;\r\n  for (int q = 0; q < qNum; q++) {\r\n    cin >> hold1;\r\n    cin >> hold2;\r\n    cin >> hold3;\r\n    if (hold1 == 1) {\r\n      cin >> hold4;\r\n      root->add(hold2-1, hold3-1, hold4);\r\n    } else {\r\n      cout << root->range_sum(hold2-1, hold3-1) << \"\\n\";\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "wangy412",
        "id": 106759,
        "date": "2022-02-17 10:14:37",
        "code": "#include <bits/stdc++.h>\r\n#define int long long \r\nusing namespace std;\r\n\r\nstruct node {\r\n    int s, e, m, v, lazy;\r\n    node *l, *r;\r\n\r\n    node(int _s, int _e) {\r\n        s = _s;\r\n        e = _e;\r\n        m = (s+e)/2;\r\n        v = 0;\r\n        lazy = 0;\r\n        l = r = nullptr;\r\n    }\r\n\r\n    void create() {\r\n        if (s != e && l == nullptr) {\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n\r\n    void propogate() {\r\n        create();\r\n        if (lazy == 0) return;\r\n        v += lazy * (e-s+1);\r\n        if (s != e) {\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\n    void update(int _s, int _e, int _v) {\r\n        create();\r\n        if (s == _s && e == _e) lazy += _v;\r\n        else {    \r\n            if (_e <= m) l->update(_s, _e, _v);\r\n            else if (_s > m) r->update(_s, _e, _v);\r\n            else l->update(_s, m, _v), r->update(m+1, _e, _v);\r\n            l->propogate(), r->propogate();\r\n            v = l->v + r->v;\r\n        }\r\n    }\r\n\r\n    int query(int _s, int _e) {\r\n        propogate();\r\n        if (s == _s && e == _e) return v;\r\n        else if (_e <= m) return l->query(_s, _e);\r\n        else if (_s > m) return r->query(_s, _e);\r\n        else return l->query(_s, m) + r->query(m+1, _e);\r\n    }\r\n} *root;\r\nint n, q;\r\nint32_t main() {\r\n    cin >> n >> q;\r\n    root = new node(1, n);\r\n    for (int i = 0; i < q; i++) {\r\n        int x; cin >> x;\r\n        if (x == 1) {\r\n            int l, r, k; cin >> l >> r >> k;\r\n            root->update(l, r, k);\r\n        } else {\r\n            int l, r; cin >> l >> r;\r\n            cout << root->query(l, r) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "adityaagarwal",
        "id": 106687,
        "date": "2022-02-16 23:07:04",
        "code": "// Krishnaya vaasudevaya\r\n// Devaki nandanayacha\r\n// Nanda gopakumaraya\r\n// Govindaya namoh namaha\r\n// Jay ganeshji, Jay Guruji, Jay Ram-bhakt Hanumanji\r\n\r\n#include<bits/stdc++.h>\r\n#include<ext/pb_ds/assoc_container.hpp>\r\n#include<ext/pb_ds/tree_policy.hpp>\r\n\r\n#define ff first\r\n#define ss second\r\n\r\n#define pb emplace_back\r\n#define eb emplace\r\n\r\n// Competion only\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n\r\nusing ll = long long;\r\nusing ull = unsigned ll;\r\n\r\nusing pii = pair<int, int>;\r\nusing pll = pair<ll, ll>;\r\nusing vi = vector<int>;\r\nusing vl = vector<ll>;\r\nusing vii = vector<pii>;\r\nusing vll = vector<pll>;\r\n\r\nconst int inf = 1e9 + 7;\r\nconst ll llinf = 1e18 + 7;\r\n\r\nconstexpr ll mod = 1e9 + 7;\r\n\r\nconst vector<pii> dirs4 = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\r\nconst vector<pii> dirs8 = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\r\n\r\ntemplate<typename T>\r\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\r\n\r\nll fastPow(ll a, ll b)\r\n{\r\n\tll res = 1;\r\n\twhile(b) {\r\n\t\tif(b & 1)\r\n\t\t\tres *= a;\r\n\t\ta *= a, b >>= 1;\r\n\t}\r\n\treturn res;\r\n}\r\n\r\nll fastPow(ll a, ll b, ll m)\r\n{\r\n\tll res = 1;\r\n\ta %= m;\r\n\twhile(b) {\r\n\t\tif(b & 1)\r\n\t\t\t(res *= a) %= m;\r\n\t\t(a *= a) %= m, b >>= 1;\r\n\t}\r\n\treturn res;\r\n}\r\n\r\nll modinv(ll x, ll m)\r\n{\r\n\treturn fastPow(x, m - 2, m);\r\n}\r\n\r\nll moddiv(ll numerator, ll denominator, ll m) {\r\n\treturn numerator * modinv(denominator, m);\r\n}\r\n\r\ntemplate<typename T>\r\ninline void maximize(T &trg, T src) {\r\n\ttrg = max(trg, src);\r\n}\r\n\r\ntemplate<typename T>\r\ninline void minimize(T &trg, T src) {\r\n\ttrg = min(trg, src);\r\n}\r\n\r\ntemplate<typename T>\r\nconstexpr ostream &operator<<(ostream &stream, const vector<T> &other) {\r\n\tstream << '[';\r\n\tsize_t n = other.size();\r\n\r\n\tif(n > 0) {\r\n\t\tfor(size_t i = 0; i < n - 1; i++)\r\n\t\t\tstream << other[i] << \", \";\r\n\t\tstream << other[n - 1];\r\n\t}\r\n\r\n\treturn stream << ']';\r\n}\r\n\r\ntemplate<typename T>\r\nconstexpr ostream &operator<<(ostream &stream, const set<T> &other) {\r\n\tstream << '{';\r\n\r\n\tsize_t n = other.size();\r\n\r\n\tif(n > 0) {\r\n\t\tauto it = other.begin();\r\n\t\tfor(size_t i = 0; i < n-1; i++)\r\n\t\t\tstream << *it << \", \", ++it;\r\n\t\tstream << *it;\r\n\t}\r\n\r\n\treturn stream << '}';\r\n}\r\n\r\ntemplate<typename T>\r\nconstexpr ostream &operator<<(ostream &stream, const multiset<T> &other) {\r\n\tstream << '{';\r\n\r\n\tsize_t n = other.size();\r\n\r\n\tif(n > 0) {\r\n\t\tauto it = other.begin();\r\n\t\tfor(size_t i = 0; i < n-1; i++)\r\n\t\t\tstream << *it << \", \", ++it;\r\n\t\tstream << *it;\r\n\t}\r\n\r\n\treturn stream << '}';\r\n}\r\n\r\ntemplate<typename T>\r\nconstexpr ostream &operator<<(ostream &stream, const ordered_set<T> &other) {\r\n\tstream << '{';\r\n\r\n\tsize_t n = other.size();\r\n\r\n\tif(n > 0) {\r\n\t\tauto it = other.begin();\r\n\t\tfor(size_t i = 0; i < n-1; i++)\r\n\t\t\tstream << *it << \", \", ++it;\r\n\t\tstream << *it;\r\n\t}\r\n\r\n\treturn stream << '}';\r\n}\r\n\r\ntemplate<typename T1, typename T2>\r\nconstexpr ostream &operator<<(ostream &stream, const map<T1, T2> &other) {\r\n\tstream << '{';\r\n\r\n\tsize_t n = other.size();\r\n\r\n\tif(n > 0) {\r\n\t\tauto it = other.begin();\r\n\t\tfor(size_t i = 0; i < n-1; i++)\r\n\t\t\tstream << (*it).first << ':' << (*it).second << \", \", ++it;\r\n\t\tstream << (*it).first << ':' << (*it).second;\r\n\t}\r\n\r\n\treturn stream << '}';\r\n}\r\n\r\ntemplate<typename T1, typename T2>\r\nconstexpr ostream &operator<<(ostream &stream, const multimap<T1, T2> &other) {\r\n\tstream << '{';\r\n\r\n\tsize_t n = other.size();\r\n\r\n\tif(n > 0) {\r\n\t\tauto it = other.begin();\r\n\t\tfor(size_t i = 0; i < n-1; i++)\r\n\t\t\tstream << (*it).first << ':' << (*it).second << \", \", ++it;\r\n\t\tstream << (*it).first << ':' << (*it).second;\r\n\t}\r\n\r\n\treturn stream << '}';\r\n}\r\n\r\ntemplate<typename T1, typename T2>\r\nconstexpr ostream &operator<<(ostream &stream, const unordered_map<T1, T2> &other) {\r\n\tstream << '{';\r\n\r\n\tsize_t n = other.size();\r\n\r\n\tif(n > 0) {\r\n\t\tauto it = other.begin();\r\n\t\tfor(size_t i = 0; i < n-1; i++)\r\n\t\t\tstream << (*it).first << ':' << (*it).second << \", \", ++it;\r\n\t\tstream << (*it).first << ':' << (*it).second;\r\n\t}\r\n\r\n\treturn stream << '}';\r\n}\r\n\r\ntemplate<typename T1, typename T2>\r\nconstexpr ostream &operator<<(ostream &stream, const pair<T1, T2> &other) {\r\n\treturn stream << '(' << other.first << \", \" << other.second << ')';\r\n}\r\n\r\ntemplate<typename T>\r\nistream &operator>>(istream &stream, vector<T> &other) {\r\n\tfor(auto &e : other)\r\n\t\tstream >> e;\r\n\r\n\treturn stream;\r\n}\r\n\r\ntemplate<typename T1, typename T2>\r\nistream &operator>>(istream &stream, pair<T1, T2> &other) {\r\n\tstream >> other.first >> other.second;\r\n\treturn stream;\r\n}\r\n\r\ntemplate<size_t I = 0, typename ...T>\r\nostream &operator<<(ostream &stream, const tuple<T...> &other) {\r\n\r\n\tif constexpr(I == 0)\r\n\t\tstream << '(';\r\n\r\n\tstream << get<I>(other);\r\n\r\n\tif constexpr(I < sizeof...(T) - 1) {\r\n\t\tstream << \", \";\r\n\t\treturn operator<<<I + 1>(stream, other);\r\n\t}\r\n\treturn stream << ')';\r\n}\r\n\r\nstruct segtree {\r\n\r\n\tstruct node {\r\n\t\tll v{};\r\n\t\tll lz{};\r\n\r\n\t\tnode *lptr{nullptr};\r\n\t\tnode *rptr{nullptr};\r\n\r\n\t\t~node() {\r\n\r\n\t\t\tdelete lptr;\r\n\t\t\tdelete rptr;\r\n\t\t}\r\n\t};\r\n\r\n\r\n\tnode *root{nullptr};\r\n\r\n\tsegtree() {}\r\n\r\n\tvoid pushdown(int l, int mid, int r, node *&cur) {\r\n\r\n\t\tcur->v += (r - l + 1) * cur->lz;\r\n\r\n\t\tif(l != r) {\r\n\t\t\tif(cur->lptr == nullptr)\r\n\t\t\t\tcur->lptr = new node;\r\n\t\t\tcur->lptr->lz += cur->lz;\r\n\r\n\t\t\tif(cur->rptr == nullptr)\r\n\t\t\t\tcur->rptr = new node;\r\n\t\t\tcur->rptr->lz += cur->lz;\r\n\t\t}\r\n\r\n\t\tcur->lz = 0;\r\n\t}\r\n\r\n\tvoid update(int ql, int qr, ll v, int l, int r, node *&cur) {\t\t\r\n\r\n\t\tint mid = (l + r)/2;\r\n\r\n\t\tif(cur == nullptr) {\r\n\t\t\t// cout << \"ALLOCATING FOR \" << pii{l, r} << endl;\r\n\t\t\tcur = new node;\r\n\t\t}\r\n\t\tif(cur->lz != 0) {\r\n\t\t\tpushdown(l, mid, r, cur);\r\n\t\t}\r\n\r\n\t\tif(ql > r or l > qr) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif(ql <= l and r <= qr) {\r\n\r\n\t\t\t// cout << pii{l, r} << endl;\r\n\r\n\t\t\tcur->lz += v;\r\n\t\t\tpushdown(l, mid, r, cur);\r\n\t\t}\r\n\r\n\t\telse {\r\n\t\t\tupdate(ql, qr, v, l, mid, cur->lptr);\r\n\t\t\tupdate(ql, qr, v, 1 + mid, r, cur->rptr);\r\n\r\n\t\t\tcur->v = 0;\r\n\t\t\tif(cur->lptr != nullptr)\r\n\t\t\t\tcur->v += cur->lptr->v;\r\n\t\t\tif(cur->rptr != nullptr)\r\n\t\t\t\tcur->v += cur->rptr->v;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid update(int ql, int qr, int v, int l, int r) {\r\n\t\tupdate(ql, qr, v, l, r, root);\r\n\t}\r\n\r\n\tll qry(int ql, int qr, int l, int r, node *&cur) {\r\n\r\n\t\tint mid = (l + r)/2;\r\n\r\n\t\tif(cur == nullptr) {\r\n\t\t\tcur = new node;\r\n\t\t}\r\n\t\tif(cur->lz != 0) {\r\n\t\t\tpushdown(l, mid, r, cur);\r\n\t\t}\r\n\r\n\t\tif(ql > r or l > qr) {\r\n\t\t\treturn 0LL;\r\n\t\t}\r\n\r\n\t\tif(ql <= l and r <= qr) {\r\n\t\t\treturn cur->v;\r\n\t\t}\r\n\r\n\t\treturn qry(ql, qr, l, mid, cur->lptr) + qry(ql, qr, 1 + mid, r, cur->rptr);\r\n\t}\r\n\r\n\tll qry(int ql, int qr, int l, int r) {\r\n\t\treturn qry(ql, qr, l, r, root);\r\n\t}\r\n\r\n\tvoid show(node *cur) {\r\n\r\n\t\tif(cur == nullptr)\r\n\t\t\treturn;\r\n\r\n\t\tcout << cur->v << endl;\r\n\r\n\t\tshow(cur->lptr);\r\n\t\tshow(cur->rptr);\r\n\t}\r\n\r\n\tvoid show() {\r\n\r\n\t\tshow(root);\r\n\t}\r\n};\r\n\r\ninline void solve() {\r\n\r\n\tsegtree st;\r\n\tint n, q; cin >> n >> q;\r\n\r\n\tint t, l, r, k;\r\n\twhile(q--) {\r\n\r\n\t\tcin >> t >> l >> r, --l, --r;\r\n\r\n\t\tif(t == 1) {\r\n\t\t\tcin >> k;\r\n\t\t\tst.update(l, r, k, 0, n - 1);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout << st.qry(l, r, 0, n - 1) << '\\n';\r\n\t\t}\r\n\t}\r\n\r\n\t// cout << endl;\r\n\t// st.show();\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n// #ifndef ONLINE_JUDGE\r\n// \tfreopen(\"input.txt\", \"r\", stdin);\r\n// \tfreopen(\"output.txt\",  \"w\", stdout);\r\n// #endif\r\n\r\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\n\tsolve();\r\n\r\n\treturn 0;\r\n}\r\n"
    },
    {
        "username": "ritulkrsingh",
        "id": 106655,
        "date": "2022-02-16 22:11:53",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int int64_t\r\n#define sp << ' ' <<\r\n#define nl << '\\n'\r\n\r\nint sL, sR, sV;\r\nstruct SegmentTree {\r\n\tint l, r, sum = 0, add = 0;\r\n\tSegmentTree *L = NULL, *R = NULL;\r\n\tSegmentTree(int lv, int rv) : l(lv), r(rv) {}\r\n\tvoid rangeAdd(int lv, int rv, int v) {\r\n\t\tsL = lv, sR = rv+1, sV = v;\r\n\t\trangeAdd();\r\n\t}\r\n\tvoid rangeAdd() {\r\n\t\tif(sL<=l && r<=sR) {\r\n\t\t\tadd += sV;\r\n\t\t\tsum += sV * (r - l);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(sR<=l || r<=sL) return;\r\n\t\tint m = (l + r) / 2;\r\n\t\t(L ? : L = new SegmentTree(l, m))->rangeAdd();\r\n\t\t(R ? : R = new SegmentTree(m, r))->rangeAdd();\r\n\t\tsum = add * (r - l) + L->sum + R->sum;\r\n\t}\r\n\tint rangeSum(int lv, int rv) {\r\n\t\tsL = lv, sR = rv+1;\r\n\t\treturn rangeSum();\r\n\t}\r\n\tint rangeSum() {\r\n\t\tif(sL<=l && r<=sR) return sum;\r\n\t\tif(sR<=l || r<=sL) return 0LL;\r\n\t\treturn (min(sR, r) - max(sL, l)) * add + (L ? L->rangeSum() : 0LL) + (R ? R->rangeSum() : 0LL);\r\n\t}\r\n};\r\n\r\nsigned main() {\r\n\tcin.tie(0)->sync_with_stdio(0);\r\n\tint n, q; cin >> n >> q;\r\n\r\n\tSegmentTree st(0, n+1);\r\n\r\n\twhile(q--) {\r\n\t\tint t, l, r, k = 0; cin >> t >> l >> r;\r\n\t\tif(t & 1) {\r\n\t\t\tcin >> k;\r\n\t\t\tst.rangeAdd(l, r, k);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout << st.rangeSum(l, r) nl;\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "SweeKang",
        "id": 105990,
        "date": "2022-02-14 22:13:49",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\n/*\r\nroot = new node(0, N-1, array); //creates a segment tree with elements 0 to N - 1. The array parameter is optional.\r\nroot = new node(0, 1000000000); //this tree supports lazy node creation and propagation too, declare as much as you like :)\r\n\r\nroot->add(0, 5000, 3);    //add 3 to range [0, 5000]\r\nroot->add(3000, 9000, -2); //minus 2 to range [3000, 9000]\r\nroot->set(7000, 10000, 5);    //set range [7000, 10000] to 5\r\n\r\n// at this point, 0 to 2999 is 3, 3000 to 5000 is 1, 5001 to 6999 is -2, 7000 to 10000 is 5\r\nroot->range_max(0, 10000);    //returns 5\r\nroot->range_min(0, 10000);    //returns -2\r\nroot->range_sum(0, 10000);    //returns 22008\r\n*/\r\n\r\nint main() {\r\n\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cout.tie(NULL);\r\n\r\n    ll n, q, cmd, l, r, k; cin >> n >> q;\r\n    root = new node(0, n);\r\n\r\n    for (ll i = 0; i < q; i++) {\r\n        cin >> cmd;\r\n        switch (cmd) {\r\n            case 1:\r\n                cin >> l >> r >> k;\r\n                root->add(l, r, k);\r\n                break;\r\n        \r\n            case 2:\r\n                cin >> l >> r;\r\n                cout << root->range_sum(l, r) << '\\n';\r\n                break;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}"
    },
    {
        "username": "blue",
        "id": 101474,
        "date": "2022-01-30 17:18:48",
        "code": "#include <iostream>\r\nusing namespace std;\r\n\r\nstruct segtree\r\n{\r\n\tlong long l;\r\n\tlong long r;\r\n\r\n\tlong long sm = 0;\r\n\tlong long lp = 0;\r\n\r\n\tsegtree* left = NULL;\r\n\tsegtree* right = NULL;\r\n\r\n\tsegtree()\r\n\t{\r\n\t\t;\r\n\t}\r\n\r\n\tsegtree(long long L, long long R)\r\n\t{\r\n\t\tl = L;\r\n\t\tr = R;\r\n\t}\r\n\r\n\tvoid add(long long L, long long R, long long V)\r\n\t{\r\n\t\tif(R < l || r < L) return;\r\n\r\n\t\tsm += (min(r,R) - max(l,L) + 1) * V;\r\n\r\n\t\tif(L <= l && r <= R) lp += V;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(left == NULL) left = new segtree(l, (l+r)/2);\r\n\t\t\tleft->add(L, R, V);\r\n\r\n\t\t\tif(right == NULL) right = new segtree((l+r)/2+1, r);\r\n\t\t\tright->add(L, R, V);\r\n\t\t}\r\n\t}\r\n\r\n\tlong long sum(long long L, long long R)\r\n\t{\r\n\t\tif(R < l || r < L) return 0;\r\n\t\telse if(L <= l && r <= R) return sm;\r\n\t\telse\r\n\t\t{\r\n\t\t\tlong long res = (min(R,r) - max(L,l) + 1) * lp;\r\n\t\t\tif(left != NULL) res += left->sum(L, R);\r\n\t\t\tif(right != NULL) res += right->sum(L, R);\r\n\t\t\treturn res;\r\n\t\t}\r\n\t}\r\n};\r\n\r\nsigned main()\r\n{\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\r\n\tlong long N, Q;\r\n\tcin >> N >> Q;\r\n\r\n\tsegtree S(1, N);\r\n\r\n\tfor(long long q = 1; q <= Q; q++)\r\n\t{\r\n\t\tlong long t;\r\n\t\tcin >> t;\r\n\r\n\t\tif(t == 1)\r\n\t\t{\r\n\t\t\tlong long l, r, k;\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\tS.add(l, r, k);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlong long l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << S.sum(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "haydendoo",
        "id": 99429,
        "date": "2022-01-24 14:57:33",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int mxN=1e9;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint q, n;\r\n\troot = new node(0, mxN);\r\n\tcin >> n >> q;\r\n\tfor(int i=0; i<q; ++i){\r\n\t\tint type;\r\n\t\tcin >> type;\r\n\t\tif(type==1){\r\n\t\t\tint l, r, v;\r\n\t\t\tcin >> l >> r >> v;\r\n\t\t\troot->add(l-1,r-1,v);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->range_sum(l-1,r-1) << '\\n';\r\n\t\t}\r\n\t}\r\n} \r\n/*\r\n5 5 \r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/"
    },
    {
        "username": "Xiaoyang",
        "id": 98468,
        "date": "2022-01-22 11:50:35",
        "code": "#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define fi first\r\n#define se second\r\n#define pii pair<int,int>\r\n#define pll pair<long long,long long>\r\n#define pb push_back\r\n#define pq priority_queue\r\n#define rep(i,a,b) for (int i=a;i<(b);i++)\r\n#define MP make_pair\r\n#define int long long\r\n#define ALL(x) x.begin(),x.end()\r\nusing namespace std;\r\nstruct node{\r\n    int s,e,m;\r\n    node *l,*r;\r\n    int val,lazy;\r\n    node(int S,int E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void create(){\r\n        if (s!=e){\r\n            l = new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n    void update(int a, int b, int v){\r\n        if (l==nullptr) create();\r\n        if (a==s && b==e) lazy+=v;\r\n        else{\r\n            if (b<=m) l->update(a,b,v);\r\n            else if (a>m) r->update(a,b,v);\r\n            else l->update(a,m,v), r->update(m+1,b,v);\r\n            l->propagate(), r->propagate();\r\n            val = l->val + r->val;\r\n\r\n        }\r\n    }\r\n    int query(int a, int b){\r\n        if (l==nullptr) create();\r\n        propagate();\r\n        if (a==s && b==e) return val;\r\n        else if (b<=m) return l->query(a,b);\r\n        else if (a>m) return r->query(a,b);\r\n        else return  l->query(a,m) + r->query(m+1,b);\r\n\r\n    }\r\n    void propagate(){\r\n        if (l==nullptr) create();\r\n        if (lazy==0) return;\r\n        val+=(e-s+1)*lazy ;\r\n        if (s!=e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n}*root;\r\nsigned main(){\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n    int n;\r\n    cin>>n;\r\n    int a,b,c,d;\r\n    root = new node(1,n);\r\n \tint q;\r\n    cin>>q;\r\n    while (q--){\r\n        cin>>a;\r\n        if (a==2){\r\n            cin>>b>>c;\r\n            cout << root->query(b,c) <<'\\n';\r\n        }\r\n        else {\r\n            cin>>b>>c>>d;\r\n            root->update(b,c,d);\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "ritulkrsingh",
        "id": 96991,
        "date": "2022-01-20 02:08:46",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int int64_t\r\n#define sp << ' ' <<\r\n#define nl << '\\n'\r\n\r\nint sL, sR, sV;\r\nstruct SegmentTree {\r\n\tint l, r, sum = 0, add = 0;\r\n\tSegmentTree *L = NULL, *R;\r\n\tvoid push() {\r\n\t\tif(!L) {\r\n\t\t\tint m = (l + r) / 2;\r\n\t\t\tL = new SegmentTree(l, m);\r\n\t\t\tR = new SegmentTree(m, r);\r\n\t\t}\r\n\t}\r\n\tSegmentTree(int lv, int rv) : l(lv), r(rv) {}\r\n\tvoid rangeAdd(int lv, int rv, int v) {\r\n\t\tsL = lv, sR = rv+1, sV = v;\r\n\t\trangeAdd();\r\n\t}\r\n\tvoid rangeAdd() {\r\n\t\tif(sL<=l && r<=sR) {\r\n\t\t\tadd += sV;\r\n\t\t\tsum += sV * (r - l);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(sR<=l || r<=sL) return;\r\n\t\tpush();\r\n\t\tL->rangeAdd(), R->rangeAdd();\r\n\t\tsum = add * (r - l) + L->sum + R->sum;\r\n\t}\r\n\tint rangeSum(int lv, int rv) {\r\n\t\tsL = lv, sR = rv+1;\r\n\t\treturn rangeSum();\r\n\t}\r\n\tint rangeSum() {\r\n\t\tif(sL<=l && r<=sR) return sum;\r\n\t\tif(sR<=l || r<=sL) return 0LL;\r\n\t\tpush();\r\n\t\treturn (min(sR, r) - max(sL, l)) * add + L->rangeSum() + R->rangeSum();\r\n\t}\r\n};\r\n\r\nsigned main() {\r\n\tcin.tie(0)->sync_with_stdio(0);\r\n\tint n, q; cin >> n >> q;\r\n\r\n\tSegmentTree st(0, n+1);\r\n\r\n\twhile(q--) {\r\n\t\tint t, l, r, k = 0; cin >> t >> l >> r;\r\n\t\tif(t & 1) {\r\n\t\t\tcin >> k;\r\n\t\t\tst.rangeAdd(l, r, k);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout << st.rangeSum(l, r) nl;\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "ecxx",
        "id": 92995,
        "date": "2022-01-14 12:53:44",
        "code": "/**\r\n * Codebreaker segmenttree2\r\n * \r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nunsigned long long log2Floor(unsigned long long x) {\r\n    return 63 - __builtin_clzll(x);\r\n}\r\n\r\nunsigned long long log2Ceiling(unsigned long long x) {\r\n    return log2Floor(2*x - 1);\r\n}\r\n\r\nchar buf[450 << 20];\r\nsize_t buf_ind = sizeof buf;\r\n\r\ntemplate<class T> struct small {\r\n\ttypedef T value_type;\r\n\tsmall() {}\r\n\ttemplate<class U> small(const U&) {}\r\n\tT* allocate(size_t n) {\r\n\t\tbuf_ind -= n * sizeof(T);\r\n\t\tbuf_ind &= 0 - alignof(T);\r\n\t\treturn (T*)(buf + buf_ind);\r\n\t}\r\n\tvoid deallocate(T*, size_t) {}\r\n};\r\n\r\ntypedef struct {\r\n\r\n    int l;\r\n    int r; \r\n\r\n} childs;\r\n\r\nstruct st {\r\n\r\n    int _ptr;\r\n    ll _st, _en;\r\n    vector<ll, small<ll>> val, lazy, childlazy;\r\n    vector<childs, small<childs>> son;\r\n\r\n    st(ll start, ll end, ll Q) {\r\n        _ptr = 0;_st=start;_en=end;\r\n        ll vsize = log2Ceiling(end-start+2)*Q*4;\r\n        val.assign(vsize, 0);\r\n        lazy.assign(vsize, 0);\r\n        childlazy.assign(vsize, 0);\r\n        son.assign(vsize, {-1, -1});\r\n    }  \r\n\r\n    void makeleft(int point) {\r\n        if (son[point].l!=-1)return;\r\n        son[point].l = ++_ptr;\r\n        lazy[_ptr] = childlazy[point];\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void makeright(int point) {\r\n        if (son[point].r!=-1)return;\r\n        son[point].r = ++_ptr;\r\n        lazy[_ptr] = childlazy[point];\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void make(int point) {\r\n        makeleft(point);\r\n        makeright(point);\r\n    }\r\n\r\n    void assign_childlazy(int pa) {\r\n\r\n        childlazy[pa] += lazy[pa];\r\n\r\n        if (son[pa].l!=-1 ) {\r\n            lazy[son[pa].l]+=lazy[pa];\r\n        } \r\n        if (son[pa].r!=-1) {\r\n            lazy[son[pa].r]+=lazy[pa];\r\n        }\r\n\r\n    }\r\n\r\n    void propo(int point, ll s, ll e) {\r\n        if (lazy[point]==0)return;\r\n        val[point]+=lazy[point]*(e-s+1);\r\n        if (s!=e){\r\n            assign_childlazy(point);\r\n        }\r\n        lazy[point]=0;\r\n    }\r\n\r\n    void _update(int point, ll s, ll e, ll _s, ll _e, ll _v) {\r\n        if (s==_s&&e==_e) lazy[point]+=_v;\r\n        else {\r\n            ll m = (s+e)>>1;\r\n            make(point);\r\n            if (_s <= m) {\r\n                _update(son[point].l, s, m, _s, min(m, _e), _v);\r\n            }\r\n            if (m < _e) {\r\n                _update(son[point].r, m + 1, e, max(m+1, _s), _e, _v);\r\n            }\r\n            propo(son[point].l, s, m);\r\n            propo(son[point].r, m+1, e);\r\n\r\n            val[point] = 0;\r\n\r\n            if (son[point].l!=-1) val[point] += val[son[point].l];\r\n            if (son[point].r!=-1) val[point] += val[son[point].r];\r\n        }\r\n    }\r\n\r\n    ll _query(int point, ll s, ll e, ll _s, ll _e) {\r\n        if (point==-1) return 0;\r\n        propo(point,s,e);\r\n        ll m = (s+e)>>1;\r\n        if (s==_s&&e==_e) return val[point];\r\n        else if (_e<=m) {makeleft(point); return _query(son[point].l, s, m, _s, _e);}\r\n        else if (m<_s) {makeright(point); return _query(son[point].r, m+1, e, _s, _e);}\r\n        else {\r\n            make(point);\r\n            return (\r\n                _query(son[point].l, s, m, _s, m)\r\n            ) + (\r\n                _query(son[point].r, m+1, e, m+1, _e)\r\n            );\r\n        }\r\n    }\r\n\r\n    void update(ll s, ll e, ll v) {\r\n        _update(0, _st, _en, s, e, v);\r\n    }\r\n\r\n    ll query(ll s, ll e) {\r\n        return _query(0, _st, _en, s, e);\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tst *tree = new st(0LL,N+1,Q);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\ttree->update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << tree->query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "ecxx",
        "id": 92993,
        "date": "2022-01-14 12:47:27",
        "code": "/**\r\n * Codebreaker segmenttree2\r\n * \r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nunsigned long long log2Floor(unsigned long long x) {\r\n    return 63 - __builtin_clzll(x);\r\n}\r\n\r\nunsigned long long log2Ceiling(unsigned long long x) {\r\n    return log2Floor(2*x - 1);\r\n}\r\n\r\nstatic char buf[450 << 20];\r\nvoid* operator new(size_t s) {\r\n\tstatic size_t i = sizeof buf;\r\n\tassert(s < i);\r\n\treturn (void*)&buf[i -= s];\r\n}\r\nvoid operator delete(void*) {}\r\n\r\ntypedef struct {\r\n\r\n    int l;\r\n    int r; \r\n\r\n} childs;\r\n\r\nstruct st {\r\n\r\n    int _ptr;\r\n    ll _st, _en;\r\n    vector<ll> val, lazy, childlazy;\r\n    vector<childs> son;\r\n\r\n    st(ll start, ll end, ll Q) {\r\n        _ptr = 0;_st=start;_en=end;\r\n        ll vsize = log2Ceiling(end-start+2)*Q*4;\r\n        val.assign(vsize, 0);\r\n        lazy.assign(vsize, 0);\r\n        childlazy.assign(vsize, 0);\r\n        son.assign(vsize, {-1, -1});\r\n    }  \r\n\r\n    void makeleft(int point) {\r\n        if (son[point].l!=-1)return;\r\n        son[point].l = ++_ptr;\r\n        lazy[_ptr] = childlazy[point];\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void makeright(int point) {\r\n        if (son[point].r!=-1)return;\r\n        son[point].r = ++_ptr;\r\n        lazy[_ptr] = childlazy[point];\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void make(int point) {\r\n        makeleft(point);\r\n        makeright(point);\r\n    }\r\n\r\n    void assign_childlazy(int pa) {\r\n\r\n        childlazy[pa] += lazy[pa];\r\n\r\n        if (son[pa].l!=-1 ) {\r\n            lazy[son[pa].l]+=lazy[pa];\r\n        } \r\n        if (son[pa].r!=-1) {\r\n            lazy[son[pa].r]+=lazy[pa];\r\n        }\r\n\r\n    }\r\n\r\n    void propo(int point, ll s, ll e) {\r\n        if (lazy[point]==0)return;\r\n        val[point]+=lazy[point]*(e-s+1);\r\n        if (s!=e){\r\n            assign_childlazy(point);\r\n        }\r\n        lazy[point]=0;\r\n    }\r\n\r\n    void _update(int point, ll s, ll e, ll _s, ll _e, ll _v) {\r\n        if (s==_s&&e==_e) lazy[point]+=_v;\r\n        else {\r\n            ll m = (s+e)>>1;\r\n            make(point);\r\n            if (_s <= m) {\r\n                _update(son[point].l, s, m, _s, min(m, _e), _v);\r\n            }\r\n            if (m < _e) {\r\n                _update(son[point].r, m + 1, e, max(m+1, _s), _e, _v);\r\n            }\r\n            propo(son[point].l, s, m);\r\n            propo(son[point].r, m+1, e);\r\n\r\n            val[point] = 0;\r\n\r\n            if (son[point].l!=-1) val[point] += val[son[point].l];\r\n            if (son[point].r!=-1) val[point] += val[son[point].r];\r\n        }\r\n    }\r\n\r\n    ll _query(int point, ll s, ll e, ll _s, ll _e) {\r\n        if (point==-1) return 0;\r\n        propo(point,s,e);\r\n        ll m = (s+e)>>1;\r\n        if (s==_s&&e==_e) return val[point];\r\n        else if (_e<=m) {makeleft(point); return _query(son[point].l, s, m, _s, _e);}\r\n        else if (m<_s) {makeright(point); return _query(son[point].r, m+1, e, _s, _e);}\r\n        else {\r\n            make(point);\r\n            return (\r\n                _query(son[point].l, s, m, _s, m)\r\n            ) + (\r\n                _query(son[point].r, m+1, e, m+1, _e)\r\n            );\r\n        }\r\n    }\r\n\r\n    void update(ll s, ll e, ll v) {\r\n        _update(0, _st, _en, s, e, v);\r\n    }\r\n\r\n    ll query(ll s, ll e) {\r\n        return _query(0, _st, _en, s, e);\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tst *tree = new st(0LL,N+1,Q);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\ttree->update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << tree->query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "Xiaoyang",
        "id": 92662,
        "date": "2022-01-13 12:26:19",
        "code": "#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define fi first\r\n#define se second\r\n#define pii pair<int,int>\r\n#define pll pair<long long,long long>\r\n#define pb push_back\r\n#define pq priority_queue\r\n#define rep(i,a,b) for (int i=a;i<(b);i++)\r\n#define MP make_pair\r\n#define int long long\r\n#define ALL(x) x.begin(),x.end()\r\nusing namespace std;\r\nstruct node{\r\n    int s,e,m;\r\n    node *l,*r;\r\n    int val,lazy;\r\n    node(int S,int E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void create(){\r\n        if (s!=e){\r\n            l = new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n    int query(int a, int b){\r\n        if (l==nullptr) create();\r\n        propagate();\r\n        if (a==s && b==e) return val;\r\n        else if (b<=m) return l->query(a,b);\r\n        else if (a>m) return r->query(a,b);\r\n        else return l->query(a,m) + r->query(m+1,b);\r\n\r\n    }\r\n    void update(int a, int b, int v){\r\n        if (l==nullptr) create();\r\n        if (a==s && b==e) lazy+=v;\r\n        else{\r\n            if (b<=m) l->update(a,b,v);\r\n            else if (a>m) r->update(a,b,v);\r\n            else l->update(a,m,v), r->update(m+1,b,v);\r\n            l->propagate(), r->propagate();\r\n            val = l->val + r->val;\r\n\r\n        }\r\n    }\r\n    void propagate(){\r\n        if (l==nullptr) create();\r\n        if (lazy==0) return;\r\n        val+=(e-s+1)*lazy ;\r\n        if (s!=e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n}*root;\r\nsigned main(){\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n    int n;\r\n    cin>>n;\r\n    int q;\r\n    cin>>q;\r\n    int a,b,c,d;\r\n    root = new node(1,n);\r\n    while (q--){\r\n        cin>>a;\r\n        if (a==2){\r\n            cin>>b>>c;\r\n            cout << root->query(b,c) <<'\\n';\r\n\r\n        }\r\n        else {\r\n            cin>>b>>c>>d;\r\n            root->update(b,c,d);\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "Xiaoyang",
        "id": 92661,
        "date": "2022-01-13 12:25:46",
        "code": "\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define fi first\r\n#define se second\r\n#define pii pair<int,int>\r\n#define pll pair<long long,long long>\r\n#define pb push_back\r\n#define pq priority_queue\r\n#define rep(i,a,b) for (int i=a;i<(b);i++)\r\n#define MP make_pair\r\n#define int long long\r\n#define ALL(x) x.begin(),x.end()\r\n#include <iostream>\r\n#define int long long \r\nusing namespace std;\r\nstruct node{\r\n    int s,e,m;\r\n    node *l,*r;\r\n    int val,lazy;\r\n    node(int S,int E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void create(){\r\n        if (s!=e){\r\n            l = new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n    int query(int a, int b){\r\n        if (l==nullptr) create();\r\n        propagate();\r\n        if (a==s && b==e) return val;\r\n        else if (b<=m) return l->query(a,b);\r\n        else if (a>m) return r->query(a,b);\r\n        else return l->query(a,m) + r->query(m+1,b);\r\n\r\n    }\r\n    void update(int a, int b, int v){\r\n        if (l==nullptr) create();\r\n        if (a==s && b==e) lazy+=v;\r\n        else{\r\n            if (b<=m) l->update(a,b,v);\r\n            else if (a>m) r->update(a,b,v);\r\n            else l->update(a,m,v), r->update(m+1,b,v);\r\n            l->propagate(), r->propagate();\r\n            val = l->val + r->val;\r\n\r\n        }\r\n    }\r\n    void propagate(){\r\n        if (l==nullptr) create();\r\n        if (lazy==0) return;\r\n        val+=(e-s+1)*lazy ;\r\n        if (s!=e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n}*root;\r\nsigned main(){\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n    int n;\r\n    cin>>n;\r\n    int q;\r\n    cin>>q;\r\n    int a,b,c,d;\r\n    root = new node(1,n);\r\n    while (q--){\r\n        cin>>a;\r\n        if (a==2){\r\n            cin>>b>>c;\r\n            cout << root->query(b,c) <<'\\n';\r\n\r\n        }\r\n        else {\r\n            cin>>b>>c>>d;\r\n            root->update(b,c,d);\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "Xiaoyang",
        "id": 92660,
        "date": "2022-01-13 12:25:29",
        "code": "#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define fi first\r\n#define se second\r\n#define pii pair<int,int>\r\n#define pll pair<long long,long long>\r\n#define pb push_back\r\n#define pq priority_queue\r\n#define rep(i,a,b) for (int i=a;i<(b);i++)\r\n#define MP make_pair\r\n#define int long long\r\n#define ALL(x) x.begin(),x.end()\r\n#include <iostream>\r\n#define int long long \r\nusing namespace std;\r\nstruct node{\r\n    int s,e,m;\r\n    node *l,*r;\r\n    int val,lazy;\r\n    node(int S,int E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void create(){\r\n        if (s!=e){\r\n            l = new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n    int query(int a, int b){\r\n        if (l==nullptr) create();\r\n        propagate();\r\n        if (a==s && b==e) return val;\r\n        else if (b<=m) return l->query(a,b);\r\n        else if (a>m) return r->query(a,b);\r\n        else return l->query(a,m) + r->query(m+1,b);\r\n\r\n    }\r\n    void update(int a, int b, int v){\r\n        if (l==nullptr) create();\r\n        if (a==s && b==e) lazy+=v;\r\n        else{\r\n            if (b<=m) l->update(a,b,v);\r\n            else if (a>m) r->update(a,b,v);\r\n            else l->update(a,m,v), r->update(m+1,b,v);\r\n            l->propagate(), r->propagate();\r\n            val = l->val + r->val;\r\n\r\n        }\r\n    }\r\n    void propagate(){\r\n        if (l==nullptr) create();\r\n        if (lazy==0) return;\r\n        val+=(e-s+1)*lazy ;\r\n        if (s!=e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n}*root;\r\nsigned main(){\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n    int n;\r\n    cin>>n;\r\n    int q;\r\n    cin>>q;\r\n    int a,b,c,d;\r\n    root = new node(1,n);\r\n    while (q--){\r\n        cin>>a;\r\n        if (a==2){\r\n            cin>>b>>c;\r\n            cout << root->query(b,c) <<'\\n';\r\n\r\n        }\r\n        else {\r\n            cin>>b>>c>>d;\r\n            root->update(b,c,d);\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "ecxx",
        "id": 92635,
        "date": "2022-01-13 10:55:48",
        "code": "/**\r\n * Codebreaker segmenttree2\r\n * \r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nunsigned long long log2Floor(unsigned long long x) {\r\n    return 63 - __builtin_clzll(x);\r\n}\r\n\r\nunsigned long long log2Ceiling(unsigned long long x) {\r\n    return log2Floor(2*x - 1);\r\n}\r\n\r\ntypedef struct {\r\n\r\n    int l;\r\n    int r; \r\n\r\n} childs;\r\n\r\nstruct st {\r\n\r\n    int _ptr;\r\n    ll _st, _en;\r\n    vector<ll> val, lazy, childlazy;\r\n    vector<childs> son;\r\n\r\n    st(ll start, ll end, ll Q) {\r\n        _ptr = 0;_st=start;_en=end;\r\n        ll vsize = log2Ceiling(end-start+2)*Q*1.5;\r\n        val.assign(vsize, 0);\r\n        lazy.assign(vsize, 0);\r\n        childlazy.assign(vsize, 0);\r\n        son.assign(vsize, {-1, -1});\r\n    }  \r\n\r\n    void makeleft(int point) {\r\n        if (son[point].l!=-1)return;\r\n        son[point].l = ++_ptr;\r\n        lazy[_ptr] = childlazy[point];\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void makeright(int point) {\r\n        if (son[point].r!=-1)return;\r\n        son[point].r = ++_ptr;\r\n        lazy[_ptr] = childlazy[point];\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void make(int point) {\r\n        makeleft(point);\r\n        makeright(point);\r\n    }\r\n\r\n    void assign_childlazy(int pa) {\r\n\r\n        childlazy[pa] += lazy[pa];\r\n\r\n        if (son[pa].l!=-1 ) {\r\n            lazy[son[pa].l]+=lazy[pa];\r\n        } \r\n        if (son[pa].r!=-1) {\r\n            lazy[son[pa].r]+=lazy[pa];\r\n        }\r\n\r\n    }\r\n\r\n    void propo(int point, ll s, ll e) {\r\n        if (lazy[point]==0)return;\r\n        val[point]+=lazy[point]*(e-s+1);\r\n        if (s!=e){\r\n            assign_childlazy(point);\r\n        }\r\n        lazy[point]=0;\r\n    }\r\n\r\n    void _update(int point, ll s, ll e, ll _s, ll _e, ll _v) {\r\n        if (s==_s&&e==_e) lazy[point]+=_v;\r\n        else {\r\n            ll m = (s+e)>>1;\r\n            make(point);\r\n            if (_e <= m) {\r\n                //makeleft(point); \r\n                _update(son[point].l, s, m, _s, _e, _v);\r\n            }\r\n            else if (m < _s) {\r\n                //makeright(point);\r\n                _update(son[point].r, m + 1, e, _s, _e, _v);\r\n            }\r\n            else {\r\n                //make(point);\r\n                _update(son[point].l, s, m, _s, m, _v);\r\n                _update(son[point].r, m+1, e, m+1, _e, _v);\r\n            }\r\n            if (son[point].l!=-1) propo(son[point].l, s, m);\r\n            if (son[point].r!=-1) propo(son[point].r, m+1, e);\r\n\r\n            val[point] = 0;\r\n\r\n            if (son[point].l!=-1) val[point] += val[son[point].l];\r\n            if (son[point].r!=-1) val[point] += val[son[point].r];\r\n        }\r\n    }\r\n\r\n    ll _query(int point, ll s, ll e, ll _s, ll _e) {\r\n        if (point==-1) return 0;\r\n        propo(point,s,e);\r\n        ll m = (s+e)>>1;\r\n        if (s==_s&&e==_e) return val[point];\r\n        else if (_e<=m) {makeleft(point); return _query(son[point].l, s, m, _s, _e);}\r\n        else if (m<_s) {makeright(point); return _query(son[point].r, m+1, e, _s, _e);}\r\n        else {\r\n            make(point);\r\n            return (\r\n                _query(son[point].l, s, m, _s, m)\r\n            ) + (\r\n                _query(son[point].r, m+1, e, m+1, _e)\r\n            );\r\n        }\r\n    }\r\n\r\n    void update(ll s, ll e, ll v) {\r\n        _update(0, _st, _en, s, e, v);\r\n    }\r\n\r\n    ll query(ll s, ll e) {\r\n        return _query(0, _st, _en, s, e);\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tst tree(0LL,N+1,Q);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\ttree.update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << tree.query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "ecxx",
        "id": 92630,
        "date": "2022-01-13 10:51:14",
        "code": "/**\r\n * Codebreaker segmenttree2\r\n * \r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nunsigned long long log2Floor(unsigned long long x) {\r\n    return 63 - __builtin_clzll(x);\r\n}\r\n\r\nunsigned long long log2Ceiling(unsigned long long x) {\r\n    return log2Floor(2*x - 1);\r\n}\r\n\r\ntypedef struct {\r\n\r\n    int l;\r\n    int r; \r\n\r\n} childs;\r\n\r\n\r\nstruct st {\r\n\r\n    int _ptr;\r\n    ll _st, _en;\r\n    vector<ll> val, lazy;\r\n    vector<int> son;\r\n\r\n    st(ll start, ll end, ll Q) {\r\n        _ptr = 0;_st=start;_en=end;\r\n        ll vsize = log2Ceiling(end-start+2)*Q*4;\r\n        val.assign(vsize, 0);\r\n        lazy.assign(vsize, 0);\r\n        son.assign(vsize, -1);\r\n    }  \r\n\r\n    void make(int point) {\r\n        if (son[point]!=-1)return;\r\n        son[point] = ++_ptr;\r\n        ++_ptr;\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void propo(int point, ll s, ll e) {\r\n        make(point);\r\n        if (lazy[point]==0)return;\r\n        val[point]+=lazy[point]*(e-s+1);\r\n        if (s!=e){\r\n            lazy[son[point]]+=lazy[point];\r\n            lazy[son[point]+1]+=lazy[point];\r\n        }\r\n        lazy[point]=0;\r\n    }\r\n\r\n    void _update(int point, ll s, ll e, ll _s, ll _e, ll _v) {\r\n        if (s==_s&&e==_e) lazy[point]+=_v;\r\n        else {\r\n            ll m = (s+e)>>1;\r\n            make(point);\r\n            if (_e <= m) _update(son[point], s, m, _s, _e, _v);\r\n            else if (m < _s) _update(son[point]+1, m+1, e, _s, _e, _v);\r\n            else {\r\n                _update(son[point], s, m, _s, m, _v);\r\n                _update(son[point]+1, m+1, e, m+1, _e, _v);\r\n            }\r\n            propo(son[point], s, m);\r\n            propo(son[point]+1, m+1, e);\r\n            val[point] = val[son[point]] + val[son[point]+1];\r\n        }\r\n    }\r\n\r\n    ll _query(int point, ll s, ll e, ll _s, ll _e) {\r\n        //cout << \"QUERIED \" << s << \" \" << e << \" \" << _s << \" \" << _e << \"\\n\";\r\n        propo(point,s,e);\r\n        ll m = (s+e)>>1;\r\n        if (s==_s&&e==_e) return val[point];\r\n        else if (_e<=m) return _query(son[point], s, m, _s, _e);\r\n        else if (m<_s) return _query(son[point]+1, m+1, e, _s, _e);\r\n        else return (\r\n            _query(son[point], s, m, _s, m)\r\n        ) + (\r\n            _query(son[point]+1, m+1, e, m+1, _e)\r\n        );\r\n    }\r\n\r\n    void update(ll s, ll e, ll v) {\r\n        _update(0, _st, _en, s, e, v);\r\n    }\r\n\r\n    ll query(ll s, ll e) {\r\n        return _query(0, _st, _en, s, e);\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tst tree(0LL,N+1,Q);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\ttree.update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << tree.query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "ecxx",
        "id": 92629,
        "date": "2022-01-13 10:50:02",
        "code": "/**\r\n * Codebreaker segmenttree2\r\n * \r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nunsigned long long log2Floor(unsigned long long x) {\r\n    return 63 - __builtin_clzll(x);\r\n}\r\n\r\nunsigned long long log2Ceiling(unsigned long long x) {\r\n    return log2Floor(2*x - 1);\r\n}\r\n\r\ntypedef struct {\r\n\r\n    int l;\r\n    int r; \r\n\r\n} childs;\r\n\r\nstruct st {\r\n\r\n    int _ptr;\r\n    ll _st, _en;\r\n    vector<ll> val, lazy, childlazy;\r\n    vector<childs> son;\r\n\r\n    st(ll start, ll end, ll Q) {\r\n        _ptr = 0;_st=start;_en=end;\r\n        ll vsize = log2Ceiling(end-start+2)*Q*2;\r\n        val.assign(vsize, 0);\r\n        lazy.assign(vsize, 0);\r\n        childlazy.assign(vsize, 0);\r\n        son.assign(vsize, {-1, -1});\r\n    }  \r\n\r\n    void makeleft(int point) {\r\n        if (son[point].l!=-1)return;\r\n        son[point].l = ++_ptr;\r\n        lazy[_ptr] = childlazy[point];\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void makeright(int point) {\r\n        if (son[point].r!=-1)return;\r\n        son[point].r = ++_ptr;\r\n        lazy[_ptr] = childlazy[point];\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void make(int point) {\r\n        makeleft(point);\r\n        makeright(point);\r\n    }\r\n\r\n    void assign_childlazy(int pa) {\r\n\r\n        childlazy[pa] += lazy[pa];\r\n\r\n        if (son[pa].l!=-1 ) {\r\n            lazy[son[pa].l]+=lazy[pa];\r\n        } \r\n        if (son[pa].r!=-1) {\r\n            lazy[son[pa].r]+=lazy[pa];\r\n        }\r\n\r\n    }\r\n\r\n    void propo(int point, ll s, ll e) {\r\n        if (lazy[point]==0)return;\r\n        val[point]+=lazy[point]*(e-s+1);\r\n        if (s!=e){\r\n            assign_childlazy(point);\r\n        }\r\n        lazy[point]=0;\r\n    }\r\n\r\n    void _update(int point, ll s, ll e, ll _s, ll _e, ll _v) {\r\n        if (s==_s&&e==_e) lazy[point]+=_v;\r\n        else {\r\n            ll m = (s+e)>>1;\r\n            make(point);\r\n            if (_e <= m) {\r\n                //makeleft(point); \r\n                _update(son[point].l, s, m, _s, _e, _v);\r\n            }\r\n            else if (m < _s) {\r\n                //makeright(point);\r\n                _update(son[point].r, m + 1, e, _s, _e, _v);\r\n            }\r\n            else {\r\n                //make(point);\r\n                _update(son[point].l, s, m, _s, m, _v);\r\n                _update(son[point].r, m+1, e, m+1, _e, _v);\r\n            }\r\n            if (son[point].l!=-1) propo(son[point].l, s, m);\r\n            if (son[point].r!=-1) propo(son[point].r, m+1, e);\r\n\r\n            val[point] = 0;\r\n\r\n            if (son[point].l!=-1) val[point] += val[son[point].l];\r\n            if (son[point].r!=-1) val[point] += val[son[point].r];\r\n        }\r\n    }\r\n\r\n    ll _query(int point, ll s, ll e, ll _s, ll _e) {\r\n        if (point==-1) return 0;\r\n        propo(point,s,e);\r\n        ll m = (s+e)>>1;\r\n        if (s==_s&&e==_e) return val[point];\r\n        else if (_e<=m) {makeleft(point); return _query(son[point].l, s, m, _s, _e);}\r\n        else if (m<_s) {makeright(point); return _query(son[point].r, m+1, e, _s, _e);}\r\n        else {\r\n            make(point);\r\n            return (\r\n                _query(son[point].l, s, m, _s, m)\r\n            ) + (\r\n                _query(son[point].r, m+1, e, m+1, _e)\r\n            );\r\n        }\r\n    }\r\n\r\n    void update(ll s, ll e, ll v) {\r\n        _update(0, _st, _en, s, e, v);\r\n    }\r\n\r\n    ll query(ll s, ll e) {\r\n        return _query(0, _st, _en, s, e);\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tst tree(0LL,N+1,Q);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\ttree.update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << tree.query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "ecxx",
        "id": 92628,
        "date": "2022-01-13 10:49:45",
        "code": "/**\r\n * Codebreaker segmenttree2\r\n * \r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nunsigned long long log2Floor(unsigned long long x) {\r\n    return 63 - __builtin_clzll(x);\r\n}\r\n\r\nunsigned long long log2Ceiling(unsigned long long x) {\r\n    return log2Floor(2*x - 1);\r\n}\r\n\r\ntypedef struct {\r\n\r\n    int l;\r\n    int r; \r\n\r\n} childs;\r\n\r\nstruct st {\r\n\r\n    int _ptr;\r\n    ll _st, _en;\r\n    vector<ll> val, lazy, childlazy;\r\n    vector<childs> son;\r\n\r\n    st(ll start, ll end, ll Q) {\r\n        _ptr = 0;_st=start;_en=end;\r\n        ll vsize = log2Ceiling(end-start+2)*Q*4;\r\n        val.assign(vsize, 0);\r\n        lazy.assign(vsize, 0);\r\n        childlazy.assign(vsize, 0);\r\n        son.assign(vsize, {-1, -1});\r\n    }  \r\n\r\n    void makeleft(int point) {\r\n        if (son[point].l!=-1)return;\r\n        son[point].l = ++_ptr;\r\n        lazy[_ptr] = childlazy[point];\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void makeright(int point) {\r\n        if (son[point].r!=-1)return;\r\n        son[point].r = ++_ptr;\r\n        lazy[_ptr] = childlazy[point];\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void make(int point) {\r\n        makeleft(point);\r\n        makeright(point);\r\n    }\r\n\r\n    void assign_childlazy(int pa) {\r\n\r\n        childlazy[pa] += lazy[pa];\r\n\r\n        if (son[pa].l!=-1 ) {\r\n            lazy[son[pa].l]+=lazy[pa];\r\n        } \r\n        if (son[pa].r!=-1) {\r\n            lazy[son[pa].r]+=lazy[pa];\r\n        }\r\n\r\n    }\r\n\r\n    void propo(int point, ll s, ll e) {\r\n        if (lazy[point]==0)return;\r\n        val[point]+=lazy[point]*(e-s+1);\r\n        if (s!=e){\r\n            assign_childlazy(point);\r\n        }\r\n        lazy[point]=0;\r\n    }\r\n\r\n    void _update(int point, ll s, ll e, ll _s, ll _e, ll _v) {\r\n        if (s==_s&&e==_e) lazy[point]+=_v;\r\n        else {\r\n            ll m = (s+e)>>1;\r\n            make(point);\r\n            if (_e <= m) {\r\n                //makeleft(point); \r\n                _update(son[point].l, s, m, _s, _e, _v);\r\n            }\r\n            else if (m < _s) {\r\n                //makeright(point);\r\n                _update(son[point].r, m + 1, e, _s, _e, _v);\r\n            }\r\n            else {\r\n                //make(point);\r\n                _update(son[point].l, s, m, _s, m, _v);\r\n                _update(son[point].r, m+1, e, m+1, _e, _v);\r\n            }\r\n            if (son[point].l!=-1) propo(son[point].l, s, m);\r\n            if (son[point].r!=-1) propo(son[point].r, m+1, e);\r\n\r\n            val[point] = 0;\r\n\r\n            if (son[point].l!=-1) val[point] += val[son[point].l];\r\n            if (son[point].r!=-1) val[point] += val[son[point].r];\r\n        }\r\n    }\r\n\r\n    ll _query(int point, ll s, ll e, ll _s, ll _e) {\r\n        if (point==-1) return 0;\r\n        propo(point,s,e);\r\n        ll m = (s+e)>>1;\r\n        if (s==_s&&e==_e) return val[point];\r\n        else if (_e<=m) {makeleft(point); return _query(son[point].l, s, m, _s, _e);}\r\n        else if (m<_s) {makeright(point); return _query(son[point].r, m+1, e, _s, _e);}\r\n        else {\r\n            make(point);\r\n            return (\r\n                _query(son[point].l, s, m, _s, m)\r\n            ) + (\r\n                _query(son[point].r, m+1, e, m+1, _e)\r\n            );\r\n        }\r\n    }\r\n\r\n    void update(ll s, ll e, ll v) {\r\n        _update(0, _st, _en, s, e, v);\r\n    }\r\n\r\n    ll query(ll s, ll e) {\r\n        return _query(0, _st, _en, s, e);\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tst tree(0LL,N+1,Q);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\ttree.update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << tree.query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "Xiaoyang",
        "id": 92253,
        "date": "2022-01-12 11:17:04",
        "code": "#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define fi first\r\n#define se second\r\n#define pii pair<int,int>\r\n#define pll pair<long long,long long>\r\n#define pb push_back\r\n#define pq priority_queue\r\n#define rep(i,a,b) for (int i=a;i<(b);i++)\r\n#define MP make_pair\r\n#define int long long\r\n#define ALL(x) x.begin(),x.end()\r\n#include <iostream>\r\n#define int long long \r\nusing namespace std;\r\nstruct node{\r\n    int s,e,m;\r\n    node *l,*r;\r\n    int val,lazy;\r\n    node(int S,int E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void create(){\r\n        if (s!=e){\r\n            l = new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n    int query(int a, int b){\r\n        if (l==nullptr) create();\r\n        propagate();\r\n        if (a==s && b==e) return val;\r\n        else if (b<=m) return l->query(a,b);\r\n        else if (a>m) return r->query(a,b);\r\n        else return l->query(a,m) + r->query(m+1,b);\r\n\r\n    }\r\n    void update(int a, int b, int v){\r\n        if (l==nullptr) create();\r\n        if (a==s && b==e) lazy+=v;\r\n        else{\r\n            if (b<=m) l->update(a,b,v);\r\n            else if (a>m) r->update(a,b,v);\r\n            else l->update(a,m,v), r->update(m+1,b,v);\r\n            l->propagate(), r->propagate();\r\n            val = l->val + r->val;\r\n\r\n        }\r\n    }\r\n    void propagate(){\r\n        if (l==nullptr) create();\r\n        if (lazy==0) return;\r\n        val+=(e-s+1)*lazy ;\r\n        if (s!=e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n}*root;\r\nsigned main(){\r\n    int n;\r\n    cin>>n;\r\n    int q;\r\n    cin>>q;\r\n    int a,b,c,d;\r\n    root = new node(1,n);\r\n    while (q--){\r\n        cin>>a;\r\n        if (a==2){\r\n            cin>>b>>c;\r\n            cout << root->query(b,c) <<'\\n';\r\n\r\n        }\r\n        else {\r\n            cin>>b>>c>>d;\r\n            root->update(b,c,d);\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "ecxx",
        "id": 91750,
        "date": "2022-01-11 10:23:26",
        "code": "/**\r\n * Codebreaker segmenttree2\r\n * \r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nunsigned long long log2Floor(unsigned long long x) {\r\n    return 63 - __builtin_clzll(x);\r\n}\r\n\r\nunsigned long long log2Ceiling(unsigned long long x) {\r\n    return log2Floor(2*x - 1);\r\n}\r\n\r\n\r\nstruct st {\r\n\r\n    int _ptr;\r\n    ll _st, _en;\r\n    vector<ll> val, lazy;\r\n    vector<int> son;\r\n\r\n    st(ll start, ll end, ll Q) {\r\n        _ptr = 0;_st=start;_en=end;\r\n        ll vsize = log2Ceiling(end-start+2)*Q*4;\r\n        val.assign(vsize, 0);\r\n        lazy.assign(vsize, 0);\r\n        son.assign(vsize, -1);\r\n    }  \r\n\r\n    void make(int point) {\r\n        if (son[point]!=-1)return;\r\n        son[point] = ++_ptr;\r\n        ++_ptr;\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void propo(int point, ll s, ll e) {\r\n        make(point);\r\n        if (lazy[point]==0)return;\r\n        val[point]+=lazy[point]*(e-s+1);\r\n        if (s!=e){\r\n            lazy[son[point]]+=lazy[point];\r\n            lazy[son[point]+1]+=lazy[point];\r\n        }\r\n        lazy[point]=0;\r\n    }\r\n\r\n    void _update(int point, ll s, ll e, ll _s, ll _e, ll _v) {\r\n        if (s==_s&&e==_e) lazy[point]+=_v;\r\n        else {\r\n            ll m = (s+e)>>1;\r\n            make(point);\r\n            if (_e <= m) _update(son[point], s, m, _s, _e, _v);\r\n            else if (m < _s) _update(son[point]+1, m+1, e, _s, _e, _v);\r\n            else {\r\n                _update(son[point], s, m, _s, m, _v);\r\n                _update(son[point]+1, m+1, e, m+1, _e, _v);\r\n            }\r\n            propo(son[point], s, m);\r\n            propo(son[point]+1, m+1, e);\r\n            val[point] = val[son[point]] + val[son[point]+1];\r\n        }\r\n    }\r\n\r\n    ll _query(int point, ll s, ll e, ll _s, ll _e) {\r\n        //cout << \"QUERIED \" << s << \" \" << e << \" \" << _s << \" \" << _e << \"\\n\";\r\n        propo(point,s,e);\r\n        ll m = (s+e)>>1;\r\n        if (s==_s&&e==_e) return val[point];\r\n        else if (_e<=m) return _query(son[point], s, m, _s, _e);\r\n        else if (m<_s) return _query(son[point]+1, m+1, e, _s, _e);\r\n        else return (\r\n            _query(son[point], s, m, _s, m)\r\n        ) + (\r\n            _query(son[point]+1, m+1, e, m+1, _e)\r\n        );\r\n    }\r\n\r\n    void update(ll s, ll e, ll v) {\r\n        _update(0, _st, _en, s, e, v);\r\n    }\r\n\r\n    ll query(ll s, ll e) {\r\n        return _query(0, _st, _en, s, e);\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tst tree(0LL,N+1,Q);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\ttree.update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << tree.query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "ecxx",
        "id": 91749,
        "date": "2022-01-11 10:22:58",
        "code": "/**\r\n * Codebreaker segmenttree2\r\n * \r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nunsigned long long log2Floor(unsigned long long x) {\r\n    return 63 - __builtin_clzll(x);\r\n}\r\n\r\nunsigned long long log2Ceiling(unsigned long long x) {\r\n    return log2Floor(2*x - 1);\r\n}\r\n\r\n\r\nstruct st {\r\n\r\n    int _ptr;\r\n    ll _st, _en;\r\n    vector<ll> val, lazy;\r\n    vector<int> son;\r\n\r\n    st(ll start, ll end, ll Q) {\r\n        _ptr = 0;_st=start;_en=end;\r\n        ll vsize = log2Ceiling(end-start+2)*Q*4;\r\n        val.assign(vsize, 0);\r\n        lazy.assign(vsize, 0);\r\n        son.assign(vsize, -1);\r\n    }  \r\n\r\n    void make(int point) {\r\n        if (son[point]!=-1)return;\r\n        son[point] = ++_ptr;\r\n        ++_ptr;\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void propo(int point, ll s, ll e) {\r\n        make(point);\r\n        if (lazy[point]==0)return;\r\n        val[point]+=lazy[point]*(e-s+1);\r\n        if (s!=e){\r\n            lazy[son[point]]+=lazy[point];\r\n            lazy[son[point]+1]+=lazy[point];\r\n        }\r\n        lazy[point]=0;\r\n    }\r\n\r\n    void _update(int point, ll s, ll e, ll _s, ll _e, ll _v) {\r\n        if (s==_s&&e==_e) lazy[point]+=_v;\r\n        else {\r\n            ll m = (s+e)>>1;\r\n            make(point);\r\n            if (_e <= m) _update(son[point], s, m, _s, _e, _v);\r\n            else if (m < _s) _update(son[point]+1, m+1, e, _s, _e, _v);\r\n            else {\r\n                _update(son[point], s, m, _s, m, _v);\r\n                _update(son[point]+1, m+1, e, m+1, _e, _v);\r\n            }\r\n            propo(son[point], s, m);\r\n            propo(son[point]+1, m+1, e);\r\n            val[point] = val[son[point]] + val[son[point]+1];\r\n        }\r\n    }\r\n\r\n    ll _query(int point, ll s, ll e, ll _s, ll _e) {\r\n        //cout << \"QUERIED \" << s << \" \" << e << \" \" << _s << \" \" << _e << \"\\n\";\r\n        propo(point,s,e);\r\n        ll m = (s+e)>>1;\r\n        if (s==_s&&e==_e) return val[point];\r\n        else if (_e<=m) return _query(son[point], s, m, _s, _e);\r\n        else if (m<_s) return _query(son[point]+1, m+1, e, _s, _e);\r\n        else return (\r\n            _query(son[point], s, m, _s, m)\r\n        ) + (\r\n            _query(son[point]+1, m+1, e, m+1, _e)\r\n        );\r\n    }\r\n\r\n    void update(ll s, ll e, ll v) {\r\n        _update(0, _st, _en, s, e, v);\r\n    }\r\n\r\n    ll query(ll s, ll e) {\r\n        return _query(0, _st, _en, s, e);\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tst tree(0LL,N+1,Q);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\ttree.update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << tree.query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "ecxx",
        "id": 91746,
        "date": "2022-01-11 10:17:09",
        "code": "/**\r\n * Codebreaker segmenttree2\r\n * \r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nunsigned long long log2Floor(unsigned long long x) {\r\n    return 63 - __builtin_clzll(x);\r\n}\r\n\r\nunsigned long long log2Ceiling(unsigned long long x) {\r\n    return log2Floor(2*x - 1);\r\n}\r\n\r\n\r\nstruct st {\r\n\r\n    int _ptr;\r\n    ll _st, _en;\r\n    vector<ll> data;\r\n\r\n    ll vsize;\r\n\r\n    ll getval(int point) {\r\n        return data[point];\r\n    }\r\n\r\n    void setval(int point, ll value) {\r\n        data[point]=value;\r\n    }\r\n\r\n    ll getlazy(int point) {\r\n        return data[point+vsize];\r\n    }\r\n\r\n    void setlazy(int point, ll value) {\r\n        data[point+vsize]=value;\r\n    }\r\n\r\n    int getson(int point) {\r\n        return (int)data[point+vsize+vsize];\r\n    }\r\n\r\n    void setson(int point, int value) {\r\n        data[point+vsize+vsize] = value;\r\n    }\r\n\r\n\r\n    st(ll start, ll end, ll Q) {\r\n        _ptr = 0;_st=start;_en=end;\r\n        vsize = log2Ceiling(end-start+2)*Q*3;\r\n        data.assign(vsize*3, 0);\r\n    }  \r\n\r\n    void make(int point) {\r\n        if (getson(point)!=0)return;\r\n        setson(point, ++_ptr);\r\n        ++_ptr;\r\n    }\r\n\r\n    void propo(int point, ll s, ll e) {\r\n        make(point);\r\n        if (getlazy(point)==0)return;\r\n        setval(point, getval(point) + getlazy(point)*(e-s+1));\r\n        if (s!=e){\r\n            setlazy(getson(point), getlazy(getson(point)) + getlazy(point));\r\n            setlazy(getson(point)+1, getlazy(getson(point)+1) + getlazy(point));\r\n        }\r\n        setlazy(point, 0);\r\n    }\r\n\r\n    void _update(int point, ll s, ll e, ll _s, ll _e, ll _v) {\r\n        if (s==_s&&e==_e) setlazy(point, getlazy(point)+_v);\r\n        else {\r\n            ll m = (s+e)>>1;\r\n            make(point);\r\n            if (_e <= m) _update(getson(point), s, m, _s, _e, _v);\r\n            else if (m < _s) _update(getson(point)+1, m+1, e, _s, _e, _v);\r\n            else {\r\n                _update(getson(point), s, m, _s, m, _v);\r\n                _update(getson(point)+1, m+1, e, m+1, _e, _v);\r\n            }\r\n            propo(getson(point), s, m);\r\n            propo(getson(point)+1, m+1, e);\r\n            setval(point, getval(getson(point)) + getval(getson(point)+1));\r\n        }\r\n    }\r\n\r\n    ll _query(int point, ll s, ll e, ll _s, ll _e) {\r\n        propo(point,s,e);\r\n        ll m = (s+e)>>1;\r\n        if (s==_s&&e==_e) return getval(point);\r\n        else if (_e<=m) return _query(getson(point), s, m, _s, _e);\r\n        else if (m<_s) return _query(getson(point)+1, m+1, e, _s, _e);\r\n        else return (\r\n            _query(getson(point), s, m, _s, m)\r\n        ) + (\r\n            _query(getson(point)+1, m+1, e, m+1, _e)\r\n        );\r\n    }\r\n\r\n    void update(ll s, ll e, ll v) {\r\n        _update(0, _st, _en, s, e, v);\r\n    }\r\n\r\n    ll query(ll s, ll e) {\r\n        return _query(0, _st, _en, s, e);\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tst tree(0LL,N+1,Q);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\ttree.update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << tree.query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "ecxx",
        "id": 91744,
        "date": "2022-01-11 10:16:33",
        "code": "/**\r\n * Codebreaker segmenttree2\r\n * \r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nunsigned long long log2Floor(unsigned long long x) {\r\n    return 63 - __builtin_clzll(x);\r\n}\r\n\r\nunsigned long long log2Ceiling(unsigned long long x) {\r\n    return log2Floor(2*x - 1);\r\n}\r\n\r\n\r\nstruct st {\r\n\r\n    int _ptr;\r\n    ll _st, _en;\r\n    vector<ll> data;\r\n\r\n    ll vsize;\r\n\r\n    ll getval(int point) {\r\n        return data[point];\r\n    }\r\n\r\n    void setval(int point, ll value) {\r\n        data[point]=value;\r\n    }\r\n\r\n    ll getlazy(int point) {\r\n        return data[point+vsize];\r\n    }\r\n\r\n    void setlazy(int point, ll value) {\r\n        data[point+vsize]=value;\r\n    }\r\n\r\n    int getson(int point) {\r\n        return (int)data[point+vsize+vsize];\r\n    }\r\n\r\n    void setson(int point, int value) {\r\n        data[point+vsize+vsize] = value;\r\n    }\r\n\r\n\r\n    st(ll start, ll end, ll Q) {\r\n        _ptr = 0;_st=start;_en=end;\r\n        vsize = log2Ceiling(end-start+2)*Q*3;\r\n        data.assign(vsize*3, 0);\r\n    }  \r\n\r\n    void make(int point) {\r\n        if (getson(point)!=0)return;\r\n        setson(point, ++_ptr);\r\n        ++_ptr;\r\n    }\r\n\r\n    void propo(int point, ll s, ll e) {\r\n        make(point);\r\n        if (getlazy(point)==0)return;\r\n        setval(point, getval(point) + getlazy(point)*(e-s+1));\r\n        if (s!=e){\r\n            setlazy(getson(point), getlazy(getson(point)) + getlazy(point));\r\n            setlazy(getson(point)+1, getlazy(getson(point)+1) + getlazy(point));\r\n        }\r\n        setlazy(point, 0);\r\n    }\r\n\r\n    void _update(int point, ll s, ll e, ll _s, ll _e, ll _v) {\r\n        if (s==_s&&e==_e) setlazy(point, getlazy(point)+_v);\r\n        else {\r\n            ll m = (s+e)>>1;\r\n            make(point);\r\n            if (_e <= m) _update(getson(point), s, m, _s, _e, _v);\r\n            else if (m < _s) _update(getson(point)+1, m+1, e, _s, _e, _v);\r\n            else {\r\n                _update(getson(point), s, m, _s, m, _v);\r\n                _update(getson(point)+1, m+1, e, m+1, _e, _v);\r\n            }\r\n            propo(getson(point), s, m);\r\n            propo(getson(point)+1, m+1, e);\r\n            setval(point, getval(getson(point)) + getval(getson(point)+1));\r\n        }\r\n    }\r\n\r\n    ll _query(int point, ll s, ll e, ll _s, ll _e) {\r\n        propo(point,s,e);\r\n        ll m = (s+e)>>1;\r\n        if (s==_s&&e==_e) return getval(point);\r\n        else if (_e<=m) return _query(getson(point), s, m, _s, _e);\r\n        else if (m<_s) return _query(getson(point)+1, m+1, e, _s, _e);\r\n        else return (\r\n            _query(getson(point), s, m, _s, m)\r\n        ) + (\r\n            _query(getson(point)+1, m+1, e, m+1, _e)\r\n        );\r\n    }\r\n\r\n    void update(ll s, ll e, ll v) {\r\n        _update(0, _st, _en, s, e, v);\r\n    }\r\n\r\n    ll query(ll s, ll e) {\r\n        return _query(0, _st, _en, s, e);\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tst tree(0LL,N+1,Q);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\ttree.update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << tree.query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "ecxx",
        "id": 91676,
        "date": "2022-01-10 22:56:48",
        "code": "/**\r\n * Codebreaker segmenttree2\r\n * \r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nunsigned long long log2Floor(unsigned long long x) {\r\n    return 63 - __builtin_clzll(x);\r\n}\r\n\r\nunsigned long long log2Ceiling(unsigned long long x) {\r\n    return log2Floor(2*x - 1);\r\n}\r\n\r\n\r\nstruct st {\r\n\r\n    int _ptr;\r\n    ll _st, _en;\r\n    vector<ll> val, lazy;\r\n    vector<int> son;\r\n\r\n    st(ll start, ll end, ll Q) {\r\n        _ptr = 0;_st=start;_en=end;\r\n        ll vsize = log2Ceiling(end-start+2)*Q*4;\r\n        val.assign(1, 0);\r\n        lazy.assign(1, 0);\r\n        son.assign(1, -1);\r\n    }  \r\n\r\n    void make(int point) {\r\n        if (son[point]!=-1)return;\r\n        son[point] = ++_ptr;\r\n        ++_ptr;\r\n\t\tval.push_back(0);val.push_back(0);\r\n\t\tlazy.push_back(0);lazy.push_back(0);\r\n\t\tson.push_back(-1);son.push_back(-1);\r\n    }\r\n\r\n    void propo(int point, ll s, ll e) {\r\n        make(point);\r\n        if (lazy[point]==0)return;\r\n        val[point]+=lazy[point]*(e-s+1);\r\n        if (s!=e){\r\n            lazy[son[point]]+=lazy[point];\r\n            lazy[son[point]+1]+=lazy[point];\r\n        }\r\n        lazy[point]=0;\r\n    }\r\n\r\n    void _update(int point, ll s, ll e, ll _s, ll _e, ll _v) {\r\n        if (s==_s&&e==_e) lazy[point]+=_v;\r\n        else {\r\n            ll m = (s+e)>>1;\r\n            make(point);\r\n            if (_e <= m) _update(son[point], s, m, _s, _e, _v);\r\n            else if (m < _s) _update(son[point]+1, m+1, e, _s, _e, _v);\r\n            else {\r\n                _update(son[point], s, m, _s, m, _v);\r\n                _update(son[point]+1, m+1, e, m+1, _e, _v);\r\n            }\r\n            propo(son[point], s, m);\r\n            propo(son[point]+1, m+1, e);\r\n            val[point] = val[son[point]] + val[son[point]+1];\r\n        }\r\n    }\r\n\r\n    ll _query(int point, ll s, ll e, ll _s, ll _e) {\r\n        //cout << \"QUERIED \" << s << \" \" << e << \" \" << _s << \" \" << _e << \"\\n\";\r\n        propo(point,s,e);\r\n        ll m = (s+e)>>1;\r\n        if (s==_s&&e==_e) return val[point];\r\n        else if (_e<=m) return _query(son[point], s, m, _s, _e);\r\n        else if (m<_s) return _query(son[point]+1, m+1, e, _s, _e);\r\n        else return (\r\n            _query(son[point], s, m, _s, m)\r\n        ) + (\r\n            _query(son[point]+1, m+1, e, m+1, _e)\r\n        );\r\n    }\r\n\r\n    void update(ll s, ll e, ll v) {\r\n        _update(0, _st, _en, s, e, v);\r\n    }\r\n\r\n    ll query(ll s, ll e) {\r\n        return _query(0, _st, _en, s, e);\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tst tree(0LL,N+1,Q);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\ttree.update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << tree.query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "ecxx",
        "id": 91675,
        "date": "2022-01-10 22:55:28",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node {\r\n\tlong long s,e,m,val=0,lazy;\r\n\tnode *LL=NULL, *RR=NULL;\r\n\r\n\tnode(long long _s, long long _e) {\r\n\t\ts=_s;e=_e;m=(s+e)>>1;\r\n\t\tval=0;lazy=0;\r\n\r\n\t\tif (s==e) return;\r\n\t\t\r\n\t}\r\n\r\n\tvoid make() {\r\n\t\tif (!LL) {\r\n\t\t\tLL = new node(s,m);\r\n\t\t\tRR = new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid propo() {\r\n\r\n\t\tmake();\r\n\r\n\t\tif (lazy==0) return;\r\n\t\tval += lazy*(e-s+1);\r\n\r\n\t\tif (s!=e) {\r\n\t\t\tLL->lazy+=lazy;\r\n\t\t\tRR->lazy+=lazy;\r\n\t\t}\r\n\r\n\t\tlazy-=lazy;\r\n\r\n\t}\r\n\r\n\tvoid update(long long _s, long long _e, long long _v) {\r\n\t\tif (s==_s && e==_e) lazy += _v;\r\n\t\telse {\r\n\t\t\tmake();\r\n\t\t\tif (_e <= m) LL->update(_s,_e,_v);\r\n\t\t\telse if (m < _s) RR->update(_s,_e,_v);\r\n\t\t\telse {\r\n\t\t\t\tLL->update(_s, m, _v);\r\n\t\t\t\tRR->update(m+1, _e, _v);\r\n\t\t\t}\r\n\t\t\tLL->propo();\r\n\t\t\tRR->propo();\r\n\t\t\tval = LL->val + RR->val;\r\n\t\t}\r\n\t}\r\n\r\n\tlong long query(long long _s, long long _e) {\r\n\t\tpropo();\r\n\t\tif (s==_s && e==_e) return val;\r\n\t\telse if (_e<=m) return LL->query(_s,_e);\r\n\t\telse if (m <_s) return RR->query(_s,_e);\r\n\t\telse return LL->query(_s,m) + RR->query(m+1,_e);\r\n\t}\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tnode nod(0LL,N+1);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\tnod.update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << nod.query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "ecxx",
        "id": 91674,
        "date": "2022-01-10 22:54:46",
        "code": "/**\r\n * Codebreaker segmenttree2\r\n * \r\n */\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n\r\nunsigned long long log2Floor(unsigned long long x) {\r\n    return 63 - __builtin_clzll(x);\r\n}\r\n\r\nunsigned long long log2Ceiling(unsigned long long x) {\r\n    return log2Floor(2*x - 1);\r\n}\r\n\r\n\r\nstruct st {\r\n\r\n    int _ptr;\r\n    ll _st, _en;\r\n    vector<ll> val, lazy;\r\n    vector<int> son;\r\n\r\n    st(ll start, ll end, ll Q) {\r\n        _ptr = 0;_st=start;_en=end;\r\n        ll vsize = log2Ceiling(end-start+2)*Q*4;\r\n        val.assign(vsize, 0);\r\n        lazy.assign(vsize, 0);\r\n        son.assign(vsize, -1);\r\n    }  \r\n\r\n    void make(int point) {\r\n        if (son[point]!=-1)return;\r\n        son[point] = ++_ptr;\r\n        ++_ptr;\r\n        if (_ptr>=val.size())exit(1);\r\n    }\r\n\r\n    void propo(int point, ll s, ll e) {\r\n        make(point);\r\n        if (lazy[point]==0)return;\r\n        val[point]+=lazy[point]*(e-s+1);\r\n        if (s!=e){\r\n            lazy[son[point]]+=lazy[point];\r\n            lazy[son[point]+1]+=lazy[point];\r\n        }\r\n        lazy[point]=0;\r\n    }\r\n\r\n    void _update(int point, ll s, ll e, ll _s, ll _e, ll _v) {\r\n        if (s==_s&&e==_e) lazy[point]+=_v;\r\n        else {\r\n            ll m = (s+e)>>1;\r\n            make(point);\r\n            if (_e <= m) _update(son[point], s, m, _s, _e, _v);\r\n            else if (m < _s) _update(son[point]+1, m+1, e, _s, _e, _v);\r\n            else {\r\n                _update(son[point], s, m, _s, m, _v);\r\n                _update(son[point]+1, m+1, e, m+1, _e, _v);\r\n            }\r\n            propo(son[point], s, m);\r\n            propo(son[point]+1, m+1, e);\r\n            val[point] = val[son[point]] + val[son[point]+1];\r\n        }\r\n    }\r\n\r\n    ll _query(int point, ll s, ll e, ll _s, ll _e) {\r\n        //cout << \"QUERIED \" << s << \" \" << e << \" \" << _s << \" \" << _e << \"\\n\";\r\n        propo(point,s,e);\r\n        ll m = (s+e)>>1;\r\n        if (s==_s&&e==_e) return val[point];\r\n        else if (_e<=m) return _query(son[point], s, m, _s, _e);\r\n        else if (m<_s) return _query(son[point]+1, m+1, e, _s, _e);\r\n        else return (\r\n            _query(son[point], s, m, _s, m)\r\n        ) + (\r\n            _query(son[point]+1, m+1, e, m+1, _e)\r\n        );\r\n    }\r\n\r\n    void update(ll s, ll e, ll v) {\r\n        _update(0, _st, _en, s, e, v);\r\n    }\r\n\r\n    ll query(ll s, ll e) {\r\n        return _query(0, _st, _en, s, e);\r\n    }\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tst tree(0LL,N+1,Q);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\ttree.update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << tree.query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "Xiaoyang",
        "id": 90891,
        "date": "2022-01-08 20:30:17",
        "code": "#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define fi first\r\n#define se second\r\n#define pii pair<int,int>\r\n#define pll pair<long long,long long>\r\n#define pb push_back\r\n#define pq priority_queue\r\n#define rep(i,a,b) for (int i=a;i<(b);i++)\r\n#define MP make_pair\r\n#define int long long\r\n#define ALL(x) x.begin(),x.end()\r\n#include <iostream>\r\n#define int long long \r\nusing namespace std;\r\nstruct node{\r\n    int s,e,m;\r\n    node *l,*r;\r\n    int val,lazy;\r\n    node(int S,int E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void create(){\r\n        if (s!=e){\r\n            l = new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n    int query(int a, int b){\r\n        if (l==nullptr) create();\r\n        propagate();\r\n        if (a==s && b==e) return val;\r\n        else if (b<=m) return l->query(a,b);\r\n        else if (a>m) return r->query(a,b);\r\n        else return l->query(a,m) + r->query(m+1,b);\r\n\r\n    }\r\n    void update(int a, int b, int v){\r\n        if (l==nullptr) create();\r\n        if (a==s && b==e) lazy+=v;\r\n        else{\r\n            if (b<=m) l->update(a,b,v);\r\n            else if (a>m) r->update(a,b,v);\r\n            else l->update(a,m,v), r->update(m+1,b,v);\r\n            l->propagate(), r->propagate();\r\n            val = l->val + r->val;\r\n\r\n        }\r\n    }\r\n    void propagate(){\r\n        if (l==nullptr) create();\r\n        if (lazy==0) return;\r\n        val+=(e-s+1)*lazy ;\r\n        if (s!=e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n}*root;\r\nmain(){\r\n    int n;\r\n    cin>>n;\r\n    int q;\r\n    cin>>q;\r\n    int a,b,c,d;\r\n    root = new node(1,n);\r\n    while (q--){\r\n        cin>>a;\r\n        if (a==2){\r\n            cin>>b>>c;\r\n            cout << root->query(b,c) <<'\\n';\r\n\r\n        }\r\n        else {\r\n            cin>>b>>c>>d;\r\n            root->update(b,c,d);\r\n        }\r\n\r\n    }\r\n\r\n}"
    },
    {
        "username": "Xiaoyang",
        "id": 90889,
        "date": "2022-01-08 20:23:09",
        "code": "#pragma GCC optimize(\"O3,unroll-loops\")\r\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define fi first\r\n#define se second\r\n#define pii pair<int,int>\r\n#define pll pair<long long,long long>\r\n#define pb push_back\r\n#define pq priority_queue\r\n#define rep(i,a,b) for (int i=a;i<(b);i++)\r\n#define MP make_pair\r\n#define int long long\r\n#define ALL(x) x.begin(),x.end()\r\nstruct node{\r\n    int s, e, m; //range is [s,e], m is the middle point\r\n    int val; //sum of [s,e]\r\n    int lazy; //lazy tag of [s,e]\r\n    node *l, *r; //create two children l and r, where l is [s,m] and [m+1,e]\r\n    node (int S, int E){ //constructor called node\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0; //initially all values are 0\r\n        lazy = 0; //lazy tag of 0 will mean there is no update (sentinel value)\r\n    }\r\nvoid create(){ ///lazily create children\r\n    if(s != e){ ///impt: cause dont create children if the node is already a leaf\r\n    \tl = new node(s, m);\r\n    \tr = new node(m+1, e);\r\n    }\r\n}\r\nvoid propogate(){\r\n\tif(l == nullptr) create(); //lazily create children\r\n    if (lazy==0) return; //nothing happens\r\n    val+=lazy*(e-s+1); //(e-s+1) is the length of the range\r\n    if (s != e){ //not a leaf, send lazy tags to children\r\n        l->lazy+=lazy;\r\n        r->lazy+=lazy;\r\n    }\r\n    lazy=0; //set our lazy tag value back to the sentinel\r\n}\r\nvoid update(int S, int E, int V){ //increment [S,E] by V\r\n    if(s==S && e==E) lazy += V; //update covers range, update lazy tag\r\n    else{ //go we have to go deeper\r\n    \tif(l == nullptr) create(); //lazily create children\r\n    \tif(E <= m) l->update(S, E, V); //[S,E] is in the left child\r\n    \telse if (m < S) r->update(S, E, V); //[S,E] is in the right child\r\n    \telse {l->update(S, m, V),r->update(m+1, E, V);}\r\n    \tl->propogate(),r->propogate();\r\n    \t//remember to propogate your children before update yourself\r\n    \tval = l->val + r->val; //update the range sum\r\n    }\r\n}\r\nint query(int S, int E){\r\n    propogate(); //remember to propogate\r\n\tif(l == nullptr) create(); //lazily create children\r\n    if(s == S && e == E) return val; //case 1\r\n    else if(E <= m) return l->query(S, E); //case 2, recurse to left child\r\n    else if(S >= m+1) return r->query(S, E); //case 3, recurse to right child\r\n    else return l->query(S, m) + r->query(m+1, E); //case 4, split the query range,\r\n    }\r\n} *root = new node(1, 1000000000);;\r\nsigned main(){\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n    int n,q,l,r,k;\r\n    cin>>n>>q;\r\n    root = new node(0, n);\r\n    while(q--){\r\n        int type;\r\n        cin>>type;\r\n        if(type==1){\r\n            cin>>l>>r>>k;\r\n            root->update(l--,r--,k);\r\n        }else{\r\n            cin>>l>>r;\r\n            int Q = root->query(l--,r--);\r\n          \tcout<<Q<<\"\\n\";\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "bron",
        "id": 82841,
        "date": "2021-12-28 13:27:46",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long int\r\nstruct node{\r\n   int s, e, m; //range is [s,e], m is the middle point\r\n   int val = 0; //sum of [s,e]\r\n   int lazy = 0; //lazy tag of [s,e]\r\n   node *l = nullptr, *r = nullptr; //create two children l and r, where l is [s,m] and [m+1,e]\r\n   node (int S, int E){ //constructor called node\r\n        s = S, e = E, m = (s+e)/2;\r\n       \r\n    }\r\n    void create(){\r\n    \tif(l == nullptr){\r\n    \t\tl = new node(s,m);\r\n    \t\tr = new node(m+1,e);\r\n\t\t}\r\n\t}\r\n    void propogate(){\r\n        if (lazy==0) return; //nothing happens\r\n        val+=lazy*(e-s+1); //(e-s+1) is the length of the range\r\n        if (s != e){ //not a leaf, send lazy tags to children\r\n             create();\r\n             l->lazy+=lazy;\r\n             r->lazy+=lazy;\r\n        }\r\n    lazy=0; //set our lazy tag value back to the sentinel\r\n    }\r\n    void update(int S, int E, int V){ //increment [S,E] by V\r\n        propogate();\r\n\t    if(s==S && e==E) lazy += V; //update covers range, update lazy tag\r\n        else{ //go we have to go deeper\r\n           create();\r\n           if(E <= m) l->update(S, E, V); //[S,E] is in the left child\r\n           else if (m < S) r->update(S, E, V); //[S,E] is in the right child\r\n           else l->update(S, m, V),r->update(m+1, E, V);\r\n           l->propogate(),r->propogate();\r\n//remember to propogate your children before update yourself\r\n           val = l->val + r->val; //update the range sum\r\n        }\r\n    }\r\n    int query(int S, int E){\r\n        propogate(); //remember to propogate\r\n        if(s == S && e == E || l == nullptr) return val; //case 1\r\n        else if(E <= m) return l->query(S, E); //case 2, recurse to left child\r\n        else if(S >= m+1) return r->query(S, E); //case 3, recurse to right child\r\n        else return l->query(S, m) + r->query(m+1, E); //case 4, split the query range,\r\n//recurse to both childs\r\n   }\r\n} *root = new node(0,1e9+100);\r\n\r\n main(){\r\n\tcin.tie(0);\r\n\tios::sync_with_stdio(0);\r\n\tint N,Q;\r\n    cin>>N>>Q;\r\n\tfor(int i=0;i<Q;i++){\r\n\t\tint A,B,C,D;\r\n\t\tcin>>A;\r\n\t    if(A==1){\r\n\t    \tcin>>B>>C>>D;\r\n\t    \troot->update(B,C,D);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>B>>C;\r\n\t\t\tcout<<root->query(B,C)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "begitable",
        "id": 82644,
        "date": "2021-12-27 19:12:54",
        "code": "#include<bits/stdc++.h>\r\n#define int long long \r\nusing namespace std;\r\nint N,tmp;\r\nstruct node{\r\n\tint s,e,m;\r\n\tint val,lazy;\r\n\tnode *l, *r;\r\n\t\r\n\tnode (int S, int E){ \r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t\tval = 0; \r\n\t\tlazy = 0; \r\n\t}\r\n\tvoid create(){ \r\n\t\tif(s != e){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif(l == nullptr) create();\r\n\t\tif (lazy==0) return;\r\n\t\tval+=lazy*(e-s+1); \r\n\t\tif (s != e){ \r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0; \r\n\t}\r\n\tvoid update(int S, int E, int V){ \r\n\t\tif(l == nullptr) create();\r\n\t\tif(s==S && e==E) lazy += V; \r\n\t\telse{ \r\n\t\t\tif(E <= m) l->update(S, E, V);\r\n\t\t\telse if (m < S) r->update(S, E, V);\r\n\t\t\telse l->update(S, m, V),r->update(m+1, E, V);\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\tval = l->val + r->val; \r\n\t\t}\r\n\t}\r\n\tint query(int S, int E){\r\n\t\tif(l == nullptr) create();\r\n\t\t\r\n\t\tpropogate(); \r\n\t\t\r\n\t\tif(s == S && e == E) return val; \r\n\t\telse if(E <= m){\r\n\t\t\treturn l->query(S, E);\r\n\t\t} \r\n\t\telse if(S >= m+1) {return r->query(S, E);} \r\n\t\telse {return l->query(S, m) + r->query(m+1, E);}\r\n\t\t\r\n\t}\r\n} ;\r\n\r\nint32_t main(){\r\n\tint q, sum;\r\n\tcin >> N >> q;\r\n\tnode*root = new node(1,N);\r\n\tfor(int i = 0; i <q; i++){\r\n\t\tint a,b,c;\r\n\t\tcin >> a >> b >> c;\r\n\t\tif(a == 1){\r\n\t\t\tint k;\r\n\t\t\tcin >> k;\r\n\t\t\troot->update(b,c,k);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout<< root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "begitable",
        "id": 82632,
        "date": "2021-12-27 19:01:14",
        "code": "#include<bits/stdc++.h>\r\n#define int long long \r\nusing namespace std;\r\nint N,tmp;\r\nstruct node{\r\n\tint s,e,m;\r\n\tint val,lazy;\r\n\tnode *l, *r;\r\n\t\r\n\tnode (int S, int E){ \r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t\tval = 0; \r\n\t\tlazy = 0; \r\n\t}\r\n\tvoid create(){ \r\n\t\tif(s != e){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif(l == nullptr) create();\r\n\t\tif (lazy==0) return;\r\n\t\tval+=lazy*(e-s+1); \r\n\t\tif (s != e){ \r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0; \r\n\t}\r\n\tvoid update(int S, int E, int V){ \r\n\t\tif(l == nullptr) create();\r\n\t\tif(s==S && e==E) lazy += V; \r\n\t\telse{ \r\n\t\t\tif(E <= m) l->update(S, E, V);\r\n\t\t\telse if (m < S) r->update(S, E, V);\r\n\t\t\telse l->update(S, m, V),r->update(m+1, E, V);\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\tval = l->val + r->val; \r\n\t\t}\r\n\t}\r\n\tint query(int S, int E){\r\n\t\tif(l == nullptr) create();\r\n\t\t\r\n\t\tpropogate(); \r\n\t\t\r\n\t\tif(s == S && e == E) return val; \r\n\t\telse if(E <= m){\r\n\t\t\treturn l->query(S, E);\r\n\t\t} \r\n\t\telse if(S >= m+1) {return r->query(S, E);} \r\n\t\telse {return l->query(S, m) + r->query(m+1, E);}\r\n\t\t\r\n\t}\r\n} ;\r\n\r\nint32_t main(){\r\n\tint q, sum;\r\n\tcin >> N >> q;\r\n\tnode*root = new node(1,N);\r\n\tfor(int i = 0; i <q; i++){\r\n\t\tint a,b,c;\r\n\t\tcin >> a >> b >> c;\r\n\t\tif(a == 1){\r\n\t\t\tint k;\r\n\t\t\tcin >> k;\r\n\t\t\troot->update(b,c,k);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout<< root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "Max",
        "id": 77998,
        "date": "2021-12-19 13:41:12",
        "code": "#include <iostream>\r\nusing namespace std;\r\n\r\nlong long N, Q;\r\n\r\nstruct node{\r\n    long long s, e, m, val, lazy;\r\n    node *l, *r;\r\n\r\n    node(long long s1, long long e1):\r\n    s(s1), e(e1), m((long long)((s1 + e1) / 2)), val(0), lazy(0){\r\n        if(s != e){\r\n            l = nullptr;\r\n            r = nullptr;\r\n        }\r\n    }\r\n\r\n    void createl(){\r\n        l = new node(s, m);\r\n    }\r\n\r\n    void creater(){\r\n        r = new node(m + 1, e);\r\n    }\r\n\r\n    void prop(){\r\n        if(lazy == 0) return;\r\n\r\n        val += (e - s + 1) * lazy;\r\n        if(l == nullptr) createl();\r\n        if(r == nullptr) creater();\r\n        if(s != e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        \r\n        lazy = 0;\r\n    }\r\n\r\n    void update(long long L, long long R, long long incre){\r\n        prop();\r\n        if(L <= s && R >= e){\r\n            lazy += incre;\r\n            return;\r\n        }\r\n        if(l == nullptr) createl();\r\n        if(r == nullptr) creater();\r\n        if(L > m) r->update(L, R, incre);\r\n        else if(R <= m) l->update(L, R, incre);\r\n        else{\r\n            l->update(L, m, incre);\r\n            r->update(m + 1, R, incre);\r\n        }\r\n        l->prop(); r->prop();\r\n        val = l->val + r->val;\r\n    }\r\n\r\n    long long q(long long x, long long y){\r\n        prop();\r\n        if(s >= x && e <= y) return val;\r\n        if(l == nullptr) createl();\r\n        if(r == nullptr) creater();\r\n        if(x > m) return r->q(x, y);\r\n        if(y <= m) return l->q(x, y);\r\n        return l->q(x, m) + r->q(m + 1, y);\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n    cin >> N >> Q;\r\n    root = new node(1, N);\r\n    for(int i = 0; i < Q; i++){\r\n        int type; cin >> type;\r\n        if(type == 1){\r\n            long long l, r, k;\r\n            cin >> l >> r >> k;\r\n            root->update(l,r,k);\r\n        }\r\n        else{\r\n            long long l, r;\r\n            cin >> l >> r;\r\n            cout << root->q(l, r) << endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "dsyz",
        "id": 76659,
        "date": "2021-12-17 02:41:38",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\n#define MAXN (10005)\r\nstruct node{\r\n  ll s,e,m,val,lazy;\r\n  node *l,*r;\r\n  node(ll S,ll E){\r\n    s = S;\r\n    e = E;\r\n    m = (s + e) >> 1;\r\n    val = 0;\r\n    lazy = 0;\r\n  }\r\n  void create(){\r\n    if(l == nullptr && s != e){\r\n      l = new node(s,m);\r\n      r = new node(m + 1,e);\r\n    }\r\n  }\r\n  void propagate(){\r\n    create();\r\n    if(lazy == 0){\r\n      return;\r\n    }\r\n    val += lazy * (e - s + 1);\r\n    if(s != e){\r\n      l->lazy += lazy;\r\n      r->lazy += lazy;\r\n    }\r\n    lazy = 0;\r\n  }\r\n  void update(ll S,ll E,ll v){\r\n    if(s == S && e == E) lazy += v;\r\n    else{\r\n      create();\r\n      if(E <= m) l->update(S,E,v);\r\n      else if(S > m) r->update(S,E,v);\r\n      else l->update(S,m,v),r->update(m + 1,E,v);\r\n      l->propagate(),r->propagate();\r\n      val = l->val + r->val;\r\n    }\r\n  }\r\n  long long query(ll S,ll E){\r\n    create();\r\n    propagate();\r\n    if(s == S && e == E) return val;\r\n    else if(S > m) return r->query(S,E);\r\n    else if(E <= m) return l->query(S,E);\r\n    else return l->query(S,m) + r-> query(m + 1,E);\r\n  }\r\n} *root;\r\nint main() {\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  ll N,Q;\r\n  cin>>N>>Q;\r\n  root = new node(0,N + 1);\r\n  for(ll i = 0;i < Q;i++){\r\n    ll a;\r\n    cin>>a;\r\n    if(a == 1){\r\n      ll L,R,k;\r\n      cin>>L>>R>>k;\r\n      root -> update(L - 1,R - 1,k);\r\n    }else if(a == 2){\r\n      ll L,R;\r\n      cin>>L>>R;\r\n      cout<<root -> query(L - 1,R - 1)<<'\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "leyi",
        "id": 74245,
        "date": "2021-12-14 12:49:24",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node{\r\n\tlong long s, e, m; \r\n\tlong long val;\r\n\tlong long lazy; \r\n\tnode *l, *r;\r\n\t\r\n\tnode (long long S, long long E){ \r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t\tval = 0;\r\n\t\tlazy = 0;\r\n\t}\r\n\t\r\n\tvoid create(){\r\n\t\tif(s != e){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid propogate(){\r\n\t\tif(l == nullptr) create();\r\n\t\tif (lazy==0) return;\r\n\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif (s != e){ \r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\t\r\n\tvoid update(long long S, long long E, long long V){ \r\n\t\tif(l == nullptr) create();\r\n\t\tif(s==S && e==E) lazy += V;\r\n\t\telse{\r\n\t\t\tif(E <= m) l->update(S, E, V);\r\n\t\t\telse if (m < S) r->update(S, E, V);\r\n\t\t\telse l->update(S, m, V),r->update(m+1, E, V);\r\n\t\t\t\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\t\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\t\r\n\tlong long query(long long S, long long E){\r\n\t\tif(l == nullptr) create();\r\n\t\tpropogate();\r\n\t\t\r\n\t\tif(s == S && e == E) return val;\r\n\t\telse if(E <= m) return l->query(S, E);\r\n\t\telse if(S >= m+1) return r->query(S, E); \r\n\t\telse return l->query(S, m) + r->query(m+1, E); \r\n\t}\r\n} *root;\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n\tlong long int n, q; cin >> n >> q;\r\n\troot = new node(1, n);\r\n\tfor(int i=0; i<q; i++){\r\n\t\tlong long int a; cin >> a;\r\n\t\tif(a == 1){\r\n\t\t\tlong long b, c, d; cin >> b >> c >> d;\r\n\t\t\troot->update(b, c, d);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlong long b, c; cin >> b >> c;\r\n\t\t\tlong long int ans = root->query(b, c); \r\n\t\t\tcout << ans << \"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "penguin133",
        "id": 73974,
        "date": "2021-12-13 21:41:51",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n\tint s,e,m, val = 0, lazy = 0;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\tnode(int _s, int _e){\r\n\t\ts = _s, e = _e;\r\n\t\tm = s + (e-s)/2;\r\n\t}\r\n\tvoid mc(){\r\n\t\tif(l == nullptr){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\tvoid propo(){\r\n\t\tif(lazy == 0)return;\r\n\t\tval += lazy*(e-s+1);\r\n\t\tif(s != e){\r\n\t\t\tmc();\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy =0;\r\n\t}\r\n\tvoid update(int a, int b, int c){\r\n\t\tpropo();\r\n\t\tif(a == s && b == e)lazy += c;\r\n\t\telse{\r\n\t\t\tmc();\r\n\t\t\tif(b <= m)l->update(a,b,c);\r\n\t\t\telse if(a > m)r->update(a,b,c);\r\n\t\t\telse l->update(a,m,c), r->update(m+1,b,c);\r\n\t\t\tl->propo(), r->propo();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\tint query(int a,int b){\r\n\t\tpropo();\r\n\t\tif((a == s && b == e) || l == nullptr)return val;\r\n\t\telse{\r\n\t\t\tif(b <= m)return l->query(a,b);\r\n\t\t\telse if(a > m)return r->query(a,b);\r\n\t\t\telse return l->query(a,m) + r->query(m+1,b);\r\n\t\t}\r\n\t}\r\n}*root  =new node(0, 1e9 + 100);\r\n\r\nmain(){\r\n\tios::sync_with_stdio(0);cin.tie(0);\r\n\tint n,q;\r\n\tcin >> n >> q;\r\n\twhile(q--){\r\n\t\tint a,b,c,d;\r\n\t\tcin >> a;\r\n\t\tif(!--a){\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << root->query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "Ywq06",
        "id": 73453,
        "date": "2021-12-13 11:30:24",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nstruct node{\r\nlong long s, e, m; //range is [s,e], m is the middle point\r\nlong long val; //sum of [s,e]\r\nlong long lazy; //lazy tag of [s,e]\r\nnode *l = nullptr, *r = nullptr; //create two children l and r, where l is [s,m] and [m+1,e]\r\nvoid create(){ ///lazily create children\r\nif (s!=e) { /// impt: cause don't create children if the node is already a leaf\r\nl = new node (s, m);\r\nr = new node(m+1, e);\r\n}\r\n}\r\nnode (int S, int E){ //constructor called node\r\ns = S, e = E, m = (s+e)/2;\r\nval = 0; //initially all values are 0\r\nlazy = 0; //lazy tag of 0 will mean there is no update (sentinel value)\r\n}\r\nvoid propogate(){\r\nif (l == nullptr) create();\r\nif (lazy==0) return; //nothing happens\r\nval+=lazy*(e-s+1); //(e-s+1) is the length of the range\r\nif (s != e){ //not a leaf, send lazy tags to children\r\nl->lazy+=lazy;\r\nr->lazy+=lazy;\r\n}\r\nlazy=0; //set our lazy tag value back to the sentinel\r\n}\r\nvoid update(int S, int E, int V){ //increment [S,E] by V\r\nif (l == nullptr) create();\r\nif(s==S && e==E) lazy += V; //update covers range, update lazy tag\r\nelse{ //go we have to go deeper\r\nif(E <= m) l->update(S, E, V); //[S,E] is in the left child\r\nelse if (m < S) r->update(S, E, V); //[S,E] is in the right child\r\nelse l->update(S, m, V),r->update(m+1, E, V);\r\nl->propogate(),r->propogate();\r\n//remember to propogate your children before update yourself\r\nval = l->val + r->val; //update the range sum\r\n}\r\n}\r\nlong long query(int S, int E){\r\nif (l == nullptr) create();\r\npropogate(); //remember to propogate\r\nif(s == S && e == E) return val; //case 1\r\nelse if(E <= m) return l->query(S, E); //case 2, recurse to left child\r\nelse if(S >= m+1) return r->query(S, E); //case 3, recurse to right child\r\nelse return l->query(S, m) + r->query(m+1, E); //case 4, split the query range, recurse to both childs\r\n}\r\n} *root;\r\n\r\nint main(){\r\n  long long a,b,c,t1,t2,t3;\r\n  cin >> a >> b;\r\n  root=new node(1,a);\r\n  for(int i=0;i<b;i++){\r\n    cin >> c;\r\n    if(c==1){\r\n      cin >> t1 >> t2 >> t3;\r\n      root->update(t1,t2,t3);\r\n    }\r\n    else{\r\n      cin >> t1 >> t2;\r\n      cout << root->query(t1,t2) << \"\\n\";\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "Fenixion",
        "id": 73444,
        "date": "2021-12-13 11:26:37",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\nstruct node{\r\n    ll s, e, m;\r\n    ll val;\r\n    ll lazy;\r\n    node *l, *r;\r\n\r\n    node (ll S, ll E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n        l = r = nullptr;\r\n    }\r\n    void create() {\r\n        if(s != e){\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n\r\n    }\r\n\r\n    void propogate(){\r\n        if (lazy==0) return;\r\n        val += lazy*(e-s+1);\r\n        if (l == nullptr) create();\r\n        if (s != e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n    void update(ll S, ll E, ll V){\r\n        if(s==S && e==E) lazy += V;\r\n        else{\r\n            if (l == nullptr) create();\r\n            if(E <= m) l->update(S, E, V);\r\n            else if (m < S) r->update(S, E, V);\r\n            else l->update(S, m, V), r->update(m+1, E, V);\r\n            l->propogate(), r->propogate();\r\n            val = l->val + r->val;\r\n        }\r\n    }\r\n    ll query(ll S, ll E){\r\n        if (l == nullptr) create();\r\n        propogate();\r\n        if(s == S && e == E) return val;\r\n        else if(E <= m) return l->query(S, E);\r\n        else if(S >= m+1) return r->query(S, E);\r\n        else return l->query(S, m) + r->query(m+1, E);\r\n    }\r\n} *root;\r\n\r\n\r\n\r\nint main() {\r\n    ios::sync_with_stdio(); cin.tie(0); cout.tie(0);\r\n    ll n, q, op, a, b, c;\r\n    cin >> n >> q;\r\n    root = new node(1,n);\r\n    for (ll i=0;i<q;i++) {\r\n        scanf(\"%lld\", &op);\r\n        if (op == 1) {\r\n            scanf(\"%lld%lld%lld\", &a, &b, &c);\r\n            root->update(a,b,c);\r\n        }\r\n        else {\r\n            scanf(\"%lld%lld\", &a, &b);\r\n            cout << root->query(a,b) << \"\\n\";\r\n        }\r\n    }\r\n\r\n\r\n\r\n}\r\n/*\r\n5 5\r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/\r\n\r\n"
    },
    {
        "username": "begitable",
        "id": 73433,
        "date": "2021-12-13 11:21:28",
        "code": "#include<bits/stdc++.h>\r\n#define int long long \r\nusing namespace std;\r\nint N,tmp;\r\nstruct node{\r\n\tint s,e,m;\r\n\tint val,lazy;\r\n\tnode *l, *r;\r\n\t\r\n\tnode (int S, int E){ \r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t\tval = 0; \r\n\t\tlazy = 0; \r\n\t}\r\n\tvoid create(){ \r\n\t\tif(s != e){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif(l == nullptr) create();\r\n\t\tif (lazy==0) return;\r\n\t\tval+=lazy*(e-s+1); \r\n\t\tif (s != e){ \r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0; \r\n\t}\r\n\tvoid update(int S, int E, int V){ \r\n\t\tif(l == nullptr) create();\r\n\t\tif(s==S && e==E) lazy += V; \r\n\t\telse{ \r\n\t\t\tif(E <= m) l->update(S, E, V);\r\n\t\t\telse if (m < S) r->update(S, E, V);\r\n\t\t\telse l->update(S, m, V),r->update(m+1, E, V);\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\tval = l->val + r->val; \r\n\t\t}\r\n\t}\r\n\tint query(int S, int E){\r\n\t\tif(l == nullptr) create();\r\n\t\t\r\n\t\tpropogate(); \r\n\t\t\r\n\t\tif(s == S && e == E) return val; \r\n\t\telse if(E <= m){\r\n\t\t\treturn l->query(S, E);\r\n\t\t} \r\n\t\telse if(S >= m+1) {return r->query(S, E);} \r\n\t\telse {return l->query(S, m) + r->query(m+1, E);}\r\n\t\t\r\n\t}\r\n} ;\r\n\r\nint32_t main(){\r\n\tint q, sum;\r\n\tcin >> N >> q;\r\n\tnode*root = new node(1,N);\r\n\tfor(int i = 0; i <q; i++){\r\n\t\tint a,b,c;\r\n\t\tcin >> a >> b >> c;\r\n\t\tif(a == 1){\r\n\t\t\tint k;\r\n\t\t\tcin >> k;\r\n\t\t\troot->update(b,c,k);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout<< root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "blackscreen1",
        "id": 73403,
        "date": "2021-12-13 11:13:09",
        "code": "#include <bits//stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n#define st short\r\n#define iloop(m, h) for (auto i = m; i < h; i++)\r\n#define jloop(m, h) for (auto j = m; j < h; j++)\r\n#define kloop(m, h) for (auto k = m; k < h; k++)\r\nll n;\r\nstruct node{\r\nll s, e, m;\r\nll val;\r\nll lazy;\r\nbool children;\r\nnode *l, *r;\r\nnode (ll S, ll E){\r\ns = S, e = E, m = (s+e)/2;\r\nval = 0;\r\nlazy = 0;\r\nchildren = 0;\r\n}\r\nvoid create() {\r\nif (s != e) {\r\nl = new node(s, m);\r\nr = new node(m+1, e);\r\nchildren = 1;\r\n}\t\r\n}\r\nvoid propogate(){\r\nif (lazy==0) return;\r\nval+=lazy*(e-s+1);\r\nif (children == false) {create();}\r\nif (s != e){\r\nl->lazy+=lazy;\r\nr->lazy+=lazy;\r\n}\r\nlazy=0;\r\n}\r\nvoid update(ll S, ll E, ll V){\r\nif(s==S && e==E) lazy += V;\r\nelse{\r\nif (children == false) create();\r\nif(E <= m) l->update(S, E, V);\r\nelse if (m < S) r->update(S, E, V);\r\nelse l->update(S, m, V),r->update(m+1, E, V);\r\nl->propogate(),r->propogate();\r\nval = l->val + r->val;\r\n}\r\n}\r\nll query(ll S, ll E){\r\nif (children == false) create();\r\npropogate();\r\nif(s == S && e == E) return val;\r\nelse if(E <= m) return l->query(S, E);\r\nelse if(S >= m+1) return r->query(S, E);\r\nelse return l->query(S, m) + r->query(m+1, E);\r\n}\r\n};\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(NULL);\r\n\tcin >> n;\r\n\tnode root(1, n);\r\n\tll f, cmd, a, b, c;\r\n\tcin >> f;\r\n\twhile (f--) {\r\n\t\tcin >> cmd;\r\n\t\tif (cmd == 2) {cin >> a >> b; cout << root.query(a,b) << \"\\n\";}\r\n\t\telse {cin >> a >> b >> c; root.update(a,b,c);}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "veg",
        "id": 73364,
        "date": "2021-12-13 11:01:45",
        "code": "#include <iostream>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n\tint s,e,m;\r\n\tint val;\r\n\tnode *l,*r;\r\n\tint lazy;\r\n\tnode(int S,int E){\r\n\t\ts=S;\r\n\t\te=E;\r\n\t\tm=(e+s)/2;\r\n\t\tval=0;\r\n\t\tlazy=0;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(s!=e){\r\n\t\t\tl=new node(s,m);\r\n\t\t\tr=new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\tvoid propo(){\r\n\t\tif(lazy==0)return;\r\n\t\tval+=lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tif(l==nullptr)create();\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\tvoid update(int S,int E,int V){\r\n\t\tif(s==S&&e==E)lazy+=V;\r\n\t\telse{\r\n\t\t\tif(l==nullptr)create();\r\n\t\t\tif(E<=m){\r\n\t\t\t\tl->update(S,E,V);\r\n\t\t\t}else if(m<S){\r\n\t\t\t\tr->update(S,E,V);\r\n\t\t\t}else{\r\n\t\t\t\tl->update(S,m,V);\r\n\t\t\t\tr->update(m+1,E,V);\r\n\t\t\t}\r\n\t\t\tl->propo();\r\n\t\t\tr->propo();\r\n\t\t\tval=l->val+r->val;\r\n\t\t}\r\n\t}\r\n\tint query(int S,int E){\r\n\t\tpropo();\r\n\t\tif(s==S&&e==E)return val;\r\n\t\telse{\r\n\t\t\tif(l==nullptr)create();\r\n\t\t\tif(E<=m)return l->query(S,E);\r\n\t\t\telse if(S>m)return r->query(S,E);\r\n\t\t\telse return l->query(S, m) + r->query(m+1, E);\r\n\t\t}\r\n\t}\r\n\r\n}*root;\r\n\r\nint32_t main(){\r\n\tios::sync_with_stdio(0);cin.tie(0);\r\n\tint n,q;\r\n\tcin>>n>>q;\r\n\troot = new node (1,n);\r\n\tfor(int i=0;i<q;i++){\r\n\t\tint a;cin>>a;\r\n\t\tif(a==1){\r\n\t\t\tint l,r,k;cin>>l>>r>>k;\r\n\t\t\troot->update(l,r,k);\r\n\t\t}else{\r\n\t\t\tint l,r;cin>>l>>r;\r\n\t\t\tcout<<root->query(l,r)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "edwinkoon",
        "id": 73276,
        "date": "2021-12-13 10:31:41",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct Node{\r\n    int s,e,m;\r\n    int val,lazy;\r\n    Node *l=nullptr, *r=nullptr;\r\n\r\n    Node (int S, int E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n\r\n    void prop(){\r\n        if (lazy==0) return;\r\n\r\n        val += lazy*(e-s+1);\r\n        if (l==nullptr) create();\r\n        if (s != e){\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0;\r\n    }\r\n\r\n    void create(){\r\n        if (s!=e){\r\n            l = new Node(s,m);\r\n            r = new Node(m+1,e);\r\n        }\r\n    }\r\n\r\n    void update(int S, int E, int V){\r\n        if (l==nullptr && s!=e) create();\r\n        if (s==S && e == E) lazy+=V;\r\n        else{\r\n            if (E <= m) l->update(S,E,V);\r\n            else if (m<S) r->update(S,E,V);\r\n\r\n            else l->update(S,m,V), r-> update(m+1, E,V);\r\n\r\n            l->prop(), r->prop();\r\n            val = l->val+r->val;\r\n        }\r\n    }\r\n\r\n    int query(int S, int E){\r\n        if (l==nullptr) create();\r\n        prop();\r\n\r\n        if (s==S && e==E) return val;\r\n        else if (E<=m) return l->query(S,E);\r\n        else if (S>=m+1) return r->query(S,E);\r\n        else return l->query(S,m) + r-> query(m+1, E);\r\n    }\r\n} *root = new Node(1,1000000010);\r\n\r\nint32_t main() {\r\n    ios_base::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n    int N;\r\n    cin >> N;\r\n    int Q;\r\n    cin >> Q;\r\n    for (int i = 0; i < Q; ++i){\r\n        int t, a, b, c;\r\n        cin >> t >> a >> b;\r\n        if (t == 1){cin >> c; root->update(a,b,c);}\r\n        else if (t == 2) cout << root->query(a, b) << \"\\n\";\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "Ok",
        "id": 73269,
        "date": "2021-12-13 10:26:55",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nint N,Q,h2,h3,h4;\r\nlong long int h;\r\nlong long int lst[100100];\r\n\r\nstruct node{\r\n    int s,e,m,child;\r\n    long long int v;\r\n    long long int lazy;\r\n\r\n    node *l, *r;\r\n\r\n    node(int S, int E){\r\n        lazy = 0;\r\n        s = S;\r\n        e = E;\r\n        m = (S + E)/2;\r\n        child = 0;\r\n        v = 0;\r\n    }\r\n\r\n    void update(int S ,int E, int h1){\r\n        if(S <= s && E >= e){\r\n            lazy = lazy + h1;\r\n            return;\r\n        }\r\n        v = 0;\r\n        if(S <= m){\r\n            if(child == 0){\r\n                l = new node(s,m);\r\n                r = new node(m+1,e);\r\n                child = 1;\r\n            }\r\n\r\n            l -> update(S,E,h1);\r\n        }\r\n        if(E > m){\r\n            if(child == 0){\r\n                l = new node(s,m);\r\n                r = new node(m+1,e);\r\n                child = 1;\r\n            }\r\n            r -> update(S,E,h1);\r\n        }\r\n\r\n        v = v + l -> lazy  * (l -> e - l -> s + 1);\r\n        v = v + r -> lazy  * (r -> e - r -> s + 1);\r\n        v = l -> v + r -> v + v;\r\n        return;\r\n    }\r\n\r\n    long long int query(int S, int E){\r\n        long long int V = 0;\r\n        if(S <= s && E >= e){\r\n            V = v + lazy * (e - s + 1);\r\n            return V;\r\n        }\r\n\r\n        if(child == 0){\r\n            return 0 + lazy  * (min(E,e) - max(S,s) + 1);\r\n        }\r\n\r\n        if(S <= m){\r\n            V = V + l -> query(S, E);\r\n        }\r\n        if(E > m){\r\n            V = V + r -> query(S, E);\r\n        }\r\n\r\n        if(min(E,e) - max(S,s) + 1 < 0){\r\n            return V;\r\n        }\r\n        else{\r\n            return V + lazy  * (min(E,e) - max(S,s) + 1);\r\n        }\r\n    }\r\n\r\n}*root;\r\n\r\nint main(){\r\n    scanf(\" %d\",&N);\r\n    root = new node(1,N);\r\n\r\n    scanf(\" %d\",&Q);\r\n\r\n    for(int i = 0; i < Q; i++){\r\n        scanf(\" %d\",&h2);\r\n        if(h2 == 2){\r\n            scanf(\" %d\",&h2);\r\n            scanf(\" %d\",&h3);\r\n            printf(\"%lld\\n\",root -> query(h2,h3));\r\n        }\r\n        else{\r\n            scanf(\" %d\",&h2);\r\n            scanf(\" %d\",&h3);\r\n            scanf(\" %d\",&h4);\r\n            root -> update(h2,h3,h4);\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n"
    },
    {
        "username": "thegrimbee",
        "id": 73254,
        "date": "2021-12-13 10:20:32",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n\tint s, e, m, lazy;\r\n\tint val;\r\n\tnode *l, *r; ///dont create them initially\r\n\tnode (int S, int E){\r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t\tval = 0;\r\n\t\tlazy = 0;\r\n\t\t//do not create children l and r right now\r\n\t}\r\n\tvoid create(){ ///lazily create children\r\n\t\tif(s != e){ ///impt: cause dont create children if the node is already a leaf\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif (lazy==0) return; //nothing happens\r\n\t\tval+=lazy*(e-s+1); //(e-s+1) is the length of the range\r\n\t\tif (s != e){ //not a leaf, send lazy tags to children\r\n\t\t\tif(l == nullptr) create();\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0; //set our lazy tag value back to the sentinel\r\n\t}\r\n\tvoid update(int S, int E, int V){\r\n\t\tif(s == S && e == E) lazy+= V;\r\n\t\telse{\r\n\t\t\tif(l == nullptr) create(); //lazily create children\r\n\t\t\tif(E <= m) l->update(S, E, V); //[S,E] is in the left child\r\n\t\t\telse if (m < S) r->update(S, E, V); //[S,E] is in the right child\r\n\t\t\telse l->update(S, m, V),r->update(m+1, E, V);\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\t//remember to propogate your children before update yourself\r\n\t\t\tval = l->val + r->val; //update the range sum\r\n\t\t}\r\n\t}\r\n\tint query(int S, int E){\r\n\t\tif(l == nullptr) create(); //lazily create children\r\n\t\tpropogate(); //remember to propogate\r\n\t\tif(s == S && e == E) return val; //case 1\r\n\t\telse if(E <= m) return l->query(S, E); //case 2, recurse to left child\r\n\t\telse if(S >= m+1) return r->query(S, E); //case 3, recurse to right child\r\n\t\telse return l->query(S, m) + r->query(m+1, E); //case 4, split the query range,\r\n\t}\r\n} *root;\r\nsigned main(){\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tint N, Q, a, b, c, d;\r\n\tcin >> N >> Q;\r\n\troot = new node(1, 1000000000);\r\n\tfor (int i = 0; i < Q; ++i){\r\n\t\tcin >> a >> b >> c;\r\n\t\tif (a == 1){\r\n\t\t\tcin >> d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse cout << root->query(b,c) << '\\n';\r\n\t}\r\n}\r\n"
    },
    {
        "username": "dodgydog",
        "id": 73231,
        "date": "2021-12-13 10:01:39",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nstruct node{\r\n\tint s, e, m, val ,lazy;\r\n\tnode *l, *r; \r\n\tnode (int S, int E){ \r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t\tval = 0; \r\n\t\tlazy = 0; \r\n\t}\r\n\tvoid create(){\r\n\t\tif(s != e){ \r\n\t\t\t\tl = new node(s, m);\r\n\t\t\t\tr = new node(m+1, e); \r\n\t\t}\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif (lazy==0) return; \r\n\t\tval+=lazy*(e-s+1); \r\n\t\tif (l==nullptr) create();\r\n\t\tif (s != e){ \r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0; \r\n\t}\r\n\tvoid update(int S, int E, int V){ \r\n\t\tif (l==nullptr) create();\r\n\t\tif(s==S && e==E) lazy += V; \r\n\t\telse{ \r\n\t\t\tif(E <= m) l->update(S, E, V); \r\n\t\t\telse if (m < S) r->update(S, E, V); \r\n\t\t\telse l->update(S, m, V),r->update(m+1, E, V);\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\tval = l->val + r->val; \r\n\t\t}\r\n\t}\r\n\tint query(int S, int E){\r\n\t\tif (l==nullptr) create();\r\n\t\tpropogate(); \r\n\t\tif(s == S && e == E) return val; \r\n\t\telse if(E <= m) return l->query(S, E); \r\n\t\telse if(S >= m+1) return r->query(S, E); \r\n\t\telse return l->query(S, m) + r->query(m+1, E); \r\n\t}\r\n} *root;\r\nint32_t main(){\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(0);\r\n  cout.tie(0);\r\n  int a,b,c,d,e; cin >> a >> b;\r\n  root = new node(1,a);\r\n  while (b--){\r\n    cin >> c;\r\n    if (c==1){\r\n      cin >> c >> d >> e;\r\n      root->update(c,d,e);\r\n    }\r\n    else{\r\n      cin >> c >> d;\r\n      cout << root->query(c,d) << '\\n';\r\n    }\r\n  }\r\n}\r\n"
    },
    {
        "username": "penguin133",
        "id": 73219,
        "date": "2021-12-13 09:45:56",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n\tint s,e,m, val = 0, lazy = 0;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\tnode(int _s, int _e){\r\n\t\ts = _s, e = _e;\r\n\t\tm = s + (e-s)/2;\r\n\t}\r\n\tvoid mc(){\r\n\t\tif(l == nullptr){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\tvoid propo(){\r\n\t\tif(lazy == 0)return;\r\n\t\tval += lazy*(e-s+1);\r\n\t\tif(s != e){\r\n\t\t\tmc();\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy =0;\r\n\t}\r\n\tvoid update(int a, int b, int c){\r\n\t\tpropo();\r\n\t\tif(a == s && b == e)lazy += c;\r\n\t\telse{\r\n\t\t\tmc();\r\n\t\t\tif(b <= m)l->update(a,b,c);\r\n\t\t\telse if(a > m)r->update(a,b,c);\r\n\t\t\telse l->update(a,m,c), r->update(m+1,b,c);\r\n\t\t\tl->propo(), r->propo();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\tint query(int a,int b){\r\n\t\tpropo();\r\n\t\tif(a == s && b == e)return val;\r\n\t\telse{\r\n\t\t\tmc();\r\n\t\t\tif(b <= m)return l->query(a,b);\r\n\t\t\telse if(a > m)return r->query(a,b);\r\n\t\t\telse return l->query(a,m) + r->query(m+1,b);\r\n\t\t}\r\n\t}\r\n}*root  =new node(0, 1e9 + 100);\r\n\r\nmain(){\r\n\tios::sync_with_stdio(0);cin.tie(0);\r\n\tint n,q;\r\n\tcin >> n >> q;\r\n\twhile(q--){\r\n\t\tint a,b,c,d;\r\n\t\tcin >> a;\r\n\t\tif(!--a){\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << root->query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "jamestan",
        "id": 72898,
        "date": "2021-12-12 17:30:49",
        "code": "#include <iostream>\r\n#define int long long \r\nusing namespace std;\r\nstruct node{\r\n    int s,e,m;\r\n    node *l,*r;\r\n    int val,lazy;\r\n    node(int S,int E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n    void create(){\r\n        if (s!=e){\r\n            l = new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n    int query(int a, int b){\r\n        if (l==nullptr) create();\r\n        propagate();\r\n        if (a==s && b==e) return val;\r\n        else if (b<=m) return l->query(a,b);\r\n        else if (a>m) return r->query(a,b);\r\n        else return l->query(a,m) + r->query(m+1,b);\r\n\r\n    }\r\n    void update(int a, int b, int v){\r\n        if (l==nullptr) create();\r\n        if (a==s && b==e) lazy+=v;\r\n        else{\r\n            if (b<=m) l->update(a,b,v);\r\n            else if (a>m) r->update(a,b,v);\r\n            else l->update(a,m,v), r->update(m+1,b,v);\r\n            l->propagate(), r->propagate();\r\n            val = l->val + r->val;\r\n\r\n        }\r\n    }\r\n\r\n    void propagate(){\r\n        if (l==nullptr) create();\r\n        if (lazy==0) return;\r\n        val+=(e-s+1)*lazy ;\r\n        if (s!=e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n        \r\n        \r\n    }\r\n    \r\n\r\n}*root;\r\n\r\n\r\n\r\n\r\nmain(){\r\n    int n;\r\n    cin>>n;\r\n    int q;\r\n    cin>>q;\r\n    int a,b,c,d;\r\n    root = new node(1,n);\r\n    while (q--){\r\n        cin>>a;\r\n        if (a==2){\r\n            cin>>b>>c;\r\n            cout << root->query(b,c) <<'\\n';\r\n\r\n        }\r\n        else {\r\n            cin>>b>>c>>d;\r\n            root->update(b,c,d);\r\n        }\r\n\r\n    }\r\n\r\n}"
    },
    {
        "username": "PoTheSloth",
        "id": 72849,
        "date": "2021-12-12 16:36:30",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node\r\n{\r\n    int s, e, mid, val, lazy;\r\n    node *l=nullptr, *r=nullptr;\r\n    node(int S, int E){\r\n        s = S; e = E; mid = (s + e)/2; val = 0; lazy=0;\r\n    }\r\n    void propagate(){\r\n\t\tif(s!=e){\r\n\t\t\tif(l==nullptr)l = new node(s, mid);\r\n\t\t\tif(r==nullptr)r = new node(mid + 1, e);\r\n\t\t}\r\n        if(lazy==0){return;}\r\n        val+=lazy*(e-s+1);\r\n        if(s!=e){\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0;\r\n    }\r\n    void update(int S, int E, int V){\r\n\t\tif(s!=e){\r\n\t\t\tif(l==nullptr)l = new node(s, mid);\r\n\t\t\tif(r==nullptr)r = new node(mid + 1, e);\r\n\t\t}\r\n\t\tpropagate();lazy=0;\r\n\t\tif(s!=e){l->propagate();r->propagate();}\r\n        if(s==S and e==E){lazy+=V;return;}\r\n        else if(E<=mid){propagate(); l->update(S, E, V);}\r\n        else if(S>mid){propagate(); r->update(S, E, V);}\r\n        else{\r\n\t\t\tpropagate();\r\n            l->update(S, mid, V);\r\n            r->update(mid+1, E, V);\r\n        }\r\n        propagate();\r\n        if(s!=e){l->propagate();r->propagate();}\r\n        val = l->val+r->val;\r\n    }\r\n    int query(int S, int E){\r\n\t\tif(s!=e){\r\n\t\t\tif(l==nullptr)l = new node(s, mid);\r\n\t\t\tif(r==nullptr)r = new node(mid + 1, e);\r\n\t\t}\r\n\t\tpropagate();lazy=0;\r\n\t\tif(s!=e){l->propagate();r->propagate();}\r\n        if(s == S and e == E){return val;}\r\n        else if(E <= mid){propagate(); return l->query(S, E);}\r\n\t\telse if(S>mid){propagate(); return r->query(S, E);}\r\n\t\telse{propagate(); return (l->query(S, mid) + r->query(mid+1, E));}\r\n\t\tval = l->val+r->val;\r\n    }\r\n    void initialise(int index, int V){\r\n        if(s==e){val=V;return;}\r\n        if(index<=mid)l->initialise(index, V);\r\n        if(index>mid)r->initialise(index, V);\r\n        //l->propagate();r->propagate();\r\n        val = l->val+r->val;\r\n    }\r\n}*segtree;\r\nint n, q;\r\nint32_t main(){\r\n    ios_base::sync_with_stdio(false); cin.tie(0);cout.tie(0);\r\n    cin>>n>>q;\r\n    segtree = new node(0, n);\r\n    for(int i=0; i<q; ++i){\r\n        short type;\r\n        cin>>type;\r\n        if(type==1){\r\n            int s, e, v;\r\n            cin>>s>>e>>v;\r\n\t\t\tsegtree->update(s, e, v);\r\n        }\r\n        if(type==2){\r\n            int s, e;\r\n            cin>>s>>e;\r\n            cout<<segtree->query(s, e)<<'\\n';\r\n        }\r\n    }\r\n    //~ segtree = new node(0, 5); //DEBUG\r\n    //~ segtree->update(1, 3, -2);//DEBUG\r\n    //~ cout<<segtree->query(1, 1)<<' '<<segtree->query(2, 2)<<' '<<segtree->query(3, 3);//DEBUG\r\n}\r\n"
    },
    {
        "username": "CS24B",
        "id": 72789,
        "date": "2021-12-12 15:23:24",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define ll long long\r\n#define ull unsigned long long\r\n\r\nstruct node {\r\n    int s, e, m;\r\n    ll val, lazy;\r\n    node *l, *r;\r\n\r\n    node(int S, int E) {\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n\r\n    void update(int S, int E, ll V) {\r\n        if (l == nullptr) create();\r\n        if (s == S && e == E) lazy += V;\r\n        else {\r\n            if (E <= m) l->update(S, E, V);\r\n            else if (m < S) r->update(S, E, V);\r\n            else l->update(S, m, V), r->update(m+1, E, V);\r\n            l->propagate(), r->propagate();\r\n            val = l->val + r->val;\r\n        }\r\n    }\r\n\r\n    ll query(int S, int E) {\r\n        if (l == nullptr) create();\r\n        propagate();\r\n        if (s == S && e == E) return val;\r\n        else if (E <= m) return l->query(S, E);\r\n        else if (S >= m+1) return r->query(S, E);\r\n        else return l->query(S, m) + r->query(m+1, E);\r\n    }\r\n\r\n    void create() {\r\n        if (s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n\r\n    void propagate() {\r\n\t\tif (l == nullptr) create();\r\n        if (lazy == 0) return;\r\n        val += lazy*(e-s+1);\r\n        if (s != e) {\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n} *root;\r\n\r\nint n, q, a, l, r, k;\r\n\r\nint main(){\r\n    ios::sync_with_stdio(0), cin.tie(0);\r\n    cin >> n >> q;\r\n    root = new node(1, n);\r\n    while (q--) {\r\n        cin >> a;\r\n        if (a == 1) {\r\n            cin >> l >> r >> k;\r\n            root->update(l, r, k);\r\n        } else {\r\n            cin >> l >> r;\r\n            cout << root->query(l, r) << \"\\n\";\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "CS24B",
        "id": 72788,
        "date": "2021-12-12 15:22:59",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\n#define ll long long\r\n#define ull unsigned long long\r\n\r\nstruct node {\r\n    int s, e, m;\r\n    ll val, lazy;\r\n    node *l, *r;\r\n\r\n    node(int S, int E) {\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n\r\n    void update(int S, int E, ll V) {\r\n        if (l == nullptr) create();\r\n\t\tif (s == e) val += V;\r\n        else if (s == S && e == E) lazy += V;\r\n        else {\r\n            if (E <= m) l->update(S, E, V);\r\n            else if (m < S) r->update(S, E, V);\r\n            else l->update(S, m, V), r->update(m+1, E, V);\r\n            l->propagate(), r->propagate();\r\n            val = l->val + r->val;\r\n        }\r\n    }\r\n\r\n    ll query(int S, int E) {\r\n        if (l == nullptr) create();\r\n        propagate();\r\n        if (s == S && e == E) return val;\r\n        else if (E <= m) return l->query(S, E);\r\n        else if (S >= m+1) return r->query(S, E);\r\n        else return l->query(S, m) + r->query(m+1, E);\r\n    }\r\n\r\n    void create() {\r\n        if (s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n\r\n    void propagate() {\r\n\t\tif (l == nullptr) create();\r\n        if (lazy == 0) return;\r\n        val += lazy*(e-s+1);\r\n        if (s != e) {\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n} *root;\r\n\r\nint n, q, a, l, r, k;\r\n\r\nint main(){\r\n    ios::sync_with_stdio(0), cin.tie(0);\r\n    cin >> n >> q;\r\n    root = new node(1, n);\r\n    while (q--) {\r\n        cin >> a;\r\n        if (a == 1) {\r\n            cin >> l >> r >> k;\r\n\t\t\tif (l > r) root->update(r, l, k);\r\n\t\t\telse root->update(l, r, k);\r\n        } else {\r\n            cin >> l >> r;\r\n\t\t\tif (l > r) cout << root->query(r, l) << \"\\n\";\r\n            else cout << root->query(l, r) << \"\\n\";\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "bebecanvas",
        "id": 72649,
        "date": "2021-12-12 00:46:36",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node{\r\n    int s, e, m; //range is [s,e], m is the middle point\r\n    int val; //sum of [s,e]\r\n    int lazy; //lazy tag of [s,e]\r\n    node *l, *r; //create two children l and r, where l is [s,m] and [m+1,e]\r\n    node (int S, int E){ //constructor called node\r\n       s = S, e = E, m = (s+e)/2;\r\n       val = 0; //initially all values are 0\r\n       lazy = 0; //lazy tag of 0 will mean there is no update (sentinel value)\r\n\t}\r\n\tvoid create(){ ///lazily create children\r\n       if(s != e){ ///impt: cause dont create children if the node is already a leaf\r\n           l = new node(s, m);\r\n           r = new node(m+1, e);\r\n       }\r\n\t}\r\n    void propogate(){\r\n       if (lazy==0) return; //nothing happens\r\n       val+=lazy*(e-s+1); //(e-s+1) is the length of the range\r\n       if (s != e){ //not a leaf, send lazy tags to children\r\n\t\t   if(l == nullptr) create(); \r\n           l->lazy+=lazy;\r\n           r->lazy+=lazy;\r\n       }\r\n       lazy=0; //set our lazy tag value back to the sentinel\r\n    }\r\n    void update(int S, int E, int V){ //increment [S,E] by V\r\n       if(s==S && e==E) lazy += V; //update covers range, update lazy tag\r\n       else{ //go we have to go deeper\r\n\t\t   if(l == nullptr) create(); \r\n           if(E <= m) l->update(S, E, V); //[S,E] is in the left child\r\n           else if (m < S) r->update(S, E, V); //[S,E] is in the right child\r\n           else l->update(S, m, V),r->update(m+1, E, V);\r\n           l->propogate(),r->propogate();\r\n           //remember to propogate your children before update yourself\r\n           val = l->val + r->val; //update the range sum\r\n       }\r\n    }\r\n    int query(int S, int E){\r\n\t\tif(l == nullptr) create(); \r\n       propogate(); //remember to propogate\r\n       if(s == S && e == E) return val; //case 1\r\n       else if(E <= m) return l->query(S, E); //case 2, recurse to left child\r\n       else if(S >= m+1) return r->query(S, E); //case 3, recurse to right child\r\n       else return l->query(S, m) + r->query(m+1, E); //case 4, split the query range,\r\n}\r\n} *root;\r\n\r\nsigned main(){\r\n\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(0);\r\n    \r\n    int n; cin>> n;\r\n    root= new node(1, n);\r\n  \r\n\tint q; cin>> q;\r\n\tfor(int i=0; i<q; i++){\r\n\t\tint a; cin >> a;\r\n\t\tif(a==2){\r\n\t\t\tint b, c; cin>> b >> c;\r\n\t\t\tint ans= root-> query(b, c);\r\n\t\t\tcout << ans << endl;\r\n\t\t}else{\r\n\t\t\tint b, c, d; cin >> b >> c >> d;\r\n\t\t\troot-> update(b, c, d);\r\n\t\t}\r\n\t}\r\n    \r\n}\r\n"
    },
    {
        "username": "bebecanvas",
        "id": 72648,
        "date": "2021-12-12 00:45:45",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node{\r\n    int s, e, m; //range is [s,e], m is the middle point\r\n    int val; //sum of [s,e]\r\n    int lazy; //lazy tag of [s,e]\r\n    node *l, *r; //create two children l and r, where l is [s,m] and [m+1,e]\r\n    node (int S, int E){ //constructor called node\r\n       s = S, e = E, m = (s+e)/2;\r\n       val = 0; //initially all values are 0\r\n       lazy = 0; //lazy tag of 0 will mean there is no update (sentinel value)\r\n\t}\r\n\tvoid create(){ ///lazily create children\r\n       if(s != e){ ///impt: cause dont create children if the node is already a leaf\r\n           l = new node(s, m);\r\n           r = new node(m+1, e);\r\n       }\r\n\t}\r\n    void propogate(){\r\n       if (lazy==0) return; //nothing happens\r\n       val+=lazy*(e-s+1); //(e-s+1) is the length of the range\r\n       if (s != e){ //not a leaf, send lazy tags to children\r\n           if(l == nullptr) create(); \r\n\t\t   l->lazy+=lazy;\r\n           r->lazy+=lazy;\r\n       }\r\n       lazy=0; //set our lazy tag value back to the sentinel\r\n    }\r\n    void update(int S, int E, int V){ //increment [S,E] by V\r\n       if(s==S && e==E) lazy += V; //update covers range, update lazy tag\r\n       else{ //go we have to go deeper\r\n\t\t   if(l == nullptr) create(); \r\n           if(E <= m) l->update(S, E, V); //[S,E] is in the left child\r\n           else if (m < S) r->update(S, E, V); //[S,E] is in the right child\r\n           else l->update(S, m, V),r->update(m+1, E, V);\r\n           l->propogate(),r->propogate();\r\n           //remember to propogate your children before update yourself\r\n           val = l->val + r->val; //update the range sum\r\n       }\r\n    }\r\n    int query(int S, int E){\r\n\t\tif(l == nullptr) create(); \r\n       propogate(); //remember to propogate\r\n       if(s == S && e == E) return val; //case 1\r\n       else if(E <= m) return l->query(S, E); //case 2, recurse to left child\r\n       else if(S >= m+1) return r->query(S, E); //case 3, recurse to right child\r\n       else return l->query(S, m) + r->query(m+1, E); //case 4, split the query range,\r\n}\r\n} *root;\r\n\r\nsigned main(){\r\n\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(0);\r\n    \r\n    int n; cin>> n;\r\n    root= new node(1, n);\r\n  \r\n\tint q; cin>> q;\r\n\tfor(int i=0; i<q; i++){\r\n\t\tint a; cin >> a;\r\n\t\tif(a==2){\r\n\t\t\tint b, c; cin>> b >> c;\r\n\t\t\tint ans= root-> query(b, c);\r\n\t\t\tcout << ans << endl;\r\n\t\t}else{\r\n\t\t\tint b, c, d; cin >> b >> c >> d;\r\n\t\t\troot-> update(b, c, d);\r\n\t\t}\r\n\t}\r\n    \r\n}\r\n"
    },
    {
        "username": "papaoutai",
        "id": 72619,
        "date": "2021-12-11 23:42:02",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int s, e, m;  // range is [s,e], m is the middle poll\r\n    ll val;      // sum of [s,e]\r\n    ll lazy;     // lazy tag of [s,e]\r\n    node *l, *r;  // create two children l and r, where l is [s,m] and [m+1,e]\r\n    node(int S, int E) {  // constructor called node\r\n        s = S, e = E, m = (s + e) / 2;\r\n        val = 0;   // initially all values are 0\r\n        lazy = 0;  // lazy tag of 0 will mean there is no update (sentinel value)\r\n        l = r = nullptr;\r\n    }\r\n    void create() { // lazily create children\r\n        if(s != e) { // impt: cause dont create children if the node is already a leaf\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n    void propagate() {\r\n        if (lazy == 0) return;      // nothing happens\r\n        val += lazy * (e - s + 1);  //(e-s+1) is the length of the range\r\n        if (l==nullptr) create();\r\n        if (s != e) {               // not a leaf, send lazy tags to children\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;  // set our lazy tag value back to the sentinel\r\n    }\r\n    void update(int S, int E, ll V) {  // increment [S,E] by V\r\n        if (S == s && e == E) lazy += V;  // update covers range, update lazy tag\r\n        else { // we have to go deeper\r\n            if (l==nullptr) create();\r\n            if (E <= m) l->update(S, E, V);  //[S,E] is in the left child\r\n            else if (m < S) r->update(S, E, V);  //[S,E] is in the right child\r\n            else l->update(S, m, V), r->update(m + 1, E, V);\r\n            l->propagate(), r->propagate();\r\n            // remember to propagate your children before update yourself\r\n            val = l->val + r->val;  // update the range sum\r\n        }\r\n    }\r\n    ll query(int S, int E) {\r\n        if (l==nullptr) create();\r\n        propagate();  // remember to propagate\r\n        if (s == S && e == E) return val;  // case 1\r\n        else if (E <= m) return l->query(S, E);  // case 2, recurse to left child\r\n        else if (S >= m + 1) return r->query(S, E);  // case 3, recurse to right child\r\n        else // case 4, split the query range, recurse to both childs\r\n            return l->query(S, m) + r->query(m + 1, E);\r\n    }\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio();\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n    int n, q, op, L, R, K;\r\n    scanf(\"%d %d\", &n, &q);\r\n    node* root = new node(1, n);\r\n    for (ll i = 0; i < q; i++) {\r\n        scanf(\"%d\", &op);\r\n        if (op == 1) {\r\n            scanf(\"%d %d %d\", &L, &R, &K);\r\n            root->update(L, R, K);\r\n        } else {\r\n            scanf(\"%d %d\", &L, &R);\r\n            printf(\"%lld\\n\", root->query(L, R));\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "gghx",
        "id": 72396,
        "date": "2021-12-11 16:48:01",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node{\r\n\tll s, e, m, v, lazyadd;\r\n\tnode *l, *r;\r\n\tnode(ll _s, ll _e): s(_s), e(_e){\r\n\t\tm = (s + e) / 2;\r\n\t\tv = 0;\r\n\t\tlazyadd = 0;\r\n\t\tl = NULL;\r\n\t\tr = NULL;\r\n\t}\r\n\tvoid add(ll x, ll y, ll val) {\r\n    if (s == x && e == y) lazyadd += val;\r\n    else {\r\n      if (x > m){\r\n        if(r == NULL){\r\n        \tr = new node(m + 1, e);\r\n\t\t\t\t}\r\n\t\t\t\tr->add(x, y, val);\r\n      }\r\n      else if (y <= m){\r\n        if(l == NULL){\r\n          l = new node(s, m);\r\n\t\t\t\t}\r\n\t\t\t\tl->add(x, y, val);\r\n\t\t\t}\r\n      else{\r\n        if(l == NULL){\r\n          l = new node(s, m);\r\n\t\t\t  }\r\n\t\t\t  l->add(x, m, val);\r\n\t\t\t  if(r == NULL){\r\n          r = new node(m + 1, e);\r\n\t\t\t  }\r\n\t\t\t  r->add(m + 1, y, val);\r\n\t\t  }\r\n      if(l == NULL){\r\n        v = r->value();\r\n      }else if(r == NULL){\r\n        v = l->value();\r\n      }else{\r\n        v = l->value() + r->value();\r\n      }\r\n    }\r\n  }\r\n  ll value() {\r\n\t\tif(lazyadd == 0) return v;\r\n    if (s==e) { v+=lazyadd; lazyadd=0; return v; }\r\n    v += lazyadd * (e - s + 1);\r\n    if(r == NULL){\r\n    \tr = new node(m + 1, e);\r\n\t\t}\r\n\t\tr->lazyadd += lazyadd;\r\n\t\tif(l == NULL){\r\n\t\t\tl = new node(s, m);\r\n\t\t}\r\n\t\tl->lazyadd += lazyadd;\r\n    lazyadd = 0;\r\n    return v;\r\n\t}\r\n\tll query(ll x, ll y) {\r\n    value();\r\n    if (s==x && e==y) return v;\r\n    if (x>m){\r\n      if(r == NULL){\r\n    \t\treturn 0;\r\n\t\t\t}\r\n\t\t\treturn r->query(x, y);\r\n\t\t}\r\n    if (y<=m){\r\n      if(l == NULL){\r\n        return 0;\r\n      }\r\n      return l->query(x, y);\r\n    }\r\n    ll res = 0;\r\n    if(l == NULL) res += 0;\r\n    else res += l->query(x, m);\r\n    if(r == NULL) res += 0;\r\n    else res += r->query(m + 1, y);\r\n    return res;\r\n\t}\r\n} *root;\r\n\r\nint main(){\r\n  ios::sync_with_stdio(0);\r\n  cin.tie(0);\r\n  ll n,m;\r\n  cin>>n>>m;\r\n  root=new node(1,n);\r\n  for(int i=0;i<m;i++){\r\n    int t;\r\n    cin>>t;\r\n    if(t==1){\r\n      ll l,r,k;\r\n      cin>>l>>r>>k;\r\n      root->add(l,r,k);\r\n    }\r\n    else{\r\n      ll l,r;\r\n      cin>>l>>r;\r\n      cout<<root->query(l,r)<<\"\\n\";\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\t\r\n            \r\n"
    },
    {
        "username": "mofumofu",
        "id": 70800,
        "date": "2021-12-10 15:47:57",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\ntypedef long long int ll;\r\ntypedef pair<int,int> pii;\r\ntypedef pair<ll,ll> pll;\r\n#define mp make_pair\r\n#define pb push_back\r\n#define vi vector<int>\r\n#define si set<int>\r\n#define ff first\r\n#define ss second\r\n#define FOR(i,a,b) for(int i=(a); i<(b); i++)\r\n#define nl '\\n'\r\nll mod = 1e9+7;\r\nll inf = 1e18;\r\n\r\nstruct node{\r\n\tll s,e,m,v = 0,lazy = 0;\r\n\tnode *l, *r;\r\n\tnode(int _s, int _e){\r\n\t\ts = _s; e = _e; m = (s+e)/2;\r\n\t\tl = NULL;\r\n\t\tr = NULL;\r\n\t}\r\n\t\r\n\tvoid prop(){\r\n\t\tif(s == e){\r\n\t\t\tlazy = 0; return;\r\n\t\t}\r\n\t\tif(l == NULL) l = new node(s,m);\r\n\t\tif(r == NULL) r = new node(m+1, e);\r\n\t\tl-> up(s,e,lazy);\r\n\t\tr-> up(s,e,lazy);\r\n\t\tlazy = 0;\r\n\t}\r\n\t\r\n\tvoid up(ll x, ll y, ll z){\r\n\t\tif(x <= s && e <= y){\r\n\t\t\tlazy += z;\r\n\t\t\tv += z * (e-s+1);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tprop();\r\n\t\t\tif (x <= m) l->up(x,y,z);\r\n\t\t\tif(m < y) r->up(x,y,z);\r\n\t\t\tv = l->v + r->v;\r\n\t\t}\r\n\t}\r\n\t\r\n\tll qr(ll x, ll y){\r\n\t\tif(x <= s && e <= y) return v;\r\n\t\tprop();\r\n\t\tll sum = 0;\r\n\t\tif (x <= m) sum += l->qr(x,y);\r\n\t\tif (y > m) sum += r->qr(x,y);\r\n\t\treturn sum;\r\n\t}\r\n\t\r\n} \t*root;\r\n\r\n\r\n\r\nint main(){\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\t\r\n\r\n\tll n,q; cin >> n >> q;\r\n\troot = new node(1,n);\r\n\t\r\n\twhile(q--){\r\n\t\tint a; cin >> a;\r\n\t\tif(a==1){\r\n\t\t\tint b,c,d;\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\troot->up(b,c,d);\r\n\t\t}else{\r\n\t\t\tint b,c; cin >> b >> c;\r\n\t\t\tcout << root->qr(b,c) << nl;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "username": "hpesoj",
        "id": 70632,
        "date": "2021-12-10 10:55:34",
        "code": "#include <bits/stdc++.h>\r\n#define ll long long\r\n#define ull unsigned long long\r\n#define pb push_back\r\n#define pf push_front\r\n#define mp make_pair\r\n#define INF 1e9\r\n#define LLINF 1e18\r\n#define all(x) x.begin(), x.end()\r\n#define read(x) cin >> x\r\n#define read2(x, y) cin >> x >> y\r\n#define read3(x, y, z) cin >> x >> y >> z\r\n#define read4(x, y, z, w) cin >> x >> y >> z >> w\r\n#define print(n) cout << n\r\n#define debug(x) cout << #x << \" is \" << x << \"\\n\"\r\n#define debug2(x, y) cout << #x << \" is \" << x << \", \" << #y << \" is \" << y << \"\\n\"\r\n#define debug3(x, y, z) cout << #x << \" is \" << x << \", \" << #y << \" is \" << y << \", \" << #z << \" is \" << z << \"\\n\"\r\n#define debug4(x, y, z, w) cout << #x << \" is \" << x << \", \" << #y << \" is \" << y << \", \" << #z << \" is \" << z << \", \" << #w << \" is \" << w << \"\\n\"\r\n#define int long long\r\nusing namespace std;\r\nstruct node{\r\n    int s, e, m = (s + e) / 2, val, lazy;\r\n    node *l, *r;\r\n    node(int _s, int _e): s(_s), e(_e){\r\n        val = 0;\r\n        lazy = 0;\r\n        l = nullptr;\r\n        r = nullptr;\r\n    }\r\n    void create(){\r\n        if(s != e){\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n            //cout << \"Nodes created\\n\";\r\n        }\r\n    }\r\n    int prop(){\r\n        if(s == e){\r\n            val += lazy;\r\n            lazy = 0;\r\n            return val;\r\n        }\r\n        val += lazy * (e-s+1);\r\n        if(l == nullptr) create();\r\n        l->lazy += lazy;\r\n        r->lazy += lazy;\r\n        lazy = 0;\r\n        return val;\r\n    }\r\n    void update(int L, int R, int v){\r\n        if(L <= s and e <= R) lazy += v;\r\n        else{\r\n            if(l == nullptr) create();\r\n            if(R <= m) l->update(L, R, v);\r\n            else if(L > m) r->update(L, R, v);\r\n            else l->update(L, m, v), r->update(m+1, R, v);\r\n            val = l->prop() + r->prop();\r\n        }\r\n    }\r\n    int query(int L, int R){\r\n        prop();\r\n        if(L <= s and e <= R) return val;\r\n        else if(L > e or R < s) return 0;\r\n        else if(R <= m) return l->query(L, R);\r\n        else if(L > m) return r->query(L, R);\r\n        else return l->query(L, m) + r->query(m+1, R);\r\n    }\r\n} *root;\r\nsigned main(){\r\n    ios::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n    int n, q; read2(n, q);\r\n    root = new node(0, n-1);\r\n    while(q--){\r\n        int t; read(t);\r\n        if(t == 1){\r\n            int l, r, k; read3(l, r, k);\r\n            root->update(l-1, r-1, k);\r\n        }\r\n        else{\r\n            int l, r; read2(l, r);\r\n            cout << root->query(l-1, r-1) << \"\\n\";\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "zengminghao",
        "id": 66855,
        "date": "2021-12-06 16:22:52",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long LL;\r\n\r\nint n, q;\r\n\r\nstruct node {\r\n\tint l, r;\r\n\tLL sum = 0, tag = 0;\r\n\tnode *lc = 0, *rc = 0;\r\n\t\r\n\tnode(int L, int R) {\r\n\t\tl = L, r = R;\r\n\t}\r\n\t\r\n\tvoid extend() {\r\n\t\tif (l == r) return ;\r\n\t\tint mid = (l + r) / 2;\r\n\t\tif (lc == 0) {\r\n\t\t\tlc = new node(l, mid);\r\n\t\t\trc = new node(mid + 1, r);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid push() {\r\n\t\textend();\r\n\t\tsum += 1ll * tag * (r - l + 1);\r\n\t\tif (lc) lc->tag += tag;\r\n\t\tif (rc) rc->tag += tag;\r\n\t\ttag = 0;\r\n\t}\r\n\t\r\n\tvoid add(int L, int R, LL v) {\r\n\t\tif (l == L && r == R) {\r\n\t\t\ttag += v;\r\n\t\t\treturn ;\r\n\t\t}\r\n\t\tsum += 1ll * v * (R - L + 1);\r\n\t\tpush();\r\n\t\tint mid = (l + r) / 2;\r\n\t\tif (L <= mid) {\r\n\t\t\tlc->add(L, min(mid, R), v);\r\n\t\t}\r\n\t\tif (R >= mid + 1) {\r\n\t\t\trc->add(max(L, mid + 1), R, v);\r\n\t\t}\r\n\t}\r\n\t\r\n\tLL query(int L, int R) {\r\n\t\tpush();\r\n\t\tif (l == L && r == R) {\r\n\t\t\treturn sum;\r\n\t\t}\r\n\t\tint mid = (l + r) / 2;\r\n\t\tLL ans = 0;\r\n\t\tif (L <= mid) {\r\n\t\t\tans += lc->query(L, min(mid, R));\r\n\t\t}\r\n\t\tif (R >= mid + 1) {\r\n\t\t\tans += rc->query(max(L, mid + 1), R);\r\n\t\t}\r\n\t\treturn ans;\r\n\t}\r\n};\r\n\r\nint main() {\r\n\tscanf(\"%d %d\", &n, &q);\r\n\tnode* X = new node(1, n);\r\n\twhile (q--) {\r\n\t\tint op, l, r;\r\n\t\tscanf(\"%d %d %d\", &op, &l, &r);\r\n\t\tif (op == 1) {\r\n\t\t\tLL v;\r\n\t\t\tscanf(\"%lld\", &v);\r\n\t\t\tX->add(l, r, v);\r\n\t\t} else {\r\n\t\t\tprintf(\"%lld\\n\", X->query(l, r));\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n"
    },
    {
        "username": "Potato3218",
        "id": 65982,
        "date": "2021-12-06 10:52:47",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define beegspeed ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\r\nstruct node {\r\n    node *l, *r;\r\n    int val, lazy;\r\n    node(): val(0), l(NULL), r(NULL), lazy(0){}\r\n    int value(int s, int e){\r\n        val += (e-s+1) * lazy;\r\n        if (s==e){\r\n            lazy = 0;\r\n            return val;\r\n        }\r\n        if (l == NULL) l = new node();\r\n        l->lazy += lazy;\r\n        if (r == NULL) r = new node();\r\n        r->lazy += lazy;\r\n        lazy = 0;\r\n        return val;\r\n    }\r\n    void update(int s, int e, int x, int y, int v) {\r\n        int m = (s + e) / 2;\r\n        if (s==x && e==y){\r\n           lazy += v;\r\n           return;\r\n        }\r\n        if (y <= m){\r\n            if (l == NULL) l = new node();\r\n            l->update(s, m, x, y, v);\r\n        } else if (x > m){\r\n            if (r == NULL) r = new node();\r\n            r->update(m+1, e, x, y, v);\r\n        } else {\r\n            if (l==NULL) l = new node();\r\n            if (r==NULL) r = new node();\r\n            l->update(s, m, x, m, v);\r\n            r->update(m+1, e, m+1, y, v);\r\n        }\r\n        val = (l==NULL?0:l->value(s, m)) + (r==NULL?0:r->value(m+1, e));\r\n    }\r\n    int query(int s, int e, int x, int y) {\r\n        value(s, e);\r\n        if (s == x && e == y) return val;\r\n        int m = (s + e) / 2;\r\n        if (x > m) return (r==NULL)? 0:r->query(m + 1, e, x, y);\r\n        if (y <= m) return (l==NULL)? 0:l->query(s, m, x, y);\r\n        if (l == NULL && r != NULL) return r->query(m+1, e, m+1, y);\r\n        if (l != NULL && r == NULL) return l->query(s, m, x, m);\r\n        if (l != NULL && r != NULL) return l->query(s, m, x, m) + r->query(m+1, e, m+1, y); //Change here for max\r\n        return 0;\r\n    }\r\n} *root;\r\nint32_t main(){\r\n\tbeegspeed\r\n    int n, q; cin >> n >> q;\r\n    root = new node();\r\n    for(int sss = 0; sss<q; sss++){\r\n        int t; cin >> t;\r\n        if (t == 1){\r\n            int a, b, c; cin >> a >> b >> c;\r\n            root->update(1, n, a, b, c);\r\n        } else {\r\n            int a, b; cin >> a >> b;\r\n            cout << root->query(1, n, a, b) << '\\n';\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "hi",
        "id": 62870,
        "date": "2021-12-02 11:10:56",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define ll long long\r\n\r\nstruct node{\r\n\tll s, e, m, val, lazy;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\t\r\n\tnode(ll S, ll E){\r\n\t\ts = S;\r\n\t\te = E;\r\n\t\tval = 0;\r\n\t\tlazy = 0;\r\n\t\tm = (s+e)/2;\r\n\t}\r\n\t\r\n\tvoid create(){\r\n\t\tif(s != e){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tvoid propagate(){\r\n\t\tif(l == nullptr) create();\r\n\t\tif(lazy == 0) return;\r\n\t\tval += (e-s+1) * lazy;\r\n\t\tif(s != e){\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tvoid update(ll S, ll E, ll V){\r\n\t\tpropagate();\r\n\t\tif(s > E || e < S) return;\r\n\t\tif(s >= S && e <= E){\r\n\t\t\tlazy = V;\r\n\t\t\tpropagate();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tl->update(S, E, V);\r\n\t\tr->update(S, E, V);\r\n\t\tval = l->val + r->val;\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tll query(ll S, ll E){\r\n\t\tif(s > E || e < S) return 0;\r\n\t\tpropagate();\r\n\t\tif(s >= S && e <= E) return val;\r\n\t\treturn l->query(S, E) + r->query(S, E);\r\n\t}\r\n} *root;\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tll n, q, op, size=1, tmp, a, b, c;\r\n\tcin>>n>>q;\r\n\ttmp = n-1;\r\n\twhile(tmp){\r\n\t\ttmp >>= 1;\r\n\t\tsize *= 2;\r\n\t}\r\n\troot = new node(1, size);\r\n\tfor(ll i=0; i<q; i++){\r\n\t\tcin>>op;\r\n\t\tif(op == 1){\r\n\t\t\tcin>>a>>b>>c;\r\n\t\t\troot->update(a, b, c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>a>>b;\r\n\t\t\tcout<<root->query(a, b)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}"
    },
    {
        "username": "penguin133",
        "id": 57972,
        "date": "2021-11-27 10:38:35",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n\tint s,e,m, val = 0, lazy = 0;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\tnode(int _s, int _e){\r\n\t\ts = _s, e = _e;\r\n\t\tm = s + (e-s)/2;\r\n\t}\r\n\tvoid mc(){\r\n\t\tif(l == nullptr){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\tvoid propo(){\r\n\t\tif(lazy == 0)return;\r\n\t\tval += lazy*(e-s+1);\r\n\t\tif(s != e){\r\n\t\t\tmc();\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy =0;\r\n\t}\r\n\tvoid update(int a, int b, int c){\r\n\t\tif(a == s && b == e)lazy += c;\r\n\t\telse{\r\n\t\t\tmc();\r\n\t\t\tif(b <= m)l->update(a,b,c);\r\n\t\t\telse if(a > m)r->update(a,b,c);\r\n\t\t\telse l->update(a,m,c), r->update(m+1,b,c);\r\n\t\t\tl->propo(), r->propo();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\tint query(int a,int b){\r\n\t\tpropo();\r\n\t\tif(a == s && b == e)return val;\r\n\t\telse{\r\n\t\t\tmc();\r\n\t\t\tif(b <= m)return l->query(a,b);\r\n\t\t\telse if(a > m)return r->query(a,b);\r\n\t\t\telse return l->query(a,m) + r->query(m+1,b);\r\n\t\t}\r\n\t}\r\n}*root  =new node(0, 1e9 + 100);\r\n\r\nmain(){\r\n\tios::sync_with_stdio(0);cin.tie(0);\r\n\tint n,q;\r\n\tcin >> n >> q;\r\n\twhile(q--){\r\n\t\tint a,b,c,d;\r\n\t\tcin >> a;\r\n\t\tif(!--a){\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << root->query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "penguin133",
        "id": 57685,
        "date": "2021-11-26 15:48:59",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n\tint s,e,m, val = 0, lazy = 0;\r\n\tnode *l = NULL, *r = NULL;\r\n\tnode(int _s, int _e){\r\n\t\ts = _s, e = _e;\r\n\t\tm = s + (e-s)/2;\r\n\t}\r\n\tvoid mc(){\r\n\t\tif(l == NULL){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\tvoid propo(){\r\n\t\tif(lazy == 0)return;\r\n\t\tval += lazy*(e-s+1);\r\n\t\tif(s != e){\r\n\t\t\tmc();\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy =0;\r\n\t}\r\n\tvoid update(int a, int b, int c){\r\n\t\tif(a == s && b == e)lazy += c;\r\n\t\telse{\r\n\t\t\tmc();\r\n\t\t\tif(b <= m)l->update(a,b,c);\r\n\t\t\telse if(a > m)r->update(a,b,c);\r\n\t\t\telse l->update(a,m,c), r->update(m+1,b,c);\r\n\t\t\tl->propo(), r->propo();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\tint query(int a,int b){\r\n\t\tpropo();\r\n\t\tif(a == s && b == e)return val;\r\n\t\telse{\r\n\t\t\tmc();\r\n\t\t\tif(b <= m)return l->query(a,b);\r\n\t\t\telse if(a > m)return r->query(a,b);\r\n\t\t\telse return l->query(a,m) + r->query(m+1,b);\r\n\t\t}\r\n\t}\r\n}*root  =new node(0, 1e9 + 100);\r\n\r\nmain(){\r\n\tios::sync_with_stdio(0);cin.tie(0);\r\n\tint n,q;\r\n\tcin >> n >> q;\r\n\twhile(q--){\r\n\t\tint a,b,c,d;\r\n\t\tcin >> a;\r\n\t\tif(!--a){\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << root->query(b,c) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "zyq69",
        "id": 57678,
        "date": "2021-11-26 15:22:33",
        "code": "#include <iostream>\r\nusing namespace std;\r\n\r\nint N, Q;\r\n\r\nstruct node{\r\n\tint S, E, M;\r\n\tlong long ladd, v;\r\n\tnode *l, *r;\r\n\tnode (int _S, int _E) {\r\n\t\tS = _S; E = _E;\r\n\t\tM = S + (E - S) / 2;\r\n\t\tl = r = NULL;\r\n\t\tladd = v = 0;\r\n\t}\r\n\tvoid update (int qs, int qe, long long qv){\r\n\t\tif(qs <= S && qe >= E){\r\n\t\t\tv += qv*(E-S+1);\r\n\t\t\tladd += qv;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(!l) l = new node(S, M);\r\n\t\tif(!r) r = new node(M+1, E);\r\n\t\tif(ladd){\r\n\t\t\tl->ladd += ladd;\r\n\t\t\tr->ladd += ladd;\r\n\t\t\tl->v += ladd *(M-S+1);\r\n\t\t\tr->v += ladd * (E-M);\r\n\t\t\tladd = 0;\r\n\t\t}\r\n\t\tif(qe <= M) l->update(qs, qe, qv);\r\n\t\telse if(qs >= M+1) r->update(qs, qe, qv);\r\n\t\telse{\r\n\t\t\tl->update(qs, M, qv);\r\n\t\t\tr->update(M+1, qe, qv);\r\n\t\t}\r\n\t\tv = l->v + r->v;\r\n\t}\r\n\tlong long query(int qs, int qe){\r\n\t\tif(qs <= S && E <= qe){\r\n\t\t\treturn v;\r\n\t\t}\r\n\t\tif(!l) l = new node(S, M);\r\n\t\tif(!r) r = new node(M+1, E);\r\n\t\tif(ladd){\r\n\t\t\tl->ladd += ladd;\r\n\t\t\tr->ladd += ladd;\r\n\t\t\tl->v += ladd *(M-S+1);\r\n\t\t\tr->v += ladd * (E-M);\r\n\t\t\tladd = 0;\r\n\t\t}\r\n\t\tif(qe <= M) return l->query(qs, qe);\r\n\t\tif(qs >= M+1) return r->query(qs, qe);\r\n\t\treturn l->query(qs, M) + r->query(M+1, qe);\r\n\t}\r\n}*root;\r\n\r\nint main() {\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tcin >> N >> Q;\r\n\troot = new node(1, N);\r\n\twhile (Q--) {\r\n\t\tint op, l, r, k;\r\n\t\tcin >> op >> l >> r;\r\n\t\tif (op == 1) {\r\n\t\t\tcin >> k;\r\n\t\t\troot->update(l, r, k);\r\n\t\t} else {\r\n\t\t\tcout << root->query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}"
    },
    {
        "username": "zhougz",
        "id": 57175,
        "date": "2021-11-25 12:00:22",
        "code": "/**\r\n *    author: zhougz\r\n *    created: 25/11/2021 11:27:17\r\n**/\r\n#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nstruct node {\r\n\tint tl, tr;\r\n\tlong long val = 0, lazy = 0;\r\n\tnode *ll, *rr;\r\n\tnode(int tll, int trr) {\r\n\t\ttl = tll;\r\n\t\ttr = trr;\r\n\t}\r\n\tvoid create() {\r\n\t\tint tm = (tl + tr) / 2;\r\n\t\tll = new node(tl, tm);\r\n\t\trr = new node(tm + 1, tr);\r\n\t}\r\n\tvoid push() {\r\n\t\tll->val += (long long)(ll->tr - ll->tl + 1) * lazy;\r\n\t\trr->val += (long long)(rr->tr - rr->tl + 1) * lazy;\r\n\t\tll->lazy += lazy;\r\n\t\trr->lazy += lazy;\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid update(int l, int r, int v) {\r\n\t\tif (tr < l || r < tl) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (l <= tl && tr <= r) {\r\n\t\t\tval += (long long)(tr - tl + 1) * v;\r\n\t\t\tlazy += v;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (ll == nullptr) {\r\n\t\t\tcreate();\r\n\t\t}\r\n\t\tpush();\r\n\t\tll->update(l, r, v);\r\n\t\trr->update(l, r, v);\r\n\t\tval = ll->val + rr->val;\r\n\t\t//cerr << l << ' ' << r << ' ' << tl << ' ' << tr << ' ' << val << endl;\r\n\t}\r\n\tlong long query(int l, int r) {\r\n\t\tif (tr < l || r < tl) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (l <= tl && tr <= r) {\r\n\t\t\treturn val;\r\n\t\t}\r\n\t\tif (ll == nullptr) {\r\n\t\t\tcreate();\r\n\t\t}\r\n\t\tpush();\r\n\t\treturn ll->query(l, r) + rr->query(l, r);\r\n\t}\r\n} *root;\r\n\r\nint main()\r\n{\r\n\tios::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n\tint n, q;\r\n\tcin >> n >> q;\r\n\troot = new node(1, n);\r\n\tfor (int i = 0, t, l, r, k; i < q; i++) {\r\n\t\tcin >> t >> l >> r;\r\n\t\tif (t == 1) {\r\n\t\t\tcin >> k;\r\n\t\t\troot->update(l, r, k);\r\n\t\t} else {\r\n\t\t\tcout << root->query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n"
    },
    {
        "username": "ldminh4354",
        "id": 56949,
        "date": "2021-11-24 18:03:32",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n#define fi first\r\n#define se second\r\n#define pb push_back\r\n\r\nstruct node\r\n{\r\n\tint s,e,m,val,lazy;\r\n\tnode *l,*r;\r\n\t\r\n\tnode(int S,int E)\r\n\t{\r\n\t\ts=S;e=E;m=(s+e)/2;\r\n\t\tval=0;lazy=0;l=nullptr;r=nullptr;\r\n\t}\r\n\t\r\n\tvoid create()\r\n\t{\r\n\t\tif (s!=e)\r\n\t\t{\r\n\t\t\tl=new node(s,m);\r\n\t\t\tr=new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid propogate()\r\n\t{\r\n\t\tif (lazy==0) return;\r\n\t\t\r\n\t\tval=val+lazy*(e-s+1);\r\n\t\tif (s!=e)\r\n\t\t{\r\n\t\t\tif (l==nullptr) create();\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\t\r\n\tvoid update(int S,int E,int V)\r\n\t{\r\n\t\tif (l==nullptr) create();\r\n\t\t\r\n\t\tif (s==S and e==E) lazy+=V;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (E<=m) l->update(S,E,V);\r\n\t\t\telse if (S>=m+1) r->update(S,E,V);\r\n\t\t\telse l->update(S,m,V),r->update(m+1,E,V);\r\n\t\t\t\r\n\t\t\tl->propogate();r->propogate();\r\n\t\t\tval=l->val+r->val;\r\n\t\t}\r\n\t}\r\n\t\r\n\tint query(int S,int E)\r\n\t{\r\n\t\tif (l==nullptr) create();\r\n\t\t\r\n\t\tpropogate();\r\n\t\tif (s==S and e==E) return val;\r\n\t\telse if (E<=m) return l->query(S,E);\r\n\t\telse if (S>=m+1) return r->query(S,E);\r\n\t\telse return l->query(S,m)+r->query(m+1,E);\r\n\t}\r\n}*root;\r\n\r\nsigned main()\r\n{\r\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\r\n\tint n,q,t,a,b,c;\r\n\tcin>>n>>q;\r\n\troot=new node(1,n);\r\n\tfor (int i=1;i<q+1;i++)\r\n\t{\r\n\t\tcin>>t;\r\n\t\tif (t==1)\r\n\t\t{\r\n\t\t\tcin>>a>>b>>c;\r\n\t\t\troot->update(a,b,c);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcin>>a>>b;\r\n\t\t\tcout<<root->query(a,b)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "TheRaptor",
        "id": 56800,
        "date": "2021-11-24 12:22:18",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nstruct node{\r\n    int s, e, m;\r\n    long long val; \r\n    long long lazy; \r\n    node *l, *r; \r\n    node (int S, int E){ \r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0; \r\n        lazy = 0; \r\n\r\n    }\r\n    void create(){\r\n        if(s != e){ \r\n            l = new node(s, m); \r\n            r = new node(m+1, e); \r\n        }\r\n    }\r\n    void propogate(){\r\n        if (lazy==0) return; \r\n        val+=lazy*(e-s+1); \r\n        if (s != e){ \r\n            if(l==nullptr) create();\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0; \r\n    }\r\n    void update(int S, int E, long long V){ \r\n        if(s==S && e==E) lazy += V; \r\n        else{ //go we have to go deeper\r\n            if(l==nullptr) create();\r\n            if(E <= m) l->update(S, E, V); //[S,E] is in the left child\r\n            else if (m < S) r->update(S, E, V); //[S,E] is in the right child\r\n            else l->update(S, m, V),r->update(m+1, E, V);\r\n            l->propogate(),r->propogate();\r\n//remember to propogate your children before update yourself\r\n            val = l->val + r->val; //update the range sum\r\n        }\r\n    }\r\n    long long query(int S, int E){\r\n        propogate(); //remember to propogate\r\n        if(l==nullptr) create();\r\n        if(s == S && e == E) return val; //case 1\r\n        else if(E <= m) return l->query(S, E); //case 2, recurse to left child\r\n        else if(S >= m+1) return r->query(S, E); //case 3, recurse to right child\r\n        else return l->query(S, m) + r->query(m+1, E); //case 4, split the query range,recurse to both childs\r\n    }\r\n} *root;\r\nint main() {\r\n    int n,m;\r\n    cin >> n >> m;\r\n    root=new node(1,n);\r\n    for(int i=0; i<m; i++){\r\n        int a,b,c,d;\r\n        cin >> a >> b >> c;\r\n        if(a==1){\r\n            cin >> d;\r\n            root->update(b,c,d);\r\n        }\r\n        else{\r\n            cout << root->query(b,c) << \"\\n\";\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "Popsicled",
        "id": 54869,
        "date": "2021-11-22 11:20:04",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\nint n, q;\r\n\r\nstruct node{\r\n    int s, e, m; //range is [s,e], m is the middle point\r\n    int val; //sum of [s,e]\r\n    int lazy; //lazy tag of [s,e]\r\n    node *l, *r; //create two children l and r, where l is [s,m] and [m+1,e]\r\n\r\n    node (int S, int E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        l = r = nullptr;\r\n        lazy = 0;\r\n        //do not create children l and r right now\r\n    }\r\n\r\n    void create() { ///lazily create children\r\n        if(s != e && l == nullptr){ ///impt: cause dont create children if the node is already a leaf\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n\r\n    void propogate() {\r\n        create();\r\n        if (lazy == 0) return; //nothing happens\r\n        val += lazy*(e-s+1); //(e-s+1) is the length of the range\r\n        if (s != e) { //not a leaf, send lazy tags to children\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0; //set our lazy tag value back to the sentinel\r\n    }\r\n\r\n    void update(int S, int E, int V) { //increment [S,E] by V\r\n        create();\r\n        if(s==S && e==E) lazy += V; //update covers range, update lazy tag\r\n        else { //go we have to go deeper\r\n            if (E <= m) l->update(S, E, V); //[S,E] is in the left child\r\n            else if (m < S) r->update(S, E, V); //[S,E] is in the right child\r\n            else l->update(S, m, V), r->update(m+1, E, V);\r\n            l->propogate(), r->propogate();\r\n            //remember to propogate your children before update yourself\r\n            val = l->val + r->val; //update the range sum\r\n        }\r\n    }\r\n\r\n    int query(int S, int E){\r\n        propogate(); //remember to propogate\r\n        if(s == S && e == E) return val; //case 1\r\n        else if(E <= m) return l->query(S, E); //case 2, recurse to left child\r\n        else if(S >= m+1) return r->query(S, E); //case 3, recurse to right child\r\n        else return l->query(S, m) + r->query(m+1, E); //case 4, split the query range, recurse to both childs\r\n    }\r\n\r\n}*root;\r\n\r\n\r\nmain() {\r\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\r\n\tcin >> n >> q;\r\n    root = new node(1,n);\r\n    for (int i = 0; i < q; i++) {\r\n        int type; cin >> type;\r\n        if (type == 1) {\r\n            int l, r, k; cin >> l >> r >> k;\r\n            root->update(l, r, k);\r\n        } else {\r\n            int l, r; cin >> l >> r;\r\n            cout << root->query(l, r) << '\\n';\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "wangy412",
        "id": 53442,
        "date": "2021-11-18 22:33:34",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\nint n, q;\r\n\r\nstruct node {\r\n    int s, e, m, v, lazy;\r\n    node *l, *r;\r\n\r\n    node(int _s, int _e) {\r\n        s    = _s;\r\n        e    = _e;\r\n        m    = (s + e) / 2;\r\n        v    = 0;\r\n        lazy = 0;\r\n        l = r = nullptr;\r\n    }\r\n\r\n    void create_children() {\r\n        if (l || s == e) return;\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n    }\r\n\r\n    void propogate() {\r\n        if (!lazy) return;\r\n\r\n        create_children();\r\n\r\n        v += lazy * (e - s + 1);\r\n\r\n        if (s != e) {\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n\r\n        lazy = 0;\r\n    }\r\n\r\n    void update(int _s, int _e, int k) {\r\n        if (_s == s && _e == e) lazy += k;\r\n        else {\r\n            create_children();\r\n\r\n            if (_e <= m) l->update(_s, _e, k);\r\n            else if (_s > m)\r\n                r->update(_s, _e, k);\r\n            else\r\n                l->update(_s, m, k), r->update(m + 1, _e, k);\r\n\r\n            l->propogate();\r\n            r->propogate();\r\n            v = l->v + r->v;\r\n        }\r\n    }\r\n\r\n    int query(int _s, int _e) {\r\n        propogate();\r\n\r\n        if (s == _s && e == _e) return v;\r\n        else if (_e <= m) {\r\n            create_children();\r\n            return l->query(_s, _e);\r\n        } else if (_s > m) {\r\n            create_children();\r\n            return r->query(_s, _e);\r\n        }\r\n\r\n        create_children();\r\n        return l->query(_s, m) + r->query(m + 1, _e);\r\n    }\r\n\r\n} * root;\r\n\r\nint32_t main() {\r\n    cin >> n >> q;\r\n\r\n    root = new node(0, n);\r\n\r\n    for (int i = 0; i < q; i++) {\r\n        int x, l, r, k;\r\n        cin >> x >> l >> r;\r\n        if (x == 1) {\r\n            cin >> k;\r\n            root->update(l, r, k);\r\n        } else {\r\n            cout << root->query(l, r) << '\\n';\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "reporter",
        "id": 53441,
        "date": "2021-11-18 22:32:52",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\nint n, q;\r\n\r\nstruct node {\r\n    int s, e, m, v, lazy;\r\n    node *l, *r;\r\n\r\n    node(int _s, int _e) {\r\n        s    = _s;\r\n        e    = _e;\r\n        m    = (s + e) / 2;\r\n        v    = 0;\r\n        lazy = 0;\r\n        l = r = nullptr;\r\n    }\r\n\r\n    void create_children() {\r\n        if (l || s == e) return;\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n    }\r\n\r\n    void propogate() {\r\n        if (!lazy) return;\r\n\r\n        create_children();\r\n\r\n        v += lazy * (e - s + 1);\r\n\r\n        if (s != e) {\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n\r\n        lazy = 0;\r\n    }\r\n\r\n    void update(int _s, int _e, int k) {\r\n        create_children();\r\n\r\n        if (_s == s && _e == e) lazy += k;\r\n        else {\r\n            if (_e <= m) l->update(_s, _e, k);\r\n            else if (_s > m)\r\n                r->update(_s, _e, k);\r\n            else\r\n                l->update(_s, m, k), r->update(m + 1, _e, k);\r\n\r\n            l->propogate();\r\n            r->propogate();\r\n            v = l->v + r->v;\r\n        }\r\n    }\r\n\r\n    int query(int _s, int _e) {\r\n        create_children();\r\n        propogate();\r\n\r\n        if (s == _s && e == _e) return v;\r\n        else if (_e <= m)\r\n            return l->query(_s, _e);\r\n        else if (_s > m)\r\n            return r->query(_s, _e);\r\n\r\n        return l->query(_s, m) + r->query(m + 1, _e);\r\n    }\r\n\r\n} * root;\r\n\r\nint32_t main() {\r\n    cin >> n >> q;\r\n\r\n    root = new node(0, n);\r\n\r\n    for (int i = 0; i < q; i++) {\r\n        int x, l, r, k;\r\n        cin >> x >> l >> r;\r\n        if (x == 1) {\r\n            cin >> k;\r\n            root->update(l, r, k);\r\n        } else {\r\n            cout << root->query(l, r) << '\\n';\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}"
    },
    {
        "username": "errorgorn",
        "id": 44375,
        "date": "2021-11-04 10:59:01",
        "code": "\r\n"
    },
    {
        "username": "Damian",
        "id": 38681,
        "date": "2021-08-08 16:35:24",
        "code": " #include <iostream>\r\nusing namespace std;\r\n\r\nint N, Q;\r\n\r\nstruct node {\r\n\tint S, E, M;\r\n\tnode *l, *r;\r\n\tint64_t ladd, v;\r\n\tnode(int _S, int _E) {\r\n\t\tS = _S; E = _E;\r\n\t\tM = S + (E - S) / 2;\r\n\t\tl = r = NULL;\r\n\t\tladd = v = 0;\r\n\t}\r\n\tvoid update(int qs, int qe, int64_t qv) {\r\n\t\tif (qs <= S && E <= qe) {\r\n\t\t\tv += qv * (E - S + 1);\r\n\t\t\tladd += qv;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!l) l = new node(S, M);\r\n\t\tif (!r) r = new node(M + 1, E);\r\n\t\tif (ladd) {\r\n\t\t\tl->ladd += ladd;\r\n\t\t\tr->ladd += ladd;\r\n\t\t\tl->v += ladd * (M - S + 1);\r\n\t\t\tr->v += ladd * (E - M);\r\n\t\t\tladd = 0;\r\n\t\t}\r\n\t\tif (qe <= M) l->update(qs, qe, qv);\r\n\t\telse if (qs > M) r->update(qs, qe, qv);\r\n\t\telse {\r\n\t\t\tl->update(qs, M, qv);\r\n\t\t\tr->update(M + 1, qe, qv);\r\n\t\t}\r\n\t\tv = l->v + r->v;\r\n\t}\r\n\tint64_t query(int qs, int qe) {\r\n\t\tif (qs <= S && E <= qe) {\r\n\t\t\treturn v;\r\n\t\t}\r\n\t\tif (!l) l = new node(S, M);\r\n\t\tif (!r) r = new node(M + 1, E);\r\n\t\tif (ladd) {\r\n\t\t\tl->ladd += ladd;\r\n\t\t\tr->ladd += ladd;\r\n\t\t\tl->v += ladd * (M - S + 1);\r\n\t\t\tr->v += ladd * (E - M);\r\n\t\t\tladd = 0;\r\n\t\t}\r\n\t\tif (qe <= M) return l->query(qs, qe);\r\n\t\tif (qs > M) return r->query(qs, qe);\r\n\t\treturn l->query(qs, M) + r->query(M + 1, qe);\r\n\t}\r\n} *root;\r\n\r\nint main() {\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tcin >> N >> Q;\r\n\troot = new node(1, N);\r\n\twhile (Q--) {\r\n\t\tint op, l, r, k;\r\n\t\tcin >> op >> l >> r;\r\n\t\tif (op == 1) {\r\n\t\t\tcin >> k;\r\n\t\t\troot->update(l, r, k);\r\n\t\t} else {\r\n\t\t\tcout << root->query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n} "
    },
    {
        "username": "hmm",
        "id": 37997,
        "date": "2021-07-15 13:23:25",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node {\r\n\tlong long s, e, m, v, lz;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\tnode(long long _s, long long _e) {\r\n\t\ts = _s;\r\n\t\te = _e;\r\n\t\tm = (s+e)/2;\r\n\t\tv = 0;\r\n\t\tlz = 0;\r\n\t}\r\n\tvoid create() {\r\n\t\tif(s != e) {\r\n//\t\t\tcout << \"i \" << endl;\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n//\t\t\tcout << \"j \" << endl;\r\n\t\t}\r\n\t}\r\n\tlong long value() {\r\n//\t\tcout << \"e \" << endl;\r\n\t\tif(l == nullptr) {\r\n//\t\t\tcout << \"k \" << endl;\r\n\t\t\tcreate();\r\n\t\t}\r\n//\t\tcout << \"f \" << endl;\r\n\t\tv += (e-s+1) * lz;\r\n//\t\tcout << \"g \" << endl;\r\n\t\tif(s != e) {\r\n\t\t\tl->lz += lz;\r\n\t\t\tr->lz += lz;\r\n\t\t}\r\n//\t\tcout << \"h \" << endl;\r\n\t\tlz = 0;\r\n\t\treturn v;\r\n\t}\r\n\tvoid update(long long x, long long y, long long nv) {\r\n//\t\tcout << \"a \" << x << \" \" << y << \" \" << nv << endl;\r\n\t\tif(s == x && e == y) {\r\n//\t\t\tcout << \"b \" << endl;\r\n\t\t\tlz += nv;\r\n\t\t} else {\r\n//\t\t\tcout << \"c \" << endl;\r\n\t\t\tvalue();\r\n//\t\t\tcout << \"d \" << endl;\r\n\t\t\tif(x > m) {\r\n\t\t\t\tr->update(x, y, nv);\r\n\t\t\t} else if(y <= m) {\r\n\t\t\t\tl->update(x, y, nv);\r\n\t\t\t} else {\r\n\t\t\t\tl->update(x, m, nv);\r\n\t\t\t\tr->update(m+1, y, nv);\r\n\t\t\t}\r\n\t\t\tv = l->value() + r->value();\r\n\t\t}\r\n\t}\r\n\tlong long sum(long long x, long long y) {\r\n\t\tvalue();\r\n\t\tif(s == x && e == y) {\r\n\t\t\treturn v;\r\n\t\t} else if(x > m) {\r\n\t\t\treturn r->sum(x, y);\r\n\t\t} else if(y <= m) {\r\n\t\t\treturn l->sum(x, y);\r\n\t\t} else {\r\n\t\t\treturn l->sum(x, m) + r->sum(m+1, y);\r\n\t\t}\r\n\t}\r\n} *root;\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0); cout.tie(0);\r\n\tlong long n, q, a, b, c, d;\r\n\tcin >> n >> q;\r\n\troot = new node(1, n);\r\n\twhile(q--) {\r\n\t\tcin >> a;\r\n\t\tif(a == 1) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\troot->update(b, c, d);\r\n\t\t} else if(a == 2) {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << root->sum(b, c) << '\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "iamnumber4",
        "id": 37996,
        "date": "2021-07-15 13:11:10",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node * l, * r;\r\n    node(int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0),\r\n        mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n            if (A == NULL) return;\r\n            if (s == e) mn = mx = sum = A[s];\r\n            else {\r\n            l = new node(s, (s + e) >> 1, A), r = new node((s + e + 2) >> 1, e, A);\r\n                combine();\r\n            }\r\n        }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s + e) >> 1;\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e - s + 1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) {\r\n            self_set(v + set_val);\r\n            return;\r\n        }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v * (e - s + 1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l -> self_set(set_val), r -> self_set(set_val);\r\n            lset = set_val = 0;\r\n        }\r\n        if (add_val != 0) {\r\n            l -> self_add(add_val), r -> self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l -> sum + r -> sum;\r\n        mn = min(l -> mn, r -> mn);\r\n        mx = max(l -> mx, r -> mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) {\r\n            self_add(v);\r\n            return;\r\n        }\r\n        int m = (s + e) >> 1;\r\n        create_children();\r\n        lazy_propagate();\r\n        if (x <= m) l -> add(x, min(y, m), v);\r\n        if (y > m) r -> add(max(x, m + 1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) {\r\n            self_set(v);\r\n            return;\r\n        }\r\n        int m = (s + e) >> 1;\r\n        create_children();\r\n        lazy_propagate();\r\n        if (x <= m) l -> set(x, min(y, m), v);\r\n        if (y > m) r -> set(max(x, m + 1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e - s + 1)) * (y - x + 1);\r\n        int m = (s + e) >> 1;\r\n        lazy_propagate();\r\n        if (y <= m) return l -> range_sum(x, y);\r\n        if (x > m) return r -> range_sum(x, y);\r\n        return l -> range_sum(x, m) + r -> range_sum(m + 1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s + e) >> 1;\r\n        lazy_propagate();\r\n        if (y <= m) return l -> range_min(x, y);\r\n        if (x > m) return r -> range_min(x, y);\r\n        return min(l -> range_min(x, m), r -> range_min(m + 1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s + e) >> 1;\r\n        lazy_propagate();\r\n        if (y <= m) return l -> range_max(x, y);\r\n        if (x > m) return r -> range_max(x, y);\r\n        return max(l -> range_max(x, m), r -> range_max(m + 1, y));\r\n    }~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n}* root;\r\nint main() {\r\n    ios_base::sync_with_stdio(0);\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n    long long n, q, a, b, c, d;\r\n    cin >> n >> q;\r\n    root = new node(1, n);\r\n    for(int i = 0; i < q; i++) {\r\n        cin >> a;\r\n        if(a == 1) {\r\n            cin >> b >> c >> d;\r\n            root->add(b, c, d);\r\n        } else if(a == 2) {\r\n            cin >> b >> c;\r\n            cout << root->range_sum(b, c) << '\\n';\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "kai824",
        "id": 37264,
        "date": "2021-06-21 21:19:23",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define eb emplace_back\r\n#define mp make_pair\r\ntypedef pair<int,int> pii;\r\n#define f first\r\n#define s second\r\n\r\n#ifdef local\r\n#define debug(x) cerr<<\"Line \"<<__LINE__<<\": \"<<#x<<\"=\"<<x<<'\\n';\r\nbool deb=true;\r\n#else\r\n#define debug(x);\r\nbool deb=false;//for in-code checking\r\n#endif\r\n\r\n#define min(a,b) ((a<b)?a:b)\r\n#define max(a,b) ((a>b)?a:b)\r\n#define lbd lower_bound\r\n#define upb upper_bound\r\n\r\n//const int mod=1000000007 or 998244353;\r\n\r\nstruct node{//range sum...\r\n  int s,e,v,lz=0;\r\n  node *l,*r;\r\n  node(int ss,int ee){\r\n    s=ss;e=ee;\r\n    v=0;\r\n    l=r=NULL;\r\n  }\r\n  void prop(){\r\n    if(s<e){\r\n      if(!l)l=new node(s,(s+e)/2);\r\n      if(!r)r=new node((s+e)/2+1,e);\r\n      l->add(s,e,lz);\r\n      r->add(s,e,lz);\r\n      lz=0;\r\n    }\r\n  }\r\n  void add(int a,int b,int c){\r\n    if(a<=s && e<=b){\r\n      lz+=c;\r\n      v+=(e-s+1)*c;\r\n      return;\r\n    }\r\n    prop();\r\n    if(a<=(s+e)/2)l->add(a,b,c);\r\n    if((s+e)/2<b)r->add(a,b,c);\r\n    v=l->v+r->v;\r\n  }\r\n  int query(int a,int b){\r\n    if(a<=s && e<=b)return v;\r\n    prop();\r\n    int ans=0;\r\n    if(a<=(s+e)/2)ans=l->query(a,b);\r\n    if((s+e)/2<b)ans+=r->query(a,b);\r\n    return ans;\r\n  }\r\n} *root;\r\n\r\nint32_t main(){\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  int n,q;\r\n  cin>>n>>q;\r\n  root=new node(0,n);\r\n  while(q--){\r\n    int a,b,c;\r\n    cin>>a;\r\n    if(a==1){\r\n      cin>>a>>b>>c;\r\n      root->add(a,b,c);\r\n    }else{\r\n      cin>>a>>b;\r\n      cout<<root->query(a,b)<<'\\n';\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n/*\r\n\r\n*/\r\n"
    },
    {
        "username": "kai824",
        "id": 34438,
        "date": "2021-05-22 10:26:19",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node{\r\n  int s,e,v,lz;\r\n  node *l,*r;\r\n  node(int ss,int ee){\r\n    s=ss;e=ee;\r\n    v=lz=0;\r\n  }\r\n  void prop(){\r\n    if(s==e){lz=0;return;}\r\n    if(l==NULL)l=new node(s,(s+e)/2);\r\n    if(r==NULL)r=new node((s+e)/2+1,e);\r\n    l->add(s,e,lz);\r\n    r->add(s,e,lz);\r\n    lz=0;\r\n  }\r\n  void add(int a,int b,int c){\r\n    if(a<=s && e<=b){\r\n      v+=(e-s+1)*c;\r\n      lz+=c;\r\n      return;\r\n    }\r\n    prop();\r\n    if(a<=(s+e)/2)l->add(a,b,c);\r\n    if((s+e)/2<b)r->add(a,b,c);\r\n    v=l->v+r->v;\r\n  }\r\n  int query(int a,int b){\r\n    if(a<=s && e<=b)return v;\r\n    prop();\r\n    return (a<=(s+e)/2?l->query(a,b):0) + ((s+e)/2<b?r->query(a,b):0);\r\n  }\r\n} *root;\r\n\r\nint32_t main(){\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  int n,q;\r\n  cin>>n>>q;\r\n  root=new node(0,n);\r\n  while(q--){\r\n    int a,b,c;\r\n    cin>>a;\r\n    if(a==1){\r\n      cin>>a>>b>>c;\r\n      root->add(a,b,c);\r\n    }else{\r\n      cin>>a>>b;\r\n      cout<<root->query(a,b)<<'\\n';\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n"
    },
    {
        "username": "kai824",
        "id": 34369,
        "date": "2021-05-21 14:14:38",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define eb emplace_back\r\n#define mp make_pair\r\ntypedef pair<int,int> pii;\r\n#define f first\r\n#define s second\r\n\r\n#ifdef local\r\n#define debug(x,label) cerr<<\"DEBUG \"<<label<<\" \"<<x<<'\\n';\r\nbool deb=true;\r\n#else\r\n#define debug(x,label);\r\nbool deb=false;//for in-code checking\r\n#endif\r\n\r\n#define min(a,b) ((a<b)?a:b)\r\n#define max(a,b) ((a>b)?a:b)\r\n#define lbd lower_bound\r\n#define upb upper_bound\r\n\r\n//const int mod=1000000007 or 998244353;\r\n\r\nstruct node{\r\n  int s,e,v,lz;\r\n  node *l,*r;\r\n  node(int ss,int ee){\r\n    s=ss;e=ee;\r\n    l=r=NULL;\r\n    v=lz=0;//range sum, lz prop value\r\n  }\r\n  inline void prop(){\r\n    if(s==e){\r\n      lz=0;\r\n      return;\r\n    }\r\n    if(l==NULL)l=new node(s,(s+e)/2);\r\n    if(r==NULL)r=new node((s+e)/2+1,e);\r\n    l->add(s,e,lz);\r\n    r->add(s,e,lz);\r\n    lz=0;\r\n  }\r\n  void add(int a,int b,int c){\r\n    if(a<=s && e<=b){\r\n      lz+=c;\r\n      v+=c*(e-s+1);\r\n      return;\r\n    }\r\n    prop();\r\n    if(a<=(s+e)/2)l->add(a,b,c);\r\n    if((s+e)/2<b)r->add(a,b,c);\r\n    v=l->v+r->v;\r\n  }\r\n  int query(int a,int b){\r\n    if(a<=s && e<=b){\r\n      return v;\r\n    }\r\n    prop();\r\n    return ((a<=(s+e)/2)?l->query(a,b):0)  + (((s+e)/2<b)?r->query(a,b):0);\r\n  }\r\n} *root;\r\n\r\nint32_t main(){\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  int n,q;\r\n  cin>>n>>q;\r\n  root=new node(0,n);\r\n  while(q--){\r\n    int a,b,c;\r\n    cin>>a;\r\n    if(a==1){\r\n      cin>>a>>b>>c;\r\n      root->add(a,b,c);\r\n    }else{\r\n      cin>>a>>b;//sum query\r\n      cout<<root->query(a,b)<<'\\n';\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n/*\r\n5 5\r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/\r\n"
    },
    {
        "username": "huangqr",
        "id": 34309,
        "date": "2021-05-20 00:25:35",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef pair<ll,ll>pl;\r\n\r\nstruct node{\r\n\tll s,e,m,sum=0,lazy=0;\r\n\tnode *l=NULL,*r=NULL;\r\n\tnode(ll ss,ll ee){\r\n\t\ts=ss,e=ee,m=(s+e)>>1;\r\n\t}\r\n\tvoid cc(){\r\n\t\tif(s==e||l!=NULL)return;\r\n\t\tl=new node(s,m),r=new node(m+1,e);\r\n\t}\r\n\tll value(){\r\n\t\tcc();\r\n\t\tsum+=(e-s+1)*lazy;\r\n\t\tif(s!=e&&lazy!=0){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t\treturn sum;\r\n\t}\r\n\tvoid update(ll a,ll b,ll x){\r\n\t\tcc();//value();\r\n\t\tif(s==a&&e==b)lazy+=x;\r\n\t\telse if(b<=m)l->update(a,b,x);\r\n\t\telse if(a>m)r->update(a,b,x);\r\n\t\telse l->update(a,m,x),r->update(m+1,b,x);\r\n\t\tif(s!=e)sum=l->value()+r->value();\r\n\t}\r\n\tll query(ll a,ll b){\r\n\t\tif(l==NULL)return (sum/(e-s+1) + lazy)*(b-a+1);\r\n\t\tvalue();\r\n\t\tif(s==a&&e==b)return sum;\r\n\t\telse if(b<=m)return l->query(a,b);\r\n\t\telse if(a>m)return r->query(a,b);\r\n\t\telse return l->query(a,m)+r->query(m+1,b);\r\n\t}\r\n}*root;\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0),cin.tie(NULL);\r\n\tll n,q,a,b,c,d;\r\n\tcin>>n;\r\n\troot=new node(0,n+1);\r\n\tcin>>q;\r\n\tfor(int i=0;i<q;i++){\r\n\t\tcin>>a;\r\n\t\tif(a==1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}"
    },
    {
        "username": "huangqr",
        "id": 34308,
        "date": "2021-05-20 00:21:05",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef pair<ll,ll>pl;\r\n\r\nstruct node{\r\n\tll sum=0,lazy=0,s,e,m;\r\n\tnode *l,*r;\r\n\tnode(ll ss,ll ee){\r\n\t\ts=ss,e=ee,m=(s+e)>>1;\r\n\t\tl=r=NULL;\r\n\t}\r\n\tvoid cc(){\r\n\t\tif(s==e||l!=NULL)return;\r\n\t\tl=new node(s,m),r=new node(m+1,e);\r\n\t}\r\n\tll value(){\r\n\t\tcc();\r\n\t\tsum+=lazy*(e-s+1);\r\n\t\tif(s!=e&&lazy!=0){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t\treturn sum;\r\n\t}\r\n\tvoid update(ll a,ll b,ll x){\r\n\t\tvalue();\r\n\t\tif(s==a&&e==b)lazy+=x;\r\n\t\telse if(b<=m)l->update(a,b,x);\r\n\t\telse if(a>m)r->update(a,b,x);\r\n\t\telse l->update(a,m,x),r->update(m+1,b,x);\r\n\t\tif(s!=e)sum=l->value()+r->value();\r\n\t}\r\n\tll query(ll a,ll b){\r\n\t\tvalue();\r\n\t\tif(s==a&&e==b)return sum;\r\n\t\telse if(b<=m)return l->query(a,b);\r\n\t\telse if(a>m)return r->query(a,b);\r\n\t\telse return l->query(a,m)+r->query(m+1,b);\r\n\t}\r\n}*root;\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0),cin.tie(NULL);\r\n\tll n,q,a,b,c,d;\r\n\tcin>>n;\r\n\troot=new node(0,n+1);\r\n\tcin>>q;\r\n\tfor(int i=0;i<q;i++){\r\n\t\tcin>>a;\r\n\t\tif(a==1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}"
    },
    {
        "username": "huangqr",
        "id": 34306,
        "date": "2021-05-20 00:18:57",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef pair<ll,ll>pl;\r\n\r\nstruct node{\r\n\tll sum=0,lazy=0,s,e,m;\r\n\tnode *l,*r;\r\n\tnode(ll ss,ll ee){\r\n\t\ts=ss,e=ee,m=(s+e)>>1;\r\n\t\tl=r=NULL;\r\n\t}\r\n\tvoid cc(){\r\n\t\tif(s==e||l!=NULL)return;\r\n\t\tl=new node(s,m),r=new node(m+1,e);\r\n\t}\r\n\tll value(){\r\n\t\tcc();\r\n\t\tsum+=lazy*(e-s+1);\r\n\t\tif(s!=e&&lazy!=0){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t\treturn sum;\r\n\t}\r\n\tvoid update(ll a,ll b,ll x){\r\n\t\tvalue();\r\n\t\tif(s==a&&e==b)lazy+=x;\r\n\t\telse if(b<=m)l->update(a,b,x);\r\n\t\telse if(a>m)r->update(a,b,x);\r\n\t\telse l->update(a,m,x),r->update(m+1,b,x);\r\n\t\tif(s!=e)sum=l->value()+r->value();\r\n\t}\r\n\tll query(ll a,ll b){\r\n\t\tif(l==NULL)return (sum/(e-s+1) + lazy)*(b-a+1);\r\n\t\tvalue();\r\n\t\tif(s==a&&e==b)return sum;\r\n\t\telse if(b<=m)return l->query(a,b);\r\n\t\telse if(a>m)return r->query(a,b);\r\n\t\telse return l->query(a,m)+r->query(m+1,b);\r\n\t}\r\n}*root;\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0),cin.tie(NULL);\r\n\tll n,q,a,b,c,d;\r\n\tcin>>n;\r\n\troot=new node(0,n+1);\r\n\tcin>>q;\r\n\tfor(int i=0;i<q;i++){\r\n\t\tcin>>a;\r\n\t\tif(a==1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}"
    },
    {
        "username": "huangqr",
        "id": 34302,
        "date": "2021-05-20 00:13:43",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef pair<ll,ll>pl;\r\n\r\nstruct node{\r\n\tll sum=0,lazy=0,s,e,m;\r\n\tnode *l,*r;\r\n\tnode(ll ss,ll ee){\r\n\t\ts=ss,e=ee,m=(s+e)>>1;\r\n\t\tl=r=NULL;\r\n\t}\r\n\tvoid cc(){\r\n\t\tif(s==e||l!=NULL)return;\r\n\t\tl=new node(s,m),r=new node(m+1,e);\r\n\t}\r\n\tll value(){\r\n\t\tcc();\r\n\t\tsum+=lazy*(e-s+1);\r\n\t\tif(s!=e&&lazy!=0){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t\treturn sum;\r\n\t}\r\n\tvoid update(ll a,ll b,ll x){\r\n\t\tvalue();\r\n\t\tif(s==a&&e==b)lazy+=x;\r\n\t\telse if(b<=m)l->update(a,b,x);\r\n\t\telse if(a>m)r->update(a,b,x);\r\n\t\telse l->update(a,m,x),r->update(m+1,b,x);\r\n\t\tif(s!=e)sum=l->value()+r->value();\r\n\t}\r\n\tll query(ll a,ll b){\r\n\t\tif(sum==0&&lazy==0&&l==NULL)return 0;\r\n\t\tvalue();\r\n\t\tif(s==a&&e==b)return sum;\r\n\t\telse if(b<=m)return l->query(a,b);\r\n\t\telse if(a>m)return r->query(a,b);\r\n\t\telse return l->query(a,m)+r->query(m+1,b);\r\n\t}\r\n}*root;\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0),cin.tie(NULL);\r\n\tll n,q,a,b,c,d;\r\n\tcin>>n;\r\n\troot=new node(0,n+1);\r\n\tcin>>q;\r\n\tfor(int i=0;i<q;i++){\r\n\t\tcin>>a;\r\n\t\tif(a==1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}"
    },
    {
        "username": "kai824",
        "id": 33837,
        "date": "2021-05-04 11:24:03",
        "code": "#include \"bits/stdc++.h\"\r\nusing namespace std;\r\n#define int long long\r\n#define eb emplace_back\r\n#define mp make_pair\r\ntypedef pair<int,int> pii;\r\n#define f first\r\n#define s second\r\n\r\n#ifdef local\r\n#define debug(x,label) cerr<<\"DEBUG \"<<label<<\" \"<<x<<'\\n';\r\n#else\r\n#define debug(x,label);\r\n#endif\r\n\r\n#define min(a,b) ((a<b)?a:b)\r\n#define max(a,b) ((a>b)?a:b)\r\n\r\n//const int mod=1000000007;\r\n\r\nstruct node{\r\n  int s,e,v,lz;\r\n  node *l,*r;\r\n  node(int ss,int ee){\r\n    s=ss;e=ee;\r\n    v=lz=0;\r\n    l=r=NULL;\r\n  }\r\n  void prop(){\r\n    if(s==e){\r\n      lz=0;\r\n      return;\r\n    }\r\n    if(l==NULL)l=new node(s,(s+e)/2);\r\n    if(r==NULL)r=new node((s+e)/2+1,e);\r\n    l->add(s,e,lz);\r\n    r->add(s,e,lz);\r\n    lz=0;\r\n  }\r\n  void add(int a,int b,int c){\r\n    if(a<=s && e<=b){\r\n      lz+=c;\r\n      v+=c*(e-s+1);\r\n      return;\r\n    }\r\n    prop();\r\n    if(a<=(s+e)/2)l->add(a,b,c);\r\n    if((s+e)/2<b)r->add(a,b,c);\r\n    v=l->v+r->v;\r\n  }\r\n  int query(int a,int b){\r\n    if(a<=s && e<=b){\r\n      return v;\r\n    }\r\n    prop();\r\n    int ans=0;\r\n    if(a<=(s+e)/2)ans+=l->query(a,b);\r\n    if((s+e)/2<b)ans+=r->query(a,b);\r\n    return ans;\r\n  }\r\n} *root;\r\n\r\nint32_t main(){\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  int n,q;\r\n  cin>>n>>q;\r\n  root=new node(0,n);\r\n  while(q--){\r\n    int a,b,c;\r\n    cin>>a;\r\n    if(a==1){\r\n      cin>>a>>b>>c;\r\n      root->add(a,b,c);\r\n    }else{\r\n      cin>>a>>b;\r\n      cout<<root->query(a,b)<<'\\n';\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n/*\r\n\r\n*/\r\n"
    },
    {
        "username": "kai824",
        "id": 33796,
        "date": "2021-05-02 01:28:29",
        "code": "#include \"bits/stdc++.h\"\r\nusing namespace std;\r\n#define int long long\r\n#define eb emplace_back\r\n#define mp make_pair\r\ntypedef pair<int,int> pii;\r\n#define f first\r\n#define s second\r\n\r\n#ifdef local\r\n#define debug(x,label) cerr<<\"DEBUG \"<<label<<\" \"<<x<<'\\n';\r\n#else\r\n#define debug(x,label);\r\n#endif\r\n\r\n#define min(a,b) ((a<b)?a:b)\r\n#define max(a,b) ((a>b)?a:b)\r\n\r\n//const int mod=1000000007;\r\n\r\nstruct node{\r\n  int s,e,v,lz;\r\n  node *l,*r;\r\n  node(int ss,int ee){\r\n    s=ss;e=ee;\r\n    v=lz=0;\r\n    l=r=NULL;\r\n  }\r\n  void prop(){\r\n    if(s==e){\r\n      lz=0;return;\r\n    }\r\n    if(l==NULL)l=new node(s,(s+e)/2);\r\n    if(r==NULL)r=new node((s+e)/2+1,e);\r\n    if(lz==0)return;\r\n    l->add(s,e,lz);\r\n    r->add(s,e,lz);\r\n    lz=0;\r\n  }\r\n  void add(int a,int b,int c){\r\n    if(a<=s && e<=b){\r\n      lz+=c;\r\n      v+=c*(e-s+1);\r\n      return;\r\n    }\r\n    prop();\r\n    if(a<=(s+e)/2)l->add(a,b,c);\r\n    if((s+e)/2<b)r->add(a,b,c);\r\n    v=l->v+r->v;\r\n  }\r\n  int query(int a,int b){\r\n    if(a<=s&&e<=b){\r\n      return v;\r\n    }\r\n    prop();\r\n    int ans=0;\r\n    if(a<=(s+e)/2)ans+=l->query(a,b);\r\n    if((s+e)/2<b)ans+=r->query(a,b);\r\n    return ans;\r\n  }\r\n} *root;\r\n\r\nint32_t main(){\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  int n,q;\r\n  cin>>n>>q;\r\n  root=new node(0,n);\r\n  while(q--){\r\n    int a,b,c;\r\n    cin>>a;\r\n    if(a==1){\r\n      cin>>a>>b>>c;\r\n      root->add(a,b,c);\r\n    }else{\r\n      cin>>a>>b;\r\n      cout<<root->query(a,b)<<'\\n';\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n/*\r\n\r\n*/\r\n"
    },
    {
        "username": "kai824",
        "id": 33695,
        "date": "2021-04-30 14:20:07",
        "code": "#include \"bits/stdc++.h\"\r\nusing namespace std;\r\n#define int long long\r\n#define eb emplace_back\r\n#define mp make_pair\r\ntypedef pair<int,int> pii;\r\n#define f first\r\n#define s second\r\n\r\n#ifdef local\r\n#define debug(x,label) cerr<<\"DEBUG \"<<label<<\" \"<<x<<'\\n';\r\n#else\r\n#define debug(x,label);\r\n#endif\r\n\r\n#define min(a,b) ((a<b)?a:b)\r\n#define max(a,b) ((a>b)?a:b)\r\n\r\n//const int mod=1000000007;\r\n\r\nstruct node{\r\n  int s,e,v,lz;\r\n  node *l,*r;\r\n  node(int ss,int ee){\r\n    s=ss;e=ee;\r\n    l=r=NULL;\r\n    v=lz=0;\r\n  }\r\n  void prop(){\r\n    if(s==e){\r\n      lz=0;return;\r\n    }\r\n    if(l==NULL){\r\n      l=new node(s,(s+e)/2);\r\n    }\r\n    if(r==NULL)r=new node((s+e)/2+1,e);\r\n    l->add(s,e,lz);\r\n    r->add(s,e,lz);\r\n    lz=0;\r\n  }\r\n  void add(int a,int b,int c){\r\n    if(a<=s && e<=b){\r\n      lz+=c;\r\n      v+=c*(e-s+1);\r\n      return;\r\n    }\r\n    prop();\r\n    if(a<=(s+e)/2){\r\n      l->add(a,b,c);\r\n    }\r\n    if((s+e)/2<b){\r\n      r->add(a,b,c);\r\n    }\r\n    v=l->v+r->v;\r\n  }\r\n  int query(int a,int b){\r\n    if(a<=s && e<=b){\r\n      return v;\r\n    }\r\n    prop();\r\n    int ans=0;\r\n    if(a<=(s+e)/2){\r\n      ans+=l->query(a,b);\r\n    }\r\n    if((s+e)/2<b){\r\n      ans+=r->query(a,b);\r\n    }\r\n    return ans;\r\n  }\r\n} *root;\r\n\r\nint32_t main(){\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  int n,q;\r\n  cin>>n>>q;\r\n  root=new node(0,n);\r\n  while(q--){\r\n    int a,b,c;\r\n    cin>>a;\r\n    if(a==1){\r\n      cin>>a>>b>>c;\r\n      root->add(a,b,c);\r\n    }else{\r\n      cin>>a>>b;\r\n      cout<<root->query(a,b)<<'\\n';\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n/*\r\n\r\n*/\r\n"
    },
    {
        "username": "kai824",
        "id": 33636,
        "date": "2021-04-27 09:28:16",
        "code": "#include \"bits/stdc++.h\"\r\nusing namespace std;\r\n#define int long long\r\n#define eb emplace_back\r\n#define mp make_pair\r\ntypedef pair<int,int> pii;\r\n#define f first\r\n#define s second\r\n\r\n#ifdef local\r\n#define debug(x,label) cerr<<\"DEBUG \"<<label<<\" \"<<x<<'\\n';\r\n#else\r\n#define debug(x,label);\r\n#endif\r\n\r\n#define min(a,b) ((a<b)?a:b)\r\n#define max(a,b) ((a>b)?a:b)\r\n\r\n//const int mod=1000000007;\r\nstruct node{\r\n  int s,e,v,lazy;\r\n  node *l,*r;\r\n  node(int ss,int ee){\r\n    s=ss;e=ee;\r\n    l=r=NULL;\r\n    v=lazy=0;\r\n  }\r\n  void prop(){\r\n    if(s==e){\r\n      lazy=0;\r\n      return;\r\n    }\r\n    if(l==NULL)l=new node(s,(s+e)/2);\r\n    if(r==NULL)r=new node((s+e)/2+1,e);\r\n    l->add(s,e,lazy);\r\n    r->add(s,e,lazy);\r\n    lazy=0;\r\n  }\r\n  void add(int a,int b,int c){\r\n    if(a<=s && e<=b){\r\n      lazy+=c;\r\n      v+=c*(e-s+1);\r\n      return;\r\n    }\r\n    prop();\r\n    if(a<=(s+e)/2){\r\n      l->add(a,b,c);\r\n    }\r\n    if((s+e)/2<b){\r\n      r->add(a,b,c);\r\n    }\r\n    v=l->v+r->v;\r\n  }\r\n  int query(int a,int b){\r\n    if(a<=s && e<=b){\r\n      return v;\r\n    }\r\n    int ans=0;\r\n    prop();\r\n    if(a<=(s+e)/2){\r\n      ans+=l->query(a,b);\r\n    }\r\n    if((s+e)/2<b){\r\n      ans+=r->query(a,b);\r\n    }\r\n    return ans;\r\n  }\r\n} *root;\r\n\r\nint32_t main(){\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  int n,q,a,b,c;\r\n  cin>>n>>q;\r\n  root=new node(0,n);\r\n  while(q--){\r\n    cin>>a;\r\n    if(a==1){\r\n      cin>>a>>b>>c;\r\n      root->add(a,b,c);\r\n    }else{\r\n      cin>>a>>b;\r\n      cout<<root->query(a,b)<<'\\n';\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n/*\r\n\r\n*/\r\n"
    },
    {
        "username": "kai824",
        "id": 33630,
        "date": "2021-04-25 22:16:19",
        "code": "#include \"bits/stdc++.h\"\r\nusing namespace std;\r\n#define int long long\r\n#define eb emplace_back\r\n#define mp make_pair\r\ntypedef pair<int,int> pii;\r\n#define f first\r\n#define s second\r\n\r\n#ifdef local\r\n#define debug(x,label) cerr<<\"DEBUG \"<<label<<\" \"<<x<<'\\n';\r\n#else\r\n#define debug(x,label);\r\n#endif\r\n\r\n#define min(a,b) ((a<b)?a:b)\r\n#define max(a,b) ((a>b)?a:b)\r\n\r\n//const int mod=1000000007;\r\n\r\nstruct node{\r\n  int s,e,v=0,laz=0;\r\n  node *l,*r;\r\n  node(int ss,int ee){\r\n    s=ss;e=ee;\r\n    v=laz=0;\r\n    l=r=NULL;\r\n  }\r\n  void prop(){\r\n    if(s<e){\r\n      if(l==NULL)l=new node(s,(s+e)/2);\r\n      if(r==NULL)r=new node((s+e)/2+1,e);\r\n      l->add(s,e,laz);\r\n      r->add(s,e,laz);\r\n    }\r\n    laz=0;\r\n  }\r\n  void add(int a,int b,int c){\r\n    if(a<=s && e<=b){\r\n      laz+=c;\r\n      v+=(e-s+1)*c;\r\n      return;\r\n    }\r\n    prop();\r\n    if(a<=(s+e)/2)l->add(a,b,c);\r\n    if((s+e)/2<b)r->add(a,b,c);\r\n    v=l->v+r->v;\r\n  }\r\n  int query(int a,int b){\r\n    if(a<=s && e<=b)return v;\r\n    int ans=0;\r\n    prop();\r\n    if(a<=(s+e)/2)ans+=l->query(a,b);\r\n    if((s+e)/2<b)ans+=r->query(a,b);\r\n    return ans;\r\n  }\r\n} *root;\r\n\r\nint32_t main(){\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  int n,q,a,b,c;\r\n  cin>>n>>q;\r\n  root=new node(0,n);\r\n  while(q--){\r\n    cin>>a;\r\n    if(a==1){\r\n      cin>>a>>b>>c;\r\n      root->add(a,b,c);\r\n    }else{\r\n      cin>>a>>b;\r\n      cout<<root->query(a,b)<<'\\n';\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n/*\r\n\r\n*/\r\n"
    },
    {
        "username": "kai824",
        "id": 33628,
        "date": "2021-04-25 21:24:24",
        "code": "#include \"bits/stdc++.h\"\r\nusing namespace std;\r\n#define int long long\r\n#define eb emplace_back\r\n#define mp make_pair\r\ntypedef pair<int,int> pii;\r\n#define f first\r\n#define s second\r\n\r\n#ifdef local\r\n#define debug(x,label) cerr<<\"DEBUG \"<<label<<\" \"<<x<<'\\n';\r\n#else\r\n#define debug(x,label);\r\n#endif\r\n\r\n#define min(a,b) ((a<b)?a:b)\r\n#define max(a,b) ((a>b)?a:b)\r\n\r\n//const int mod=1000000007;\r\n\r\nstruct node{\r\n  node *l,*r;\r\n  int s,e,v=0,lazy=0;\r\n  node(int ss,int ee){\r\n    s=ss;e=ee;\r\n    /*if(s==e){\r\n      l=r=NULL;\r\n    }else{\r\n      l=new node(s,(s+e)/2);\r\n      r=new node((s+e)/2+1,e);\r\n    }*/\r\n    l=r=NULL;\r\n  }\r\n  void prop(){\r\n    if(s==e){\r\n      lazy=0;\r\n      return;\r\n    }\r\n    if(l==NULL)l=new node(s,(s+e)/2);\r\n    if(r==NULL)r=new node((s+e)/2+1,e);\r\n    l->add(s,e,lazy);\r\n    r->add(s,e,lazy);\r\n    lazy=0;\r\n  }\r\n  void add(int a,int b,int c){\r\n    if(a<=s && e<=b){\r\n      lazy+=c;\r\n      v+=c*(e-s+1);\r\n      return;\r\n    }\r\n    prop();\r\n    if(a<=(s+e)/2)l->add(a,b,c);\r\n    if((s+e)/2<b)r->add(a,b,c);\r\n    v=l->v+r->v;\r\n  }\r\n  int query(int a,int b){\r\n    if(a<=s && e<=b)return v;\r\n    prop();\r\n    int ans=0;\r\n    if(a<=(s+e)/2)ans+=l->query(a,b);\r\n    if((s+e)/2<b)ans+=r->query(a,b);\r\n    return ans;\r\n  }\r\n} *root;\r\n\r\nint32_t main(){\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  int n,q;\r\n  cin>>n>>q;\r\n  root=new node(0,n);\r\n  int a,b,c;\r\n  while(q--){\r\n    cin>>a;\r\n    if(a==1){\r\n      cin>>a>>b>>c;\r\n      root->add(a,b,c);\r\n    }else{\r\n      cin>>a>>b;\r\n      cout<<root->query(a,b)<<'\\n';\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n/*\r\n\r\n*/\r\n"
    },
    {
        "username": "Halogen",
        "id": 30310,
        "date": "2021-02-19 12:02:49",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nstruct node {\r\n    long long s, e, m, v;\r\n    long long lazy; //lazy value storage\r\n    \r\n    node *l, *r;\r\n\r\n    node(long long _s, long long _e) {\r\n        s = _s;\r\n        e = _e;\r\n        v = lazy = 0;\r\n        \r\n        if (s == e) return;\r\n\r\n        m = (s + e) / 2;\r\n        \r\n        //Do not create the children here\r\n    }\r\n\r\n    void create() { \r\n    \r\n        if (s == e) return;       //No children\r\n        if (l != nullptr) return; //exists\r\n        \r\n        //Create if non-existent and has children\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n        \r\n    }\r\n    \r\n    void propo() { \r\n    \r\n        //Create before propo\r\n        create(); \r\n        \r\n        if (lazy != 0) {\r\n            //Update value base on range\r\n            v += lazy * (e - s + 1);\r\n            \r\n            //Propogate\r\n            if (s != e){\r\n                r -> lazy += lazy;\r\n                l -> lazy += lazy;\r\n            }\r\n            \r\n            //Reset value\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    void up(long long x, long long y, long long c) {\r\n        //Propo before update\r\n        propo();\r\n\r\n        if (x == s && y == e) {\r\n            lazy += c;\r\n            return;\r\n        }\r\n        else {\r\n            if (y <= m) l -> up(x, y, c);\r\n            else if (x > m) r -> up(x, y, c);\r\n            else { l -> up(x, m, c); r -> up(m + 1, y, c); }\r\n            \r\n            //Reminder to propo before updating cur node value\r\n            l -> propo(); r -> propo();\r\n            v = l -> v + r -> v;\r\n        }\r\n\r\n    }\r\n\r\n    long long query(long long x, long long y) {\r\n        //Propo before processing query\r\n        propo();\r\n\r\n        if (s == x && e == y) return v;\r\n        if (x > m) return r -> query(x, y);\r\n        if (y <= m) return l -> query(x, y);\r\n        else return l -> query(x, m) + r -> query(m + 1, y);\r\n    }\r\n} *root;\r\n\r\nint main() {\r\n    long long N; scanf(\"%lld\", &N);\r\n    root = new node(0, 1000000005);\r\n    long long Q; scanf(\"%lld\", &Q);\r\n    \r\n    for (long long i = 0; i < Q; i++) {\r\n        long long cmd; scanf(\"%lld\", &cmd);\r\n        if (cmd == 1) {\r\n            long long a, b, c; \r\n            scanf(\"%lld %lld %lld\", &a, &b, &c); \r\n            root -> up(a, b, c);\r\n        }\r\n        if (cmd == 2) {\r\n            long long x, y; scanf(\"%lld %lld\", &x, &y);\r\n            printf(\"%lld\\n\", root -> query(x, y));\r\n        }\r\n    }\r\n}   "
    },
    {
        "username": "Halogen",
        "id": 30309,
        "date": "2021-02-19 11:54:49",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nstruct node {\r\n    long long s, e, m, v;\r\n    long long lazy;\r\n    \r\n    node *l, *r;\r\n\r\n    node(long long _s, long long _e) {\r\n        s = _s;\r\n        e = _e;\r\n        v = lazy = 0;\r\n        if (s == e) return;\r\n\r\n        m = (s + e) / 2;\r\n    }\r\n\r\n    void create() {\r\n        if (s == e) return;\r\n        if (l != nullptr) return;\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n    }\r\n    \r\n    void propo() {\r\n        create();\r\n        if (lazy != 0) {\r\n            //Update value base on range\r\n            v += lazy * (e - s + 1);\r\n            if (s != e){\r\n                r -> lazy += lazy;\r\n                l -> lazy += lazy;\r\n            }\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    void up(long long x, long long y, long long c) {\r\n        create();\r\n        propo();\r\n\r\n        if (x == s && y == e) {\r\n            lazy += c;\r\n            return;\r\n        }\r\n        else {\r\n            if (y <= m) l -> up(x, y, c);\r\n            else if (x > m) r -> up(x, y, c);\r\n            else { l -> up(x, m, c); r -> up(m + 1, y, c); }\r\n            \r\n            l -> propo(); r -> propo();\r\n            v = l -> v + r -> v;\r\n        }\r\n\r\n    }\r\n\r\n    long long query(long long x, long long y) {\r\n        create();\r\n        propo();\r\n\r\n        if (s == x && e == y) return v;\r\n        if (x > m) return r -> query(x, y);\r\n        if (y <= m) return l -> query(x, y);\r\n        else return l -> query(x, m) + r -> query(m + 1, y);\r\n    }\r\n}*root;\r\n\r\nint main() {\r\n    long long N; scanf(\"%lld\", &N);\r\n    root = new node(0, 1000000005);\r\n    long long Q; scanf(\"%lld\", &Q);\r\n    \r\n    for (long long i = 0; i < Q; i++) {\r\n        long long cmd; scanf(\"%lld\", &cmd);\r\n        if (cmd == 1) {\r\n            long long a, b, c; \r\n            scanf(\"%lld %lld %lld\", &a, &b, &c); \r\n            root -> up(a, b, c);\r\n        }\r\n        if (cmd == 2) {\r\n            long long x, y; scanf(\"%lld %lld\", &x, &y);\r\n            printf(\"%lld\\n\", root -> query(x, y));\r\n        }\r\n    }\r\n}   "
    },
    {
        "username": "fyss006",
        "id": 29307,
        "date": "2021-01-30 14:26:13",
        "code": "#include<algorithm>\r\n#include<iostream>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<cstdio>\r\n#include<map>\r\n#include<cmath>\r\n#include<stack>\r\n#define Rint register int\r\n#define ll long long\r\nusing namespace std;\r\nll sum[10000005],m,n;\r\nll lazy[10000005];\r\nint root,cnt;\r\nint ls[10000005],rs[10000005];\r\ninline void f(int &p, ll l, ll r, ll v){\r\n    if(!p){\r\n        p=++cnt;\r\n    }\r\n    lazy[p]+=v;\r\n    sum[p]+=v*(r-l+1);\r\n    return;\r\n}\r\ninline void pushdown(int p, ll l, ll r){\r\n    if(!lazy[p]) return;\r\n    ll mid; mid=(l+r)>>1;\r\n    f(ls[p],l,mid,lazy[p]); f(rs[p],mid+1,r,lazy[p]);\r\n    lazy[p]=0;\r\n}\r\n\r\ninline void update(int &k,ll l, ll r, ll x, ll y, ll v){\r\n    if(!k){\r\n        k=++cnt;\r\n    }\r\n    if(l>=x&&r<=y){\r\n        f(k,l,r,v);\r\n        return;\r\n    }\r\n    pushdown(k,l,r);\r\n    ll mid;\r\n    mid=(l+r)>>1;\r\n    if(x<=mid) update(ls[k],l,mid,x,y,v);\r\n    if(y>mid) update(rs[k],mid+1,r,x,y,v);\r\n    sum[k]=sum[ls[k]]+sum[rs[k]];\r\n    return;\r\n}\r\ninline ll check(int k, ll l,ll r, ll x, ll y){\r\n    if(!k) return 0;\r\n    if(l>=x&&r<=y){\r\n        return sum[k];\r\n    }\r\n    ll mid,ans=0;\r\n    mid=(l+r)>>1;\r\n    pushdown(k,l,r);\r\n    if(x<=mid){\r\n        ans+=check(ls[k],l,mid,x,y);\r\n    }\r\n    if(mid<y){\r\n        ans+=check(rs[k],mid+1,r,x,y);\r\n    }\r\n    return ans;\r\n}\r\nint main(){\r\n    std::ios::sync_with_stdio(false);\r\n    cin>>n>>m;\r\n    for(int i=1;i<=m;i++){\r\n        int b,x,y,z;\r\n        cin>>b>>x>>y;\r\n        if(b==1){\r\n            cin>>z;\r\n            update(root,1,n,x,y,z);\r\n        }else{\r\n            cout<<check(root,1,n,x,y)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n"
    },
    {
        "username": "fyss006",
        "id": 29306,
        "date": "2021-01-30 14:20:31",
        "code": "#pragma GCC optimize(2)\r\n#pragma GCC optimize(3)\r\n#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC optimize(\"inline\")\r\n#include<algorithm>\r\n#include<iostream>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<cstdio>\r\n#include<map>\r\n#include<cmath>\r\n#include<stack>\r\n#define Rint register int\r\n#define ll long long\r\nusing namespace std;\r\nll sum[10000005],m,n;\r\nll lazy[10000005];\r\nint root,cnt;\r\nint ls[10000005],rs[10000005];\r\ninline void f(int &p, ll l, ll r, ll v){\r\n    if(!p){\r\n        p=++cnt;\r\n    }\r\n    lazy[p]+=v;\r\n    sum[p]+=v*(r-l+1);\r\n    return;\r\n}\r\ninline void pushdown(int p, ll l, ll r){\r\n    if(!lazy[p]) return;\r\n    ll mid; mid=(l+r)>>1;\r\n    f(ls[p],l,mid,lazy[p]); f(rs[p],mid+1,r,lazy[p]);\r\n    lazy[p]=0;\r\n}\r\n\r\ninline void update(int &k,ll l, ll r, ll x, ll y, ll v){\r\n    if(!k){\r\n        k=++cnt;\r\n    }\r\n    if(l>=x&&r<=y){\r\n        f(k,l,r,v);\r\n        return;\r\n    }\r\n    pushdown(k,l,r);\r\n    ll mid;\r\n    mid=(l+r)>>1;\r\n    if(x<=mid) update(ls[k],l,mid,x,y,v);\r\n    if(y>mid) update(rs[k],mid+1,r,x,y,v);\r\n    sum[k]=sum[ls[k]]+sum[rs[k]];\r\n    return;\r\n}\r\ninline ll check(int k, ll l,ll r, ll x, ll y){\r\n    if(!k) return 0;\r\n    if(l>=x&&r<=y){\r\n        return sum[k];\r\n    }\r\n    ll mid,ans=0;\r\n    mid=(l+r)>>1;\r\n    pushdown(k,l,r);\r\n    if(x<=mid){\r\n        ans+=check(ls[k],l,mid,x,y);\r\n    }\r\n    if(mid<y){\r\n        ans+=check(rs[k],mid+1,r,x,y);\r\n    }\r\n    return ans;\r\n}\r\nint main(){\r\n    std::ios::sync_with_stdio(false);\r\n    cin>>n>>m;\r\n    for(int i=1;i<=m;i++){\r\n        int b,x,y,z;\r\n        cin>>b>>x>>y;\r\n        if(b==1){\r\n            cin>>z;\r\n            update(root,1,n,x,y,z);\r\n        }else{\r\n            cout<<check(root,1,n,x,y)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n"
    },
    {
        "username": "fyss006",
        "id": 29298,
        "date": "2021-01-30 14:13:09",
        "code": "#pragma GCC optimize(2)\r\n#pragma GCC optimize(3)\r\n#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC optimize(\"inline\")\r\n#include<algorithm>\r\n#include<iostream>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<cstdio>\r\n#include<map>\r\n#include<cmath>\r\n#include<stack>\r\n#define Rint register int\r\n#define ll long long\r\nusing namespace std;\r\nll sum[10000005],m,n;\r\nll lazy[10000005],root,cnt;\r\nll ls[10000005],rs[10000005];\r\ninline void f(ll &p, ll l, ll r, ll v){\r\n    if(!p){\r\n        p=++cnt;\r\n    }\r\n    lazy[p]+=v;\r\n    sum[p]+=v*(r-l+1);\r\n    return;\r\n}\r\ninline void pushdown(ll p, ll l, ll r){\r\n    if(!lazy[p]) return;\r\n    ll mid; mid=(l+r)>>1;\r\n    f(ls[p],l,mid,lazy[p]); f(rs[p],mid+1,r,lazy[p]);\r\n    lazy[p]=0;\r\n}\r\n\r\ninline void update(ll &k,ll l, ll r, ll x, ll y, ll v){\r\n    if(!k){\r\n        k=++cnt;\r\n    }\r\n    if(l>=x&&r<=y){\r\n        f(k,l,r,v);\r\n        return;\r\n    }\r\n    pushdown(k,l,r);\r\n    ll mid;\r\n    mid=(l+r)>>1;\r\n    if(x<=mid) update(ls[k],l,mid,x,y,v);\r\n    if(y>mid) update(rs[k],mid+1,r,x,y,v);\r\n    sum[k]=sum[ls[k]]+sum[rs[k]];\r\n    return;\r\n}\r\ninline ll check(ll k, ll l,ll r, ll x, ll y){\r\n    if(!k) return 0;\r\n    if(l>=x&&r<=y){\r\n        return sum[k];\r\n    }\r\n    ll mid,ans=0;\r\n    mid=(l+r)>>1;\r\n    pushdown(k,l,r);\r\n    if(x<=mid){\r\n        ans+=check(ls[k],l,mid,x,y);\r\n    }\r\n    if(mid<y){\r\n        ans+=check(rs[k],mid+1,r,x,y);\r\n    }\r\n    return ans;\r\n}\r\nint main(){\r\n    std::ios::sync_with_stdio(false);\r\n    cin>>n>>m;\r\n    for(int i=1;i<=m;i++){\r\n        ll b,x,y,z;\r\n        cin>>b>>x>>y;\r\n        if(b==1){\r\n            cin>>z;\r\n            update(root,1,n,x,y,z);\r\n        }else{\r\n            cout<<check(root,1,n,x,y)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n"
    },
    {
        "username": "lithops",
        "id": 29295,
        "date": "2021-01-30 14:05:35",
        "code": "//\r\n// Created by Lithops on 2020/12/17.\r\n//\r\n// generalised LazyVersion using template, lazy propagation and lazy creation, best version of all.\r\n// customisable to handle various update and query types. (incl. sum, min, max, product etc.)\r\n// able to lazy create 1e9 elements if constructed by single value constructor, saving both memory and time.\r\n\r\n#include <bits/stdc++.h>\r\n#include <ostream>\r\n\r\n#define MAXN 10007\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\ntemplate<class T>\r\nclass SegTree {\r\n\r\n    class Node {\r\n        int l, r;\r\n        Node *lch = nullptr, *rch = nullptr;\r\n        T val, lazy;\r\n        bool updated = true;\r\n        T init_v;\r\n\r\n        int m() { // recalculating m on request saves memory than storing it.\r\n            return (l + r) / 2;\r\n        }\r\n\r\n#define m m()\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        void modify0(T &a, const T &b) const {\r\n            a = b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void modify(T &a, const T &b) const {\r\n            a += b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        // in reality, used only when lazy-creating a node.\r\n        void lazy_modify0(T &a, const T &b) const {\r\n            a = b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void lazy_modify(T &a, const T &b) const {\r\n            a += b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        T merge(const T &a, const T &b) const {\r\n            return a + b;\r\n        }\r\n\r\n        void update_lazy(const T &new_val) {\r\n            if (updated) modify0(lazy, new_val);\r\n            else modify(lazy, new_val);\r\n            updated = false;\r\n        }\r\n\r\n        void propagate() {\r\n            if (updated) return;\r\n            create_ch();\r\n            lazy_modify(val, lazy);\r\n            if (l != r) {\r\n                lch->update_lazy(lazy);\r\n                rch->update_lazy(lazy);\r\n            }\r\n            updated = true;\r\n        }\r\n\r\n        void create_ch() {\r\n            if (l == r) return;\r\n            if (lch == nullptr) lch = new Node(init_v, l, m);\r\n            if (rch == nullptr) rch = new Node(init_v, m + 1, r);\r\n        }\r\n\r\n    public:\r\n        // [_l, _r]\r\n        // no lazy creation\r\n        template<class IT>\r\n        Node(const IT first, const IT last, int _l, int _r) : l(_l), r(_r) {\r\n//            m = (l + r) / 2;\r\n            if (l == r) val = first[l];\r\n            else {\r\n                lch = new Node(first, last, l, m);\r\n                rch = new Node(first, last, m + 1, r);\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [_l, _r]\r\n        // uses lazy creation\r\n        Node(const T &v, int _l, int _r) : l(_l), r(_r), init_v(v) {\r\n//            m = (l + r) / 2;\r\n            lazy_modify0(val, init_v);\r\n        }\r\n\r\n        void pupdate(int up, const T &uv) {\r\n            // assert(pl <= up && up <= pr);\r\n            create_ch();\r\n            propagate();\r\n            if (l == r) update_lazy(uv);\r\n            else {\r\n                if (up <= m) lch->pupdate(up, uv);\r\n                else rch->pupdate(up, uv);\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ul, ur)\r\n        void rupdate(int ul, int ur, const T &uv) {\r\n            // assert(l <= ul && ul < ur && ur <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ul == l && r == ur - 1) update_lazy(uv);\r\n            else {\r\n                if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n                else if (m < ul) rch->rupdate(ul, ur, uv);\r\n                else {\r\n                    lch->rupdate(ul, m + 1, uv);\r\n                    rch->rupdate(m + 1, ur, uv);\r\n                }\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ql, qr)\r\n        T rquery(int ql, int qr) {\r\n            // assert(l <= ql && ql < qr && qr <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ql == l && qr - 1 == r) return val;\r\n            else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n            else if (ql > m) return rch->rquery(ql, qr);\r\n            else return merge(lch->rquery(ql, m + 1), rch->rquery(m + 1, qr));\r\n        }\r\n\r\n        friend ostream &operator<<(ostream &os, const Node &node) {\r\n            os << node.l << \"~\" << node.r << \", val: \" << node.val << \" updated: \" << node.updated << \" lazy_update: \"\r\n               << node.lazy << endl;\r\n            if (node.lch != nullptr) os << *(node.lch);\r\n            if (node.rch != nullptr) os << *(node.rch);\r\n            return os;\r\n        }\r\n\r\n#undef m\r\n    } *root;\r\n\r\npublic:\r\n    // [first, last)\r\n    template<class IT>\r\n    SegTree(const IT first, const IT last) {\r\n        root = new Node(first, last, 0, last - first - 1);\r\n    }\r\n\r\n    SegTree(int count, const T &v) {\r\n        root = new Node(v, 0, count - 1);\r\n    }\r\n\r\n    void pupdate(int up, const T &new_val) {\r\n        root->pupdate(up, new_val);\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, const T &new_val) {\r\n        root->rupdate(ul, ur, new_val);\r\n    }\r\n\r\n    // [ql, qr)\r\n    T rquery(int ql, int qr) {\r\n        return root->rquery(ql, qr);\r\n    }\r\n\r\n    void print() const {\r\n        cout << *root;\r\n    }\r\n\r\n\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    ll n, q;\r\n    cin >> n >> q;\r\n    SegTree<ll> tree(n, 0);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nint main7() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int n, m;\r\n    int a[MAXN];\r\n\r\n\r\n    cin >> n >> m;\r\n\r\n  assert(n<-1);\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cin >> a[i];\r\n    }\r\n\r\n    SegTree<int> tree(a, a + n);\r\n\r\n    for (int i = 0; i < m; ++i) {\r\n        string s;\r\n        cin >> s;\r\n        if (s == \"ru\") {\r\n            int l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l, r, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"p\") {\r\n            tree.print();\r\n        } else if (s == \"pu\") {\r\n            int p, v;\r\n            cin >> p >> v;\r\n            tree.pupdate(p, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"rq\") {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l, r) << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "lithops",
        "id": 29294,
        "date": "2021-01-30 14:04:54",
        "code": "//\r\n// Created by Lithops on 2020/12/17.\r\n//\r\n// generalised LazyVersion using template, lazy propagation and lazy creation, best version of all.\r\n// customisable to handle various update and query types. (incl. sum, min, max, product etc.)\r\n// able to lazy create 1e9 elements if constructed by single value constructor, saving both memory and time.\r\n\r\n#include <bits/stdc++.h>\r\n#include <ostream>\r\n\r\n#define MAXN 10007\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\ntemplate<class T>\r\nclass SegTree {\r\n\r\n    class Node {\r\n        int l, r;\r\n        Node *lch = nullptr, *rch = nullptr;\r\n        T val, lazy;\r\n        bool updated = true;\r\n        T init_v;\r\n\r\n        int m() { // recalculating m on request saves memory than storing it.\r\n            return (l + r) / 2;\r\n        }\r\n\r\n#define m m()\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        void modify0(T &a, const T &b) const {\r\n            a = b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void modify(T &a, const T &b) const {\r\n            a += b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        // in reality, used only when lazy-creating a node.\r\n        void lazy_modify0(T &a, const T &b) const {\r\n            a = b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void lazy_modify(T &a, const T &b) const {\r\n            a += b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        T merge(const T &a, const T &b) const {\r\n            return a + b;\r\n        }\r\n\r\n        void update_lazy(const T &new_val) {\r\n            if (updated) modify0(lazy, new_val);\r\n            else modify(lazy, new_val);\r\n            updated = false;\r\n        }\r\n\r\n        void propagate() {\r\n            if (updated) return;\r\n            create_ch();\r\n            lazy_modify(val, lazy);\r\n            if (l != r) {\r\n                lch->update_lazy(lazy);\r\n                rch->update_lazy(lazy);\r\n            }\r\n            updated = true;\r\n        }\r\n\r\n        void create_ch() {\r\n            if (l == r) return;\r\n            if (lch == nullptr) lch = new Node(init_v, l, m);\r\n            if (rch == nullptr) rch = new Node(init_v, m + 1, r);\r\n        }\r\n\r\n    public:\r\n        // [_l, _r]\r\n        // no lazy creation\r\n        template<class IT>\r\n        Node(const IT first, const IT last, int _l, int _r) : l(_l), r(_r) {\r\n//            m = (l + r) / 2;\r\n            if (l == r) val = first[l];\r\n            else {\r\n                lch = new Node(first, last, l, m);\r\n                rch = new Node(first, last, m + 1, r);\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [_l, _r]\r\n        // uses lazy creation\r\n        Node(const T &v, int _l, int _r) : l(_l), r(_r), init_v(v) {\r\n//            m = (l + r) / 2;\r\n            lazy_modify0(val, init_v);\r\n        }\r\n\r\n        void pupdate(int up, const T &uv) {\r\n            // assert(pl <= up && up <= pr);\r\n            create_ch();\r\n            propagate();\r\n            if (l == r) update_lazy(uv);\r\n            else {\r\n                if (up <= m) lch->pupdate(up, uv);\r\n                else rch->pupdate(up, uv);\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ul, ur)\r\n        void rupdate(int ul, int ur, const T &uv) {\r\n            // assert(l <= ul && ul < ur && ur <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ul == l && r == ur - 1) update_lazy(uv);\r\n            else {\r\n                if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n                else if (m < ul) rch->rupdate(ul, ur, uv);\r\n                else {\r\n                    lch->rupdate(ul, m + 1, uv);\r\n                    rch->rupdate(m + 1, ur, uv);\r\n                }\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ql, qr)\r\n        T rquery(int ql, int qr) {\r\n            // assert(l <= ql && ql < qr && qr <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ql == l && qr - 1 == r) return val;\r\n            else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n            else if (ql > m) return rch->rquery(ql, qr);\r\n            else return merge(lch->rquery(ql, m + 1), rch->rquery(m + 1, qr));\r\n        }\r\n\r\n        friend ostream &operator<<(ostream &os, const Node &node) {\r\n            os << node.l << \"~\" << node.r << \", val: \" << node.val << \" updated: \" << node.updated << \" lazy_update: \"\r\n               << node.lazy << endl;\r\n            if (node.lch != nullptr) os << *(node.lch);\r\n            if (node.rch != nullptr) os << *(node.rch);\r\n            return os;\r\n        }\r\n\r\n#undef m\r\n    } *root;\r\n\r\npublic:\r\n    // [first, last)\r\n    template<class IT>\r\n    SegTree(const IT first, const IT last) {\r\n        root = new Node(first, last, 0, last - first - 1);\r\n    }\r\n\r\n    SegTree(int count, const T &v) {\r\n        root = new Node(v, 0, count - 1);\r\n    }\r\n\r\n    void pupdate(int up, const T &new_val) {\r\n        root->pupdate(up, new_val);\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, const T &new_val) {\r\n        root->rupdate(ul, ur, new_val);\r\n    }\r\n\r\n    // [ql, qr)\r\n    T rquery(int ql, int qr) {\r\n        return root->rquery(ql, qr);\r\n    }\r\n\r\n    void print() const {\r\n        cout << *root;\r\n    }\r\n\r\n\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    ll n, q;\r\n    cin >> n >> q;\r\n    SegTree<ll> tree(n, 0);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nint main7() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int n, m;\r\n    int a[MAXN];\r\n\r\n\r\n    cin >> n >> m;\r\n\r\n  assert(n<=1000000);\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cin >> a[i];\r\n    }\r\n\r\n    SegTree<int> tree(a, a + n);\r\n\r\n    for (int i = 0; i < m; ++i) {\r\n        string s;\r\n        cin >> s;\r\n        if (s == \"ru\") {\r\n            int l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l, r, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"p\") {\r\n            tree.print();\r\n        } else if (s == \"pu\") {\r\n            int p, v;\r\n            cin >> p >> v;\r\n            tree.pupdate(p, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"rq\") {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l, r) << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "lithops",
        "id": 29293,
        "date": "2021-01-30 14:02:05",
        "code": "//\r\n// Created by Lithops on 2020/12/17.\r\n//\r\n// generalised LazyVersion using template, lazy propagation and lazy creation, best version of all.\r\n// customisable to handle various update and query types. (incl. sum, min, max, product etc.)\r\n// able to lazy create 1e9 elements if constructed by single value constructor, saving both memory and time.\r\n\r\n#include <bits/stdc++.h>\r\n#include <ostream>\r\n\r\n#define MAXN 10007\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\ntemplate<class T>\r\nclass SegTree {\r\n\r\n    class Node {\r\n        int l, r;\r\n        Node *lch = nullptr, *rch = nullptr;\r\n        T val, lazy;\r\n        bool updated = true;\r\n        T init_v;\r\n\r\n        int m() { // recalculating m on request saves memory than storing it.\r\n            return (l + r) / 2;\r\n        }\r\n\r\n#define m m()\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        void modify0(T &a, const T &b) const {\r\n            a = b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void modify(T &a, const T &b) const {\r\n            a += b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        // in reality, used only when lazy-creating a node.\r\n        void lazy_modify0(T &a, const T &b) const {\r\n            a = b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void lazy_modify(T &a, const T &b) const {\r\n            a += b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        T merge(const T &a, const T &b) const {\r\n            return a + b;\r\n        }\r\n\r\n        void update_lazy(const T &new_val) {\r\n            if (updated) modify0(lazy, new_val);\r\n            else modify(lazy, new_val);\r\n            updated = false;\r\n        }\r\n\r\n        void propagate() {\r\n            if (updated) return;\r\n            create_ch();\r\n            lazy_modify(val, lazy);\r\n            if (l != r) {\r\n                lch->update_lazy(lazy);\r\n                rch->update_lazy(lazy);\r\n            }\r\n            updated = true;\r\n        }\r\n\r\n        void create_ch() {\r\n            if (l == r) return;\r\n            if (lch == nullptr) lch = new Node(init_v, l, m);\r\n            if (rch == nullptr) rch = new Node(init_v, m + 1, r);\r\n        }\r\n\r\n    public:\r\n        // [_l, _r]\r\n        // no lazy creation\r\n        template<class IT>\r\n        Node(const IT first, const IT last, int _l, int _r) : l(_l), r(_r) {\r\n//            m = (l + r) / 2;\r\n            if (l == r) val = first[l];\r\n            else {\r\n                lch = new Node(first, last, l, m);\r\n                rch = new Node(first, last, m + 1, r);\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [_l, _r]\r\n        // uses lazy creation\r\n        Node(const T &v, int _l, int _r) : l(_l), r(_r), init_v(v) {\r\n//            m = (l + r) / 2;\r\n            lazy_modify0(val, init_v);\r\n        }\r\n\r\n        void pupdate(int up, const T &uv) {\r\n            // assert(pl <= up && up <= pr);\r\n            create_ch();\r\n            propagate();\r\n            if (l == r) update_lazy(uv);\r\n            else {\r\n                if (up <= m) lch->pupdate(up, uv);\r\n                else rch->pupdate(up, uv);\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ul, ur)\r\n        void rupdate(int ul, int ur, const T &uv) {\r\n            // assert(l <= ul && ul < ur && ur <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ul == l && r == ur - 1) update_lazy(uv);\r\n            else {\r\n                if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n                else if (m < ul) rch->rupdate(ul, ur, uv);\r\n                else {\r\n                    lch->rupdate(ul, m + 1, uv);\r\n                    rch->rupdate(m + 1, ur, uv);\r\n                }\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ql, qr)\r\n        T rquery(int ql, int qr) {\r\n            // assert(l <= ql && ql < qr && qr <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ql == l && qr - 1 == r) return val;\r\n            else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n            else if (ql > m) return rch->rquery(ql, qr);\r\n            else return merge(lch->rquery(ql, m + 1), rch->rquery(m + 1, qr));\r\n        }\r\n\r\n        friend ostream &operator<<(ostream &os, const Node &node) {\r\n            os << node.l << \"~\" << node.r << \", val: \" << node.val << \" updated: \" << node.updated << \" lazy_update: \"\r\n               << node.lazy << endl;\r\n            if (node.lch != nullptr) os << *(node.lch);\r\n            if (node.rch != nullptr) os << *(node.rch);\r\n            return os;\r\n        }\r\n\r\n#undef m\r\n    } *root;\r\n\r\npublic:\r\n    // [first, last)\r\n    template<class IT>\r\n    SegTree(const IT first, const IT last) {\r\n        root = new Node(first, last, 0, last - first - 1);\r\n    }\r\n\r\n    SegTree(int count, const T &v) {\r\n        root = new Node(v, 0, count - 1);\r\n    }\r\n\r\n    void pupdate(int up, const T &new_val) {\r\n        root->pupdate(up, new_val);\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, const T &new_val) {\r\n        root->rupdate(ul, ur, new_val);\r\n    }\r\n\r\n    // [ql, qr)\r\n    T rquery(int ql, int qr) {\r\n        return root->rquery(ql, qr);\r\n    }\r\n\r\n    void print() const {\r\n        cout << *root;\r\n    }\r\n\r\n\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    ll n, q;\r\n    cin >> n >> q;\r\n    SegTree<ll> tree(n, 0);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nint main7() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int n, m;\r\n    int a[MAXN];\r\n\r\n\r\n    cin >> n >> m;\r\n\r\n  assert(n<=20000000);\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cin >> a[i];\r\n    }\r\n\r\n    SegTree<int> tree(a, a + n);\r\n\r\n    for (int i = 0; i < m; ++i) {\r\n        string s;\r\n        cin >> s;\r\n        if (s == \"ru\") {\r\n            int l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l, r, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"p\") {\r\n            tree.print();\r\n        } else if (s == \"pu\") {\r\n            int p, v;\r\n            cin >> p >> v;\r\n            tree.pupdate(p, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"rq\") {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l, r) << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "maomao90",
        "id": 29136,
        "date": "2021-01-27 16:54:33",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define mnto(x, y) x = min(x, (__typeof__(x)) y)\r\n#define mxto(x, y) x = max(x, (__typeof__(x)) y)\r\n#define REP(i, s, e) for (int i = s; i < e; i++)\r\n#define RREP(i, s, e) for (int i = s; i >= e; i--)\r\ntypedef long long ll;\r\n#define MP make_pair\r\n#define FI first\r\n#define SE second\r\ntypedef pair<int, int> ii;\r\ntypedef pair<ll, ll> pll;\r\n#define MT make_tuple\r\ntypedef tuple<int, int, int> iii;\r\n#define ALL(_a) _a.begin(), _a.end()\r\n#define pb emplace_back\r\ntypedef vector<int> vi;\r\ntypedef vector<ii> vii;\r\n\r\n#define INF 100000005\r\n#define LINF 100000000000000005\r\n#define MOD 1000000007\r\n#define MAXN 200005\r\n\r\nint o;\r\n\r\nstruct node {\r\n\tll lo, hi;\r\n\tll val, lazy;\r\n\tnode *l, *r;\r\n\tnode(ll lo, ll hi): lo(lo), hi(hi), val(0), lazy(0), l(nullptr), r(nullptr) {}\r\n\tvoid makeChild() {\r\n\t\tif (lo != hi && l == nullptr) {\r\n\t\t\tll mid = lo + hi >> 1;\r\n\t\t\tl = new node(lo, mid), r = new node(mid + 1, hi);\r\n\t\t}\r\n\t}\r\n\tvoid propo() {\r\n\t\tval += lazy * (hi - lo + 1);\r\n\t\tmakeChild();\r\n\t\tif (lo != hi) {\r\n\t\t\tl -> lazy += lazy;\r\n\t\t\tr -> lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid incre(ll s, ll e, ll v) {\r\n\t\tif (lo >= s && hi <= e) {\r\n\t\t\tlazy += v;\r\n\t\t\tpropo();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tmakeChild();\r\n\t\tpropo();\r\n\t\tl -> propo(); r -> propo();\r\n\t\tll mid = lo + hi >> 1;\r\n\t\tif (s <= mid) l -> incre(s, e, v);\r\n\t\tif (e > mid) r -> incre(s, e, v);\r\n\t\tval = l -> val + r -> val;\r\n\t}\r\n\tll sum(ll s, ll e) {\r\n\t\tpropo();\r\n\t\tif (lo >= s && hi <= e) return val;\r\n\t\tmakeChild();\r\n\t\tll mid = lo + hi >> 1;\r\n\t\tif (e <= mid) return l -> sum(s, e);\r\n\t\telse if (s > mid) return r -> sum(s, e);\r\n\t\telse return l -> sum(s, e) + r -> sum(s, e);\r\n\t}\r\n\t~node() {\r\n\t\tif (l != nullptr) delete l;\r\n\t\tif (r != nullptr) delete r;\r\n\t}\r\n} *root;\r\n\r\nint main() {\r\n\tint n; scanf(\"%d%d\", &n, &o);\r\n\troot = new node(0, n + 5);\r\n\twhile (o--) {\r\n\t\tint t; scanf(\"%d\", &t);\r\n\t\tif (t == 1) {\r\n\t\t\tint l, r, v; scanf(\"%d%d%d\", &l, &r, &v);\r\n\t\t\troot -> incre(l, r, v);\r\n\t\t} else if (t == 2) {\r\n\t\t\tint s, e; scanf(\"%d%d\", &s, &e);\r\n\t\t\tprintf(\"%lld\\n\", root -> sum(s, e));\r\n\t\t} else {\r\n\t\t\troot = new node(-INF, INF);\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n"
    },
    {
        "username": "ian",
        "id": 27615,
        "date": "2021-01-03 17:19:58",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\ntypedef pair<int, int> ii;\r\ntypedef long long ll;\r\ntypedef vector<int> vi;\r\ntypedef vector<ii> vii;\r\ntypedef tuple<int, int, int> iii;\r\n\r\nconst int INF = 1e9;\r\nconst ll INFL = 1e18;\r\n\r\nstruct node {\r\n  int s, e, m;\r\n  int lazy = 0;\r\n  int val = 0;\r\n  node *l, *r;\r\n  node(int S, int E) {\r\n    s = S;\r\n    e = E;\r\n    m = (s + e) / 2;\r\n    l = nullptr;\r\n    r = nullptr;\r\n  }\r\n\r\n  void create() {\r\n    if (s != e) {\r\n      l = new node(s, m);\r\n      r = new node(m + 1, e);\r\n    }\r\n  }\r\n\r\n  void propagate() {\r\n    // if (lazy == 0) return;\r\n    val += (e - s + 1) * lazy;\r\n    if (s != e) {\r\n      if (l == nullptr) create();\r\n      l->lazy += lazy;\r\n      r->lazy += lazy;\r\n    }\r\n    lazy = 0;\r\n  }\r\n\r\n  void increment(int S, int E, int v) {\r\n    // cout << (l) << endl;\r\n    // cout << s << \" \" << e << \" \" << v << endl;\r\n    if (s == S and e == E) {\r\n      lazy += v;\r\n    } else {\r\n      if (l == nullptr) create();\r\n      if (E <= m) {\r\n        l->increment(S, E, v);\r\n      } else if (S > m) {\r\n        r->increment(S, E, v);\r\n      } else {\r\n        l->increment(S, m, v);\r\n        r->increment(m + 1, E, v);\r\n      }\r\n      l->propagate();\r\n      r->propagate();\r\n      val = l->val + r->val;\r\n    }\r\n  }\r\n\r\n  int query(int S, int E) {\r\n    if (l == nullptr) create();\r\n    propagate();\r\n\r\n    if (s == S and e == E)\r\n      return val;\r\n    else if (E <= m)\r\n      return l->query(S, E);\r\n    else if (S > m)\r\n      return r->query(S, E);\r\n    else\r\n      return l->query(S, m) + r->query(m + 1, E);\r\n  }\r\n};\r\n\r\nnode *root = new node(1, 1e9);\r\n\r\nsigned main() {\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(NULL);\r\n  int n, q;\r\n  cin >> n >> q;\r\n  for (int i = 0; i < q; ++i) {\r\n    int j;\r\n    cin >> j;\r\n    if (j == 1) {\r\n      int l, r, k;\r\n      cin >> l >> r >> k;\r\n      root->increment(l, r, k);\r\n    } else {\r\n      int l, r;\r\n      cin >> l >> r;\r\n      cout << root->query(l, r) << endl;\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "ian",
        "id": 27613,
        "date": "2021-01-03 16:59:17",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\ntypedef pair<int, int> ii;\r\ntypedef long long ll;\r\ntypedef vector<int> vi;\r\ntypedef vector<ii> vii;\r\ntypedef tuple<int, int, int> iii;\r\n\r\nconst int INF = 1e9;\r\nconst ll INFL = 1e18;\r\n\r\nstruct node {\r\n  int s, e, m;\r\n  int lazy = 0;\r\n  int val = 0;\r\n  node *l, *r;\r\n  node(int S, int E) {\r\n    s = S;\r\n    e = E;\r\n    m = (s + e) / 2;\r\n    l = nullptr;\r\n    r = nullptr;\r\n  }\r\n\r\n  void create() {\r\n    if (s != e) {\r\n      l = new node(s, m);\r\n      r = new node(m + 1, e);\r\n    }\r\n  }\r\n\r\n  void propagate() {\r\n    if (lazy == 0) return;\r\n    val += (e - s + 1) * lazy;\r\n    if (s != e) {\r\n      if (l == nullptr) create();\r\n      l->lazy += lazy;\r\n      r->lazy += lazy;\r\n    }\r\n    lazy = 0;\r\n  }\r\n\r\n  void increment(int S, int E, int v) {\r\n    // cout << (l) << endl;\r\n    // cout << s << \" \" << e << \" \" << v << endl;\r\n    if (s == S and e == E) {\r\n      lazy += v;\r\n    } else {\r\n      if (l == nullptr) create();\r\n      if (E <= m) {\r\n        l->increment(S, E, v);\r\n      } else if (S > m) {\r\n        r->increment(S, E, v);\r\n      } else {\r\n        l->increment(S, m, v);\r\n        r->increment(m + 1, E, v);\r\n      }\r\n      l->propagate();\r\n      r->propagate();\r\n      val = l->val + r->val;\r\n    }\r\n  }\r\n\r\n  int query(int S, int E) {\r\n    if (l == nullptr) create();\r\n    propagate();\r\n\r\n    if (s == S and e == E)\r\n      return val;\r\n    else if (E <= m)\r\n      return l->query(S, E);\r\n    else if (S > m)\r\n      return r->query(S, E);\r\n    else\r\n      return l->query(S, m) + r->query(m + 1, E);\r\n  }\r\n} * root;\r\n\r\nsigned main() {\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(NULL);\r\n  int n, q;\r\n  cin >> n >> q;\r\n  root = new node(1, n);\r\n  for (int i = 0; i < q; ++i) {\r\n    int j;\r\n    cin >> j;\r\n    if (j == 1) {\r\n      int l, r, k;\r\n      cin >> l >> r >> k;\r\n      root->increment(l, r, k);\r\n    } else {\r\n      int l, r;\r\n      cin >> l >> r;\r\n      cout << root->query(l, r) << endl;\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "chicken",
        "id": 26696,
        "date": "2020-12-29 12:27:49",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\nstruct node{\r\n    ll s, e, m, v, lazy;\r\n    node *l, *r;\r\n    node(ll _s, ll _e){\r\n        s = _s; e = _e;\r\n        m = (s + e) / 2;\r\n        v = 0; lazy = 0;\r\n    }\r\n    void create(){\r\n        if(s != e){\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n    void propo(){\r\n        if(l == nullptr) create();\r\n        v += (e-s+1) * lazy;\r\n        if(s != e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n    ll query(ll x, ll y){\r\n        propo();\r\n        if(s == x && e == y) return v;\r\n        if(x > m) return r->query(x, y);\r\n        if(y <= m) return l->query(x, y);\r\n        return l->query(x, m) + r->query(m+1, y);\r\n    }\r\n    void update(ll x, ll y, ll val){\r\n        if(s == x && e == y){\r\n            lazy += val;\r\n            return;\r\n        } else{\r\n          propo();\r\n            if(x > m) r->update(x, y, val);\r\n            else if(y <= m) l->update(x, y, val);\r\n            else{\r\n                l->update(x, m, val);\r\n                r->update(m+1, y, val);\r\n            }\r\n            l->propo();\r\n            r->propo();\r\n            v = l->v + r->v;\r\n        }\r\n    }\r\n} *root = new node(-100, 1e9+100);\r\n\r\nint main(){\r\n    ll n, q; cin >> n >> q;\r\n    for(ll i = 0; i < q; i ++){\r\n        ll inst; cin >> inst;\r\n        if(inst == 1){\r\n            ll x, y, v;\r\n            cin >> x >> y >> v;\r\n            root->update(x, y, v);\r\n        } else{\r\n            ll x, y;\r\n            cin >> x >> y;\r\n            cout << root->query(x, y) << '\\n';\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "lithops",
        "id": 20522,
        "date": "2020-12-18 13:37:31",
        "code": "//\r\n// Created by Lithops on 2020/12/17.\r\n//\r\n// generalised LazyVersion using template, lazy propagation and lazy creation, best version of all.\r\n// customisable to handle various update and query types. (incl. sum, min, max, product etc.)\r\n// able to lazy create 1e9 elements if constructed by single value constructor, saving both memory and time.\r\n\r\n#include <bits/stdc++.h>\r\n#include <ostream>\r\n\r\n#define MAXN 10007\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\ntemplate<class T>\r\nclass SegTree {\r\n\r\n    class Node {\r\n        int l, r;\r\n        Node *lch = nullptr, *rch = nullptr;\r\n        T val, lazy;\r\n        bool updated = true;\r\n        T init_v;\r\n\r\n        int m() { // recalculating m on request saves memory than storing it.\r\n            return (l + r) / 2;\r\n        }\r\n\r\n#define m m()\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        void modify0(T &a, const T &b) const {\r\n            a = b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void modify(T &a, const T &b) const {\r\n            a += b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        // in reality, used only when lazy-creating a node.\r\n        void lazy_modify0(T &a, const T &b) const {\r\n            a = b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void lazy_modify(T &a, const T &b) const {\r\n            a += b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        T merge(const T &a, const T &b) const {\r\n            return a + b;\r\n        }\r\n\r\n        void update_lazy(const T &new_val) {\r\n            if (updated) modify0(lazy, new_val);\r\n            else modify(lazy, new_val);\r\n            updated = false;\r\n        }\r\n\r\n        void propagate() {\r\n            if (updated) return;\r\n            create_ch();\r\n            lazy_modify(val, lazy);\r\n            if (l != r) {\r\n                lch->update_lazy(lazy);\r\n                rch->update_lazy(lazy);\r\n            }\r\n            updated = true;\r\n        }\r\n\r\n        void create_ch() {\r\n            if (l == r) return;\r\n            if (lch == nullptr) lch = new Node(init_v, l, m);\r\n            if (rch == nullptr) rch = new Node(init_v, m + 1, r);\r\n        }\r\n\r\n    public:\r\n        // [_l, _r]\r\n        // no lazy creation\r\n        template<class IT>\r\n        Node(const IT first, const IT last, int _l, int _r) : l(_l), r(_r) {\r\n//            m = (l + r) / 2;\r\n            if (l == r) val = first[l];\r\n            else {\r\n                lch = new Node(first, last, l, m);\r\n                rch = new Node(first, last, m + 1, r);\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [_l, _r]\r\n        // uses lazy creation\r\n        Node(const T &v, int _l, int _r) : l(_l), r(_r), init_v(v) {\r\n//            m = (l + r) / 2;\r\n            lazy_modify0(val, init_v);\r\n        }\r\n\r\n        void pupdate(int up, const T &uv) {\r\n            // assert(pl <= up && up <= pr);\r\n            create_ch();\r\n            propagate();\r\n            if (l == r) update_lazy(uv);\r\n            else {\r\n                if (up <= m) lch->pupdate(up, uv);\r\n                else rch->pupdate(up, uv);\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ul, ur)\r\n        void rupdate(int ul, int ur, const T &uv) {\r\n            // assert(l <= ul && ul < ur && ur <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ul == l && r == ur - 1) update_lazy(uv);\r\n            else {\r\n                if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n                else if (m < ul) rch->rupdate(ul, ur, uv);\r\n                else {\r\n                    lch->rupdate(ul, m + 1, uv);\r\n                    rch->rupdate(m + 1, ur, uv);\r\n                }\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ql, qr)\r\n        T rquery(int ql, int qr) {\r\n            // assert(l <= ql && ql < qr && qr <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ql == l && qr - 1 == r) return val;\r\n            else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n            else if (ql > m) return rch->rquery(ql, qr);\r\n            else return merge(lch->rquery(ql, m + 1), rch->rquery(m + 1, qr));\r\n        }\r\n\r\n        friend ostream &operator<<(ostream &os, const Node &node) {\r\n            os << node.l << \"~\" << node.r << \", val: \" << node.val << \" updated: \" << node.updated << \" lazy_update: \"\r\n               << node.lazy << endl;\r\n            if (node.lch != nullptr) os << *(node.lch);\r\n            if (node.rch != nullptr) os << *(node.rch);\r\n            return os;\r\n        }\r\n\r\n#undef m\r\n    } *root;\r\n\r\npublic:\r\n    // [first, last)\r\n    template<class IT>\r\n    SegTree(const IT first, const IT last) {\r\n        root = new Node(first, last, 0, last - first - 1);\r\n    }\r\n\r\n    SegTree(int count, const T &v) {\r\n        root = new Node(v, 0, count - 1);\r\n    }\r\n\r\n    void pupdate(int up, const T &new_val) {\r\n        root->pupdate(up, new_val);\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, const T &new_val) {\r\n        root->rupdate(ul, ur, new_val);\r\n    }\r\n\r\n    // [ql, qr)\r\n    T rquery(int ql, int qr) {\r\n        return root->rquery(ql, qr);\r\n    }\r\n\r\n    void print() const {\r\n        cout << *root;\r\n    }\r\n\r\n\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    ll n, q;\r\n    cin >> n >> q;\r\n    SegTree<ll> tree(n, 0);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nint main7() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int n, m;\r\n    int a[MAXN];\r\n\r\n\r\n    cin >> n >> m;\r\n\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cin >> a[i];\r\n    }\r\n\r\n    SegTree<int> tree(a, a + n);\r\n\r\n    for (int i = 0; i < m; ++i) {\r\n        string s;\r\n        cin >> s;\r\n        if (s == \"ru\") {\r\n            int l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l, r, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"p\") {\r\n            tree.print();\r\n        } else if (s == \"pu\") {\r\n            int p, v;\r\n            cin >> p >> v;\r\n            tree.pupdate(p, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"rq\") {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l, r) << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "lithops",
        "id": 20503,
        "date": "2020-12-18 12:59:13",
        "code": "//\r\n// Created by Lithops on 2020/12/17.\r\n//\r\n// generalised LazyVersion using template, lazy propagation and lazy creation, best version of all.\r\n// customisable to handle various update and query types. (incl. sum, min, max, product etc.)\r\n// able to lazy create 1e9 elements if constructed by single value constructor, saving both memory and time.\r\n\r\n#include <bits/stdc++.h>\r\n#include <ostream>\r\n\r\n#define MAXN 10007\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\ntemplate<class T>\r\nclass SegTree {\r\n\r\n    class Node {\r\n        int l, r;\r\n        Node *lch = nullptr, *rch = nullptr;\r\n        T val, lazy;\r\n        bool updated = true;\r\n        T init_v;\r\n\r\n        int m() { // recalculating m on request saves memory than storing it.\r\n            return (l + r) / 2;\r\n        }\r\n\r\n#define m m()\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        void modify0(T &a, const T &b) const {\r\n            a = b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void modify(T &a, const T &b) const {\r\n            a += b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        // in reality, used only when lazy-creating a node.\r\n        void lazy_modify0(T &a, const T &b) const {\r\n            a = b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void lazy_modify(T &a, const T &b) const {\r\n            a += b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        T merge(const T &a, const T &b) const {\r\n            return a + b;\r\n        }\r\n\r\n        void update_lazy(const T &new_val) {\r\n            if (updated) modify0(lazy, new_val);\r\n            else modify(lazy, new_val);\r\n            updated = false;\r\n        }\r\n\r\n        void propagate() {\r\n            if (updated) return;\r\n            create_ch();\r\n            lazy_modify(val, lazy);\r\n            if (l != r) {\r\n                lch->update_lazy(lazy);\r\n                rch->update_lazy(lazy);\r\n            }\r\n            updated = true;\r\n        }\r\n\r\n        void create_ch() {\r\n            if (l == r) return;\r\n            if (lch == nullptr) lch = new Node(init_v, l, m);\r\n            if (rch == nullptr) rch = new Node(init_v, m + 1, r);\r\n        }\r\n\r\n    public:\r\n        // [_l, _r]\r\n        // no lazy creation\r\n        template<class IT>\r\n        Node(const IT first, const IT last, int _l, int _r) : l(_l), r(_r) {\r\n//            m = (l + r) / 2;\r\n            if (l == r) val = first[l];\r\n            else {\r\n                lch = new Node(first, last, l, m);\r\n                rch = new Node(first, last, m + 1, r);\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [_l, _r]\r\n        // uses lazy creation\r\n        Node(const T &v, int _l, int _r) : l(_l), r(_r), init_v(v) {\r\n//            m = (l + r) / 2;\r\n            lazy_modify0(val, init_v);\r\n        }\r\n\r\n        void pupdate(int up, const T &uv) {\r\n            // assert(pl <= up && up <= pr);\r\n            create_ch();\r\n            propagate();\r\n            if (l == r) update_lazy(uv);\r\n            else {\r\n                if (up <= m) lch->pupdate(up, uv);\r\n                else rch->pupdate(up, uv);\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ul, ur)\r\n        void rupdate(int ul, int ur, const T &uv) {\r\n            // assert(l <= ul && ul < ur && ur <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ul == l && r == ur - 1) update_lazy(uv);\r\n            else {\r\n                if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n                else if (m < ul) rch->rupdate(ul, ur, uv);\r\n                else {\r\n                    lch->rupdate(ul, m + 1, uv);\r\n                    rch->rupdate(m + 1, ur, uv);\r\n                }\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ql, qr)\r\n        T rquery(int ql, int qr) {\r\n            // assert(l <= ql && ql < qr && qr <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ql == l && qr - 1 == r) return val;\r\n            else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n            else if (ql > m) return rch->rquery(ql, qr);\r\n            else return merge(lch->rquery(ql, m + 1), rch->rquery(m + 1, qr));\r\n        }\r\n\r\n        friend ostream &operator<<(ostream &os, const Node &node) {\r\n            os << node.l << \"~\" << node.r << \", val: \" << node.val << \" updated: \" << node.updated << \" lazy_update: \"\r\n               << node.lazy << endl;\r\n            if (node.lch != nullptr) os << *(node.lch);\r\n            if (node.rch != nullptr) os << *(node.rch);\r\n            return os;\r\n        }\r\n\r\n#undef m\r\n    } *root;\r\n\r\npublic:\r\n    // [first, last)\r\n    template<class IT>\r\n    SegTree(const IT first, const IT last) {\r\n        root = new Node(first, last, 0, last - first - 1);\r\n    }\r\n\r\n    SegTree(int count, const T &v) {\r\n        root = new Node(v, 0, count - 1);\r\n    }\r\n\r\n    void pupdate(int up, const T &new_val) {\r\n        root->pupdate(up, new_val);\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, const T &new_val) {\r\n        root->rupdate(ul, ur, new_val);\r\n    }\r\n\r\n    // [ql, qr)\r\n    T rquery(int ql, int qr) {\r\n        return root->rquery(ql, qr);\r\n    }\r\n\r\n    void print() const {\r\n        cout << *root;\r\n    }\r\n\r\n\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    ll n, q;\r\n    cin >> n >> q;\r\n    SegTree<ll> tree(n, 0);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nint main7() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int n, m;\r\n    int a[MAXN];\r\n\r\n\r\n    cin >> n >> m;\r\n\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cin >> a[i];\r\n    }\r\n\r\n    SegTree<int> tree(a, a + n);\r\n\r\n    for (int i = 0; i < m; ++i) {\r\n        string s;\r\n        cin >> s;\r\n        if (s == \"ru\") {\r\n            int l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l, r, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"p\") {\r\n            tree.print();\r\n        } else if (s == \"pu\") {\r\n            int p, v;\r\n            cin >> p >> v;\r\n            tree.pupdate(p, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"rq\") {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l, r) << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "lithops",
        "id": 20500,
        "date": "2020-12-18 12:48:16",
        "code": "//\r\n// Created by Lithops on 2020/12/17.\r\n//\r\n// generalised LazyVersion using template, lazy propagation and lazy creation, best version of all.\r\n// customisable to handle various update and query types. (incl. sum, min, max, product etc.)\r\n// able to lazy create 1e9 elements if constructed by single value constructor, saving both memory and time.\r\n\r\n#include <bits/stdc++.h>\r\n#include <ostream>\r\n\r\n#define MAXN 10007\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\ntemplate<class T>\r\nclass SegTree {\r\n\r\n    class Node {\r\n        int l, r;\r\n        Node *lch = nullptr, *rch = nullptr;\r\n        T val, lazy;\r\n        bool updated = true;\r\n        const T &init_v;\r\n\r\n        int m() {\r\n            return (l + r) / 2;\r\n        }\r\n\r\n#define m m()\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        void modify0(T &a, const T &b) const {\r\n            a = b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void modify(T &a, const T &b) const {\r\n            a += b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        // in reality, used only when lazy-creating a node.\r\n        void lazy_modify0(T &a, const T &b) const {\r\n            a = b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void lazy_modify(T &a, const T &b) const {\r\n            a += b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        T merge(const T &a, const T &b) const {\r\n            return a + b;\r\n        }\r\n\r\n        void update_lazy(const T &new_val) {\r\n            if (updated) modify0(lazy, new_val);\r\n            else modify(lazy, new_val);\r\n            updated = false;\r\n        }\r\n\r\n        void propagate() {\r\n            if (updated) return;\r\n            create_ch();\r\n            lazy_modify(val, lazy);\r\n            if (l != r) {\r\n                lch->update_lazy(lazy);\r\n                rch->update_lazy(lazy);\r\n            }\r\n            updated = true;\r\n        }\r\n\r\n        void create_ch() {\r\n            if (l == r) return;\r\n            if (lch == nullptr) lch = new Node(init_v, l, m);\r\n            if (rch == nullptr) rch = new Node(init_v, m + 1, r);\r\n        }\r\n\r\n    public:\r\n        // [_l, _r]\r\n        // no lazy creation\r\n        template<class IT>\r\n        Node(const IT first, const IT last, int _l, int _r) : l(_l), r(_r), init_v(*first) {\r\n//            m = (l + r) / 2;\r\n            if (l == r) val = first[l];\r\n            else {\r\n                lch = new Node(first, last, l, m);\r\n                rch = new Node(first, last, m + 1, r);\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [_l, _r]\r\n        // uses lazy creation\r\n        Node(const T &v, int _l, int _r) : l(_l), r(_r), init_v(v) {\r\n//            m = (l + r) / 2;\r\n            lazy_modify0(val, init_v);\r\n        }\r\n\r\n        void pupdate(int up, const T &uv) {\r\n            // assert(pl <= up && up <= pr);\r\n            create_ch();\r\n            propagate();\r\n            if (l == r) update_lazy(uv);\r\n            else {\r\n                if (up <= m) lch->pupdate(up, uv);\r\n                else rch->pupdate(up, uv);\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ul, ur)\r\n        void rupdate(int ul, int ur, const T &uv) {\r\n            // assert(l <= ul && ul < ur && ur <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ul == l && r == ur - 1) update_lazy(uv);\r\n            else {\r\n                if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n                else if (m < ul) rch->rupdate(ul, ur, uv);\r\n                else {\r\n                    lch->rupdate(ul, m + 1, uv);\r\n                    rch->rupdate(m + 1, ur, uv);\r\n                }\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ql, qr)\r\n        T rquery(int ql, int qr) {\r\n            // assert(l <= ql && ql < qr && qr <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ql == l && qr - 1 == r) return val;\r\n            else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n            else if (ql > m) return rch->rquery(ql, qr);\r\n            else return merge(lch->rquery(ql, m + 1), rch->rquery(m + 1, qr));\r\n        }\r\n\r\n        friend ostream &operator<<(ostream &os, const Node &node) {\r\n            os << node.l << \"~\" << node.r << \", val: \" << node.val << \" updated: \" << node.updated << \" lazy_update: \"\r\n               << node.lazy << endl;\r\n            if (node.lch != nullptr) os << *(node.lch);\r\n            if (node.rch != nullptr) os << *(node.rch);\r\n            return os;\r\n        }\r\n\r\n#undef m\r\n    } *root;\r\n\r\npublic:\r\n    // [first, last)\r\n    template<class IT>\r\n    SegTree(const IT first, const IT last) {\r\n        root = new Node(first, last, 0, last - first - 1);\r\n    }\r\n\r\n    SegTree(int count, const T &v) {\r\n        root = new Node(v, 0, count - 1);\r\n    }\r\n\r\n    void pupdate(int up, const T &new_val) {\r\n        root->pupdate(up, new_val);\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, const T &new_val) {\r\n        root->rupdate(ul, ur, new_val);\r\n    }\r\n\r\n    // [ql, qr)\r\n    T rquery(int ql, int qr) {\r\n        return root->rquery(ql, qr);\r\n    }\r\n\r\n    void print() const {\r\n        cout << *root;\r\n    }\r\n\r\n\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    ll n, q;\r\n    cin >> n >> q;\r\n    SegTree<ll> tree(n, 0);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nint main9() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int n, m;\r\n    int a[MAXN];\r\n\r\n\r\n    cin >> n >> m;\r\n\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cin >> a[i];\r\n    }\r\n\r\n    SegTree<int> tree(a, a + n);\r\n\r\n    for (int i = 0; i < m; ++i) {\r\n        string s;\r\n        cin >> s;\r\n        if (s == \"ru\") {\r\n            int l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l, r, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"p\") {\r\n            tree.print();\r\n        } else if (s == \"pu\") {\r\n            int p, v;\r\n            cin >> p >> v;\r\n            tree.pupdate(p, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"rq\") {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l, r) << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "lithops",
        "id": 20499,
        "date": "2020-12-18 12:44:12",
        "code": "//\r\n// Created by Lithops on 2020/12/17.\r\n//\r\n\r\n#include <bits/stdc++.h>\r\n\r\n#define MAXN\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\n//\r\n// Created by Lithops on 2020/12/14.\r\n//\r\n// lazy creation\r\n\r\n#include <bits/stdc++.h>\r\n\r\n#define MAXN\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\nclass Node {\r\n    int l, r, m;\r\n    Node *lch = nullptr, *rch = nullptr;\r\n    ll val = 0, lazy = 0;\r\n\r\n//    int m() const {\r\n//        return (l + r) / 2;\r\n//    }\r\n    \r\n    void create_ch() {\r\n        if (l != r && lch == nullptr) {\r\n            lch = new Node(l, m);\r\n            rch = new Node(m + 1, r);\r\n        }\r\n    }\r\n\r\n    void propagate() {\r\n        if (lazy == 0) return;\r\n        create_ch();\r\n        val += lazy * (r - l + 1); // lazy sum update\r\n        if (l != r) {\r\n            lch->lazy += lazy; // sum update\r\n            rch->lazy += lazy; // sum update\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\npublic:\r\n    // [_l, _r]\r\n    Node(int _l, int _r) : l(_l), r(_r) {\r\n        m = (l + r) / 2;\r\n//        if (l != r) {\r\n//            lch = new Node(l, m);\r\n//            rch = new Node(m + 1, r);\r\n//        }\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, ll uv) {\r\n        create_ch();\r\n        propagate();\r\n        if (ul == l && r == ur - 1) lazy += uv;// sum update\r\n        else {\r\n            if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n            else if (m < ul) rch->rupdate(ul, ur, uv);\r\n            else {\r\n                lch->rupdate(ul, m + 1, uv);\r\n                rch->rupdate(m + 1, ur, uv);\r\n            }\r\n            lch->propagate();\r\n            rch->propagate();\r\n            val = lch->val + rch->val; // sum merge\r\n        }\r\n    }\r\n\r\n    // [ql, qr)\r\n    ll rquery(int ql, int qr) {\r\n        create_ch();\r\n        propagate();\r\n        if (ql == l && qr - 1 == r) return val;\r\n        else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n        else if (ql > m) return rch->rquery(ql, qr);\r\n\r\n        else return lch->rquery(ql, m + 1) + rch->rquery(m + 1, qr); // sum\r\n    }\r\n\r\n    friend ostream &operator<<(ostream &os, const Node &node) {\r\n        os << node.l << \"~\" << node.r << \", val: \" << node.val << \" lazy_update: \"\r\n           << node.lazy << endl;\r\n        if (node.l != node.r) os << *(node.lch) << *(node.rch);\r\n        return os;\r\n    }\r\n} *root;\r\n\r\nll n, q;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    cin >> n >> q;\r\n    root = new Node(0, n - 1);\r\n    for (ll i = 0; i < q; ++i) {\r\n        int cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            int l, r, v;\r\n            cin >> l >> r >> v;\r\n            root->rupdate(l - 1, r, v);\r\n        } else {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << root->rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n}\r\n\r\n"
    },
    {
        "username": "lithops",
        "id": 20498,
        "date": "2020-12-18 12:39:26",
        "code": "//\r\n// Created by Lithops on 2020/12/17.\r\n//\r\n\r\n#include <bits/stdc++.h>\r\n\r\n#define MAXN\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\n//\r\n// Created by Lithops on 2020/12/14.\r\n//\r\n// lazy creation\r\n\r\n#include <bits/stdc++.h>\r\n\r\n#define MAXN\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\nclass Node {\r\n    int l, r;\r\n    Node *lch = nullptr, *rch = nullptr;\r\n    ll val = 0, lazy = 0;\r\n\r\n    int m() {\r\n        return (l+r)/2;\r\n    }\r\n    void create_ch() {\r\n        if (l != r && lch == nullptr) {\r\n            lch = new Node(l, m());\r\n            rch = new Node(m() + 1, r);\r\n        }\r\n    }\r\n    void propagate() {\r\n        if (lazy == 0) return;\r\n        create_ch();\r\n        val += lazy * (r - l + 1); // lazy sum update\r\n        if (l != r) {\r\n            lch->lazy += lazy; // sum update\r\n            rch->lazy += lazy; // sum update\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\npublic:\r\n    // [_l, _r]\r\n    Node(int _l, int _r) : l(_l), r(_r) {\r\n//        m = (l + r) / 2;\r\n//        if (l != r) {\r\n//            lch = new Node(l, m);\r\n//            rch = new Node(m + 1, r);\r\n//        }\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, ll uv) {\r\n        create_ch();\r\n        propagate();\r\n        if (ul == l && r == ur - 1) lazy += uv;// sum update\r\n        else {\r\n            if (ur - 1 <= m()) lch->rupdate(ul, ur, uv);\r\n            else if (m() < ul) rch->rupdate(ul, ur, uv);\r\n            else {\r\n                lch->rupdate(ul, m() + 1, uv);\r\n                rch->rupdate(m() + 1, ur, uv);\r\n            }\r\n            lch->propagate();\r\n            rch->propagate();\r\n            val = lch->val + rch->val; // sum merge\r\n        }\r\n    }\r\n\r\n    // [ql, qr)\r\n    ll rquery(int ql, int qr) {\r\n        create_ch();\r\n        propagate();\r\n        if (ql == l && qr - 1 == r) return val;\r\n        else if (qr - 1 <= m()) return lch->rquery(ql, qr);\r\n        else if (ql > m()) return rch->rquery(ql, qr);\r\n\r\n        else return lch->rquery(ql, m() + 1) + rch->rquery(m() + 1, qr); // sum\r\n    }\r\n\r\n    friend ostream &operator<<(ostream &os, const Node &node) {\r\n        os << node.l << \"~\" << node.r << \", val: \" << node.val << \" lazy_update: \"\r\n           << node.lazy << endl;\r\n        if (node.l != node.r) os << *(node.lch) << *(node.rch);\r\n        return os;\r\n    }\r\n} *root;\r\n\r\nll n, q;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    cin >> n >> q;\r\n    root = new Node(0, n - 1);\r\n    for (ll i = 0; i < q; ++i) {\r\n        int cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            int l, r, v;\r\n            cin >> l >> r >> v;\r\n            root->rupdate(l - 1, r, v);\r\n        } else {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << root->rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n}\r\n\r\n"
    },
    {
        "username": "lithops",
        "id": 20497,
        "date": "2020-12-18 12:37:38",
        "code": "//\r\n// Created by Lithops on 2020/12/17.\r\n//\r\n\r\n#include <bits/stdc++.h>\r\n\r\n#define MAXN\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\n//\r\n// Created by Lithops on 2020/12/14.\r\n//\r\n// lazy creation\r\n\r\n#include <bits/stdc++.h>\r\n\r\n#define MAXN\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\nclass Node {\r\n    int l, r;\r\n    Node *lch = nullptr, *rch = nullptr;\r\n    ll val = 0, lazy = 0;\r\n\r\n    int m() {\r\n        return (l+r)/2;\r\n    }\r\n    void create_ch() {\r\n        if (l != r && lch == nullptr) {\r\n            lch = new Node(l, m());\r\n            rch = new Node(m() + 1, r);\r\n        }\r\n    }\r\n    void propagate() {\r\n        if (lazy == 0) return;\r\n        create_ch();\r\n        val += lazy * (r - l + 1); // lazy sum update\r\n        if (l != r) {\r\n            lch->lazy += lazy; // sum update\r\n            rch->lazy += lazy; // sum update\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\npublic:\r\n    // [_l, _r]\r\n    Node(int _l, int _r) : l(_l), r(_r) {\r\n//        m = (l + r) / 2;\r\n//        if (l != r) {\r\n//            lch = new Node(l, m);\r\n//            rch = new Node(m + 1, r);\r\n//        }\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, ll uv) {\r\n        create_ch();\r\n        propagate();\r\n        if (ul == l && r == ur - 1) lazy += uv;// sum update\r\n        else {\r\n            if (ur - 1 <= m()) lch->rupdate(ul, ur, uv);\r\n            else if (m() < ul) rch->rupdate(ul, ur, uv);\r\n            else {\r\n                lch->rupdate(ul, m() + 1, uv);\r\n                rch->rupdate(m() + 1, ur, uv);\r\n            }\r\n            lch->propagate();\r\n            rch->propagate();\r\n            val = lch->val + rch->val; // sum merge\r\n        }\r\n    }\r\n\r\n    // [ql, qr)\r\n    ll rquery(int ql, int qr) {\r\n        create_ch();\r\n        propagate();\r\n        if (ql == l && qr - 1 == r) return val;\r\n        else if (qr - 1 <= m()) return lch->rquery(ql, qr);\r\n        else if (ql > m()) return rch->rquery(ql, qr);\r\n\r\n        else return lch->rquery(ql, m() + 1) + rch->rquery(m() + 1, qr); // sum\r\n    }\r\n\r\n    friend ostream &operator<<(ostream &os, const Node &node) {\r\n        os << node.l << \"~\" << node.r << \", val: \" << node.val << \" lazy_update: \"\r\n           << node.lazy << endl;\r\n        if (node.l != node.r) os << *(node.lch) << *(node.rch);\r\n        return os;\r\n    }\r\n} *root;\r\n\r\nll n, q;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    cin >> n >> q;\r\n    root = new Node(0, n - 1);\r\n    for (ll i = 0; i < q; ++i) {\r\n        int cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            root->rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << root->rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n}\r\n\r\n"
    },
    {
        "username": "lithops",
        "id": 20496,
        "date": "2020-12-18 12:35:55",
        "code": "//\r\n// Created by Lithops on 2020/12/17.\r\n//\r\n\r\n#include <bits/stdc++.h>\r\n\r\n#define MAXN\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\n//\r\n// Created by Lithops on 2020/12/14.\r\n//\r\n// lazy creation\r\n\r\n#include <bits/stdc++.h>\r\n\r\n#define MAXN\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\nclass Node {\r\n    ll l, r;\r\n    Node *lch = nullptr, *rch = nullptr;\r\n    ll val = 0, lazy = 0;\r\n\r\n    int m() {\r\n        return (l+r)/2;\r\n    }\r\n    void create_ch() {\r\n        if (l != r && lch == nullptr) {\r\n            lch = new Node(l, m());\r\n            rch = new Node(m() + 1, r);\r\n        }\r\n    }\r\n    void propagate() {\r\n        if (lazy == 0) return;\r\n        create_ch();\r\n        val += lazy * (r - l + 1); // lazy sum update\r\n        if (l != r) {\r\n            lch->lazy += lazy; // sum update\r\n            rch->lazy += lazy; // sum update\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\npublic:\r\n    // [_l, _r]\r\n    Node(ll _l, ll _r) : l(_l), r(_r) {\r\n//        m = (l + r) / 2;\r\n//        if (l != r) {\r\n//            lch = new Node(l, m);\r\n//            rch = new Node(m + 1, r);\r\n//        }\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(ll ul, ll ur, ll uv) {\r\n        create_ch();\r\n        propagate();\r\n        if (ul == l && r == ur - 1) lazy += uv;// sum update\r\n        else {\r\n            if (ur - 1 <= m()) lch->rupdate(ul, ur, uv);\r\n            else if (m() < ul) rch->rupdate(ul, ur, uv);\r\n            else {\r\n                lch->rupdate(ul, m() + 1, uv);\r\n                rch->rupdate(m() + 1, ur, uv);\r\n            }\r\n            lch->propagate();\r\n            rch->propagate();\r\n            val = lch->val + rch->val; // sum merge\r\n        }\r\n    }\r\n\r\n    // [ql, qr)\r\n    ll rquery(ll ql, ll qr) {\r\n        create_ch();\r\n        propagate();\r\n        if (ql == l && qr - 1 == r) return val;\r\n        else if (qr - 1 <= m()) return lch->rquery(ql, qr);\r\n        else if (ql > m()) return rch->rquery(ql, qr);\r\n\r\n        else return lch->rquery(ql, m() + 1) + rch->rquery(m() + 1, qr); // sum\r\n    }\r\n\r\n    friend ostream &operator<<(ostream &os, const Node &node) {\r\n        os << node.l << \"~\" << node.r << \", val: \" << node.val << \" lazy_update: \"\r\n           << node.lazy << endl;\r\n        if (node.l != node.r) os << *(node.lch) << *(node.rch);\r\n        return os;\r\n    }\r\n} *root;\r\n\r\nll n, q;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    cin >> n >> q;\r\n    root = new Node(0, n - 1);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            root->rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << root->rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n}\r\n\r\n"
    },
    {
        "username": "lithops",
        "id": 20495,
        "date": "2020-12-18 12:17:32",
        "code": "//\r\n// Created by Lithops on 2020/12/14.\r\n//\r\n// lazy creation\r\n\r\n#include <bits/stdc++.h>\r\n\r\n#define MAXN\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\nclass Node {\r\n    ll l, r, m;\r\n    Node *lch = nullptr, *rch = nullptr;\r\n    ll val = 0, lazy = 0;\r\n\r\n    void create_ch() {\r\n        if (l != r && lch == nullptr) {\r\n            lch = new Node(l, m);\r\n            rch = new Node(m + 1, r);\r\n        }\r\n    }\r\n    void propagate() {\r\n        if (lazy == 0) return;\r\n        create_ch();\r\n        val += lazy * (r - l + 1); // lazy sum update\r\n        if (l != r) {\r\n            lch->lazy += lazy; // sum update\r\n            rch->lazy += lazy; // sum update\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\npublic:\r\n    // [_l, _r]\r\n    Node(ll _l, ll _r) : l(_l), r(_r) {\r\n        m = (l + r) / 2;\r\n//        if (l != r) {\r\n//            lch = new Node(l, m);\r\n//            rch = new Node(m + 1, r);\r\n//        }\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(ll ul, ll ur, ll uv) {\r\n        create_ch();\r\n        propagate();\r\n        if (ul == l && r == ur - 1) lazy += uv;// sum update\r\n        else {\r\n            if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n            else if (m < ul) rch->rupdate(ul, ur, uv);\r\n            else {\r\n                lch->rupdate(ul, m + 1, uv);\r\n                rch->rupdate(m + 1, ur, uv);\r\n            }\r\n            lch->propagate();\r\n            rch->propagate();\r\n            val = lch->val + rch->val; // sum merge\r\n        }\r\n    }\r\n\r\n    // [ql, qr)\r\n    ll rquery(ll ql, ll qr) {\r\n        create_ch();\r\n        propagate();\r\n        if (ql == l && qr - 1 == r) return val;\r\n        else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n        else if (ql > m) return rch->rquery(ql, qr);\r\n\r\n        else return lch->rquery(ql, m + 1) + rch->rquery(m + 1, qr); // sum\r\n    }\r\n\r\n    friend ostream &operator<<(ostream &os, const Node &node) {\r\n        os << node.l << \"~\" << node.r << \", val: \" << node.val << \" lazy_update: \"\r\n           << node.lazy << endl;\r\n        if (node.l != node.r) os << *(node.lch) << *(node.rch);\r\n        return os;\r\n    }\r\n} *root;\r\n\r\nll n, q;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    cin >> n >> q;\r\n    root = new Node(0, n - 1);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            root->rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << root->rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n}"
    },
    {
        "username": "lithops",
        "id": 20492,
        "date": "2020-12-18 12:06:30",
        "code": "//\r\n// Created by Lithops on 2020/12/17.\r\n//\r\n// generalised LazyVersion using template, lazy propagation and lazy creation, best version of all.\r\n// customisable to handle various update and query types. (incl. sum, min, max, product etc.)\r\n// able to lazy create 1e9 elements if constructed by single value constructor, saving both memory and time.\r\n\r\n#include <bits/stdc++.h>\r\n#include <ostream>\r\n\r\n#define MAXN 10007\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\ntemplate<class T>\r\nclass SegTree {\r\n\r\n    class Node {\r\n        int l, r, m;\r\n        Node *lch = nullptr, *rch = nullptr;\r\n        T val, lazy;\r\n        bool updated = true;\r\n        const T &init_v;\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        void modify0(T &a, const T &b) const {\r\n            a = b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void modify(T &a, const T &b) const {\r\n            a += b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        // in reality, used only when lazy-creating a node.\r\n        void lazy_modify0(T &a, const T &b) const {\r\n            a = b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void lazy_modify(T &a, const T &b) const {\r\n            a += b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        T merge(const T &a, const T &b) const {\r\n            return a + b;\r\n        }\r\n\r\n        void update_lazy(const T &new_val) {\r\n            if (updated) modify0(lazy, new_val);\r\n            else modify(lazy, new_val);\r\n            updated = false;\r\n        }\r\n\r\n        void propagate() {\r\n            if (updated) return;\r\n            create_ch();\r\n            lazy_modify(val, lazy);\r\n            if (l != r) {\r\n                lch->update_lazy(lazy);\r\n                rch->update_lazy(lazy);\r\n            }\r\n            updated = true;\r\n        }\r\n\r\n        void create_ch() {\r\n            if (l == r) return;\r\n            if (lch == nullptr) lch = new Node(init_v, l, m);\r\n            if (rch == nullptr) rch = new Node(init_v, m + 1, r);\r\n        }\r\n\r\n    public:\r\n        // [_l, _r]\r\n        // no lazy creation\r\n        template<class IT>\r\n        Node(const IT first, const IT last, int _l, int _r) : l(_l), r(_r), init_v(*first) {\r\n            m = (l + r) / 2;\r\n            if (l == r) val = first[l];\r\n            else {\r\n                lch = new Node(first, last, l, m);\r\n                rch = new Node(first, last, m + 1, r);\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [_l, _r]\r\n        // uses lazy creation\r\n        Node(const T &v, int _l, int _r) : l(_l), r(_r), init_v(v) {\r\n            m = (l + r) / 2;\r\n            lazy_modify0(val, init_v);\r\n        }\r\n\r\n        void pupdate(int up, const T &uv) {\r\n            // assert(pl <= up && up <= pr);\r\n            create_ch();\r\n            propagate();\r\n            if (l == r) update_lazy(uv);\r\n            else {\r\n                if (up <= m) lch->pupdate(up, uv);\r\n                else rch->pupdate(up, uv);\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ul, ur)\r\n        void rupdate(int ul, int ur, const T &uv) {\r\n            // assert(l <= ul && ul < ur && ur <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ul == l && r == ur - 1) update_lazy(uv);\r\n            else {\r\n                if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n                else if (m < ul) rch->rupdate(ul, ur, uv);\r\n                else {\r\n                    lch->rupdate(ul, m + 1, uv);\r\n                    rch->rupdate(m + 1, ur, uv);\r\n                }\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ql, qr)\r\n        T rquery(int ql, int qr) {\r\n            // assert(l <= ql && ql < qr && qr <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ql == l && qr - 1 == r) return val;\r\n            else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n            else if (ql > m) return rch->rquery(ql, qr);\r\n            else return merge(lch->rquery(ql, m + 1), rch->rquery(m + 1, qr));\r\n        }\r\n\r\n        friend ostream &operator<<(ostream &os, const Node &node) {\r\n            os << node.l << \"~\" << node.r << \", val: \" << node.val << \" updated: \" << node.updated << \" lazy_update: \"\r\n               << node.lazy << endl;\r\n            if (node.lch != nullptr) os << *(node.lch);\r\n            if (node.rch != nullptr) os << *(node.rch);\r\n            return os;\r\n        }\r\n\r\n    } *root;\r\n\r\npublic:\r\n    // [first, last)\r\n    template<class IT>\r\n    SegTree(const IT first, const IT last) {\r\n        root = new Node(first, last, 0, last - first - 1);\r\n    }\r\n\r\n    SegTree(int count, const T &v) {\r\n        root = new Node(v, 0, count - 1);\r\n    }\r\n\r\n    void pupdate(int up, const T &new_val) {\r\n        root->pupdate(up, new_val);\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, const T &new_val) {\r\n        root->rupdate(ul, ur, new_val);\r\n    }\r\n\r\n    // [ql, qr)\r\n    T rquery(int ql, int qr) {\r\n        return root->rquery(ql, qr);\r\n    }\r\n\r\n    void print() const {\r\n        cout << *root;\r\n    }\r\n\r\n\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    ll n, q;\r\n    cin >> n >> q;\r\n    SegTree<ll> tree(n, 0);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nint main5() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int n, m;\r\n    int a[MAXN];\r\n\r\n\r\n    cin >> n >> m;\r\n\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cin >> a[i];\r\n    }\r\n\r\n    SegTree<int> tree(a, a + n);\r\n\r\n    for (int i = 0; i < m; ++i) {\r\n        string s;\r\n        cin >> s;\r\n        if (s == \"ru\") {\r\n            int l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l, r, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"p\") {\r\n            tree.print();\r\n        } else if (s == \"pu\") {\r\n            int p, v;\r\n            cin >> p >> v;\r\n            tree.pupdate(p, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"rq\") {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l, r) << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "lithops",
        "id": 20489,
        "date": "2020-12-18 11:46:00",
        "code": "//\r\n// Created by Lithops on 2020/12/17.\r\n//\r\n// generalised LazyVersion using template, lazy propagation and lazy creation, best version of all.\r\n// customisable to handle various update and query types. (incl. sum, min, max, product etc.)\r\n// able to lazy create 1e9 elements if constructed by single value constructor, saving both memory and time.\r\n\r\n#include <bits/stdc++.h>\r\n#include <ostream>\r\n\r\n#define MAXN 10007\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\ntemplate<class T>\r\nclass SegTree {\r\n\r\n    class Node {\r\n        int l, r, m;\r\n        Node *lch = nullptr, *rch = nullptr;\r\n        T val, lazy;\r\n        bool updated = true;\r\n        const SegTree * const tree = nullptr;\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        void modify0(T &a, const T &b) const {\r\n            a = b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void modify(T &a, const T &b) const {\r\n            a += b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        // in reality, used only when lazy-creating a node.\r\n        void lazy_modify0(T &a, const T &b) const {\r\n            a = b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void lazy_modify(T &a, const T &b) const {\r\n            a += b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        T merge(const T &a, const T &b) const {\r\n            return a + b;\r\n        }\r\n\r\n        void update_lazy(const T &new_val) {\r\n            if (updated) modify0(lazy, new_val);\r\n            else modify(lazy, new_val);\r\n            updated = false;\r\n        }\r\n\r\n        void propagate() {\r\n            if (updated) return;\r\n            create_ch();\r\n            lazy_modify(val, lazy);\r\n            if (l != r) {\r\n                lch->update_lazy(lazy);\r\n                rch->update_lazy(lazy);\r\n            }\r\n            updated = true;\r\n        }\r\n\r\n        void create_ch() {\r\n            if (l == r) return;\r\n            if (lch == nullptr) lch = new Node(tree, l, m);\r\n            if (rch == nullptr) rch = new Node(tree, m + 1, r);\r\n        }\r\n\r\n    public:\r\n        // [_l, _r]\r\n        // no lazy creation\r\n        template<class IT>\r\n        Node(const IT first, const IT last, int _l, int _r) : l(_l), r(_r) {\r\n            m = (l + r) / 2;\r\n            if (l == r) val = first[l];\r\n            else {\r\n                lch = new Node(first, last, l, m);\r\n                rch = new Node(first, last, m + 1, r);\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [_l, _r]\r\n        // uses lazy creation\r\n        Node(const SegTree * const _tree, int _l, int _r) : l(_l), r(_r), tree(_tree) {\r\n            m = (l + r) / 2;\r\n            lazy_modify0(val, tree->init_v);\r\n        }\r\n\r\n        void pupdate(int up, const T &uv) {\r\n            // assert(pl <= up && up <= pr);\r\n            create_ch();\r\n            propagate();\r\n            if (l == r) update_lazy(uv);\r\n            else {\r\n                if (up <= m) lch->pupdate(up, uv);\r\n                else rch->pupdate(up, uv);\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ul, ur)\r\n        void rupdate(int ul, int ur, const T &uv) {\r\n            // assert(l <= ul && ul < ur && ur <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ul == l && r == ur - 1) update_lazy(uv);\r\n            else {\r\n                if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n                else if (m < ul) rch->rupdate(ul, ur, uv);\r\n                else {\r\n                    lch->rupdate(ul, m + 1, uv);\r\n                    rch->rupdate(m + 1, ur, uv);\r\n                }\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ql, qr)\r\n        T rquery(int ql, int qr) {\r\n            // assert(l <= ql && ql < qr && qr <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ql == l && qr - 1 == r) return val;\r\n            else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n            else if (ql > m) return rch->rquery(ql, qr);\r\n            else return merge(lch->rquery(ql, m + 1), rch->rquery(m + 1, qr));\r\n        }\r\n\r\n        friend ostream &operator<<(ostream &os, const Node &node) {\r\n            os << node.l << \"~\" << node.r << \", val: \" << node.val << \" updated: \" << node.updated << \" lazy_update: \"\r\n               << node.lazy << endl;\r\n            if (node.lch != nullptr) os << *(node.lch);\r\n            if (node.rch != nullptr) os << *(node.rch);\r\n            return os;\r\n        }\r\n    } *root;\r\n\r\n    T init_v;\r\n\r\npublic:\r\n    // [first, last)\r\n    template<class IT>\r\n    SegTree(const IT first, const IT last) {\r\n        root = new Node(first, last, 0, last - first - 1);\r\n    }\r\n\r\n    SegTree(int count, const T &v) : init_v(v) {\r\n        root = new Node(this, 0, count - 1);\r\n    }\r\n\r\n    void pupdate(int up, const T &new_val) {\r\n        root->pupdate(up, new_val);\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, const T &new_val) {\r\n        root->rupdate(ul, ur, new_val);\r\n    }\r\n\r\n    // [ql, qr)\r\n    T rquery(int ql, int qr) {\r\n        return root->rquery(ql, qr);\r\n    }\r\n\r\n    void print() const {\r\n        cout << *root;\r\n    }\r\n\r\n\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    ll n, q;\r\n    cin >> n >> q;\r\n    SegTree<ll> tree(n, 0);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nint main5() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int n, m;\r\n    int a[MAXN];\r\n\r\n\r\n    cin >> n >> m;\r\n\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cin >> a[i];\r\n    }\r\n\r\n    SegTree<int> tree(a, a + n);\r\n\r\n    for (int i = 0; i < m; ++i) {\r\n        string s;\r\n        cin >> s;\r\n        if (s == \"ru\") {\r\n            int l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l, r, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"p\") {\r\n            tree.print();\r\n        } else if (s == \"pu\") {\r\n            int p, v;\r\n            cin >> p >> v;\r\n            tree.pupdate(p, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"rq\") {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l, r) << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "lithops",
        "id": 20486,
        "date": "2020-12-18 11:44:19",
        "code": "//\r\n// Created by Lithops on 2020/12/17.\r\n//\r\n// generalised LazyVersion using template, lazy propagation and lazy creation, best version of all.\r\n// customisable to handle various update and query types. (incl. sum, min, max, product etc.)\r\n// able to lazy create 1e9 elements if constructed by single value constructor, saving both memory and time.\r\n\r\n#include <bits/stdc++.h>\r\n#include <ostream>\r\n\r\n#define MAXN 10007\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\ntemplate<class T>\r\nclass SegTree {\r\n\r\n    class Node {\r\n        int l, r, m;\r\n        Node *lch = nullptr, *rch = nullptr;\r\n        T val, lazy;\r\n        bool updated = true;\r\n        const SegTree * const tree = nullptr;\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        void modify0(T &a, const T &b) const {\r\n            a = b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void modify(T &a, const T &b) const {\r\n            a += b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        // in reality, used only when lazy-creating a node.\r\n        void lazy_modify0(T &a, const T &b) const {\r\n            a = b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void lazy_modify(T &a, const T &b) const {\r\n            a += b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        T merge(const T &a, const T &b) const {\r\n            return a + b;\r\n        }\r\n\r\n        void update_lazy(const T &new_val) {\r\n            if (updated) modify0(lazy, new_val);\r\n            else modify(lazy, new_val);\r\n            updated = false;\r\n        }\r\n\r\n        void propagate() {\r\n            if (updated) return;\r\n            create_ch();\r\n            lazy_modify(val, lazy);\r\n            if (l != r) {\r\n                lch->update_lazy(lazy);\r\n                rch->update_lazy(lazy);\r\n            }\r\n            updated = true;\r\n        }\r\n\r\n        void create_ch() {\r\n            if (l == r) return;\r\n            if (lch == nullptr) lch = new Node(tree, l, m);\r\n            if (rch == nullptr) rch = new Node(tree, m + 1, r);\r\n        }\r\n\r\n    public:\r\n        // [_l, _r]\r\n        // no lazy creation\r\n        template<class IT>\r\n        Node(const IT first, const IT last, int _l, int _r) : l(_l), r(_r) {\r\n            m = (l + r) / 2;\r\n            if (l == r) val = first[l];\r\n            else {\r\n                lch = new Node(first, last, l, m);\r\n                rch = new Node(first, last, m + 1, r);\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [_l, _r]\r\n        // uses lazy creation\r\n        Node(const SegTree * const _tree, int _l, int _r) : l(_l), r(_r), tree(_tree) {\r\n            m = (l + r) / 2;\r\n            lazy_modify0(val, tree->init_v);\r\n        }\r\n\r\n        void pupdate(int up, const T &uv) {\r\n            // assert(pl <= up && up <= pr);\r\n            create_ch();\r\n            propagate();\r\n            if (l == r) update_lazy(uv);\r\n            else {\r\n                if (up <= m) lch->pupdate(up, uv);\r\n                else rch->pupdate(up, uv);\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ul, ur)\r\n        void rupdate(int ul, int ur, const T &uv) {\r\n            // assert(l <= ul && ul < ur && ur <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ul == l && r == ur - 1) update_lazy(uv);\r\n            else {\r\n                if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n                else if (m < ul) rch->rupdate(ul, ur, uv);\r\n                else {\r\n                    lch->rupdate(ul, m + 1, uv);\r\n                    rch->rupdate(m + 1, ur, uv);\r\n                }\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ql, qr)\r\n        T rquery(int ql, int qr) {\r\n            // assert(l <= ql && ql < qr && qr <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ql == l && qr - 1 == r) return val;\r\n            else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n            else if (ql > m) return rch->rquery(ql, qr);\r\n            else return merge(lch->rquery(ql, m + 1), rch->rquery(m + 1, qr));\r\n        }\r\n\r\n        friend ostream &operator<<(ostream &os, const Node &node) {\r\n            os << node.l << \"~\" << node.r << \", val: \" << node.val << \" updated: \" << node.updated << \" lazy_update: \"\r\n               << node.lazy << endl;\r\n            if (node.lch != nullptr) os << *(node.lch);\r\n            if (node.rch != nullptr) os << *(node.rch);\r\n            return os;\r\n        }\r\n    } *root;\r\n\r\n    T init_v;\r\n\r\npublic:\r\n    // [first, last)\r\n    template<class IT>\r\n    SegTree(const IT first, const IT last) {\r\n        root = new Node(first, last, 0, last - first - 1);\r\n    }\r\n\r\n    SegTree(int count, const T &v) : init_v(v) {\r\n        root = new Node(this, 0, count - 1);\r\n    }\r\n\r\n    void pupdate(int up, const T &new_val) {\r\n        root->pupdate(up, new_val);\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, const T &new_val) {\r\n        root->rupdate(ul, ur, new_val);\r\n    }\r\n\r\n    // [ql, qr)\r\n    T rquery(int ql, int qr) {\r\n        return root->rquery(ql, qr);\r\n    }\r\n\r\n    void print() const {\r\n        cout << *root;\r\n    }\r\n\r\n\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    ll n, q;\r\n    cin >> n >> q;\r\n    SegTree<ll> tree(n, 0);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nint main5() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int n, m;\r\n    int a[MAXN];\r\n\r\n\r\n    cin >> n >> m;\r\n\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cin >> a[i];\r\n    }\r\n\r\n    SegTree<int> tree(a, a + n);\r\n\r\n    for (int i = 0; i < m; ++i) {\r\n        string s;\r\n        cin >> s;\r\n        if (s == \"ru\") {\r\n            int l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l, r, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"p\") {\r\n            tree.print();\r\n        } else if (s == \"pu\") {\r\n            int p, v;\r\n            cin >> p >> v;\r\n            tree.pupdate(p, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"rq\") {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l, r) << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "lithops",
        "id": 20256,
        "date": "2020-12-17 15:02:26",
        "code": "//\r\n// Created by Lithops on 2020/11/19.\r\n//\r\n// Segment Tree implementation using pointers and lazy propagation, encapsulated as a class\r\n\r\n#include <bits/stdc++.h>\r\n#include <ostream>\r\n\r\n#define MAXN 1002\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\ntemplate<class T>\r\nclass SegTree {\r\n\r\n    class Node {\r\n        int l, r, m;\r\n        Node *lch = nullptr, *rch = nullptr;\r\n        T val, lazy;\r\n        bool updated = true;\r\n        T init_v;\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        void modify0(T &a, const T &b) const {\r\n            a = b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void modify(T &a, const T &b) const {\r\n            a += b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        // in reality, used only when lazy-creating a node.\r\n        void lazy_modify0(T &a, const T &b) const {\r\n            a = b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void lazy_modify(T &a, const T &b) const {\r\n            a += b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        T merge(const T &a, const T &b) const {\r\n            return a + b;\r\n        }\r\n\r\n        void update_lazy(const T &new_val) {\r\n            if (updated) modify0(lazy, new_val);\r\n            else modify(lazy, new_val);\r\n            updated = false;\r\n        }\r\n\r\n        void propagate() {\r\n            if (updated) return;\r\n            create_ch();\r\n            lazy_modify(val, lazy);\r\n            if (l != r) {\r\n                lch->update_lazy(lazy);\r\n                rch->update_lazy(lazy);\r\n            }\r\n            updated = true;\r\n        }\r\n\r\n        void create_ch() {\r\n            if (l == r) return;\r\n            if (lch == nullptr) lch = new Node(init_v, l, m);\r\n            if (rch == nullptr) rch = new Node(init_v, m + 1, r);\r\n        }\r\n\r\n    public:\r\n        // [_l, _r]\r\n        // no lazy creation\r\n        template<class IT>\r\n        Node(const IT first, const IT last, int _l, int _r) : l(_l), r(_r) {\r\n            m = (l + r) / 2;\r\n            if (l == r) val = first[l];\r\n            else {\r\n                lch = new Node(first, last, l, m);\r\n                rch = new Node(first, last, m + 1, r);\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [_l, _r]\r\n        // uses lazy creation\r\n        Node(const T &v, int _l, int _r) : l(_l), r(_r), init_v(v) {\r\n            m = (l + r) / 2;\r\n            lazy_modify0(val, init_v);\r\n        }\r\n\r\n        void pupdate(int up, const T &uv) {\r\n            // assert(pl <= up && up <= pr);\r\n            create_ch();\r\n            propagate();\r\n            if (l == r) update_lazy(uv);\r\n            else {\r\n                if (up <= m) lch->pupdate(up, uv);\r\n                else rch->pupdate(up, uv);\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ul, ur)\r\n        void rupdate(int ul, int ur, const T &uv) {\r\n            // assert(l <= ul && ul < ur && ur <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ul == l && r == ur - 1) update_lazy(uv);\r\n            else {\r\n                if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n                else if (m < ul) rch->rupdate(ul, ur, uv);\r\n                else {\r\n                    lch->rupdate(ul, m + 1, uv);\r\n                    rch->rupdate(m + 1, ur, uv);\r\n                }\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ql, qr)\r\n        T rquery(int ql, int qr) {\r\n            // assert(l <= ql && ql < qr && qr <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ql == l && qr - 1 == r) return val;\r\n            else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n            else if (ql > m) return rch->rquery(ql, qr);\r\n            else return merge(lch->rquery(ql, m + 1), rch->rquery(m + 1, qr));\r\n        }\r\n\r\n        friend ostream &operator<<(ostream &os, const Node &node) {\r\n            os << node.l << \"~\" << node.r << \", val: \" << node.val << \" updated: \" << node.updated << \" lazy_update: \"\r\n               << node.lazy << endl;\r\n            if (node.lch != nullptr) os << *(node.lch);\r\n            if (node.rch != nullptr) os << *(node.rch);\r\n            return os;\r\n        }\r\n    } *root;\r\n\r\npublic:\r\n    // [first, last)\r\n    template<class IT>\r\n    SegTree(const IT first, const IT last) {\r\n        root = new Node(first, last, 0, last - first - 1);\r\n    }\r\n\r\n    SegTree(int count, const T &v) {\r\n        root = new Node(v, 0, count - 1);\r\n    }\r\n\r\n    void pupdate(int up, const T &new_val) {\r\n        root->pupdate(up, new_val);\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, const T &new_val) {\r\n        root->rupdate(ul, ur, new_val);\r\n    }\r\n\r\n    // [ql, qr)\r\n    T rquery(int ql, int qr) {\r\n        return root->rquery(ql, qr);\r\n    }\r\n\r\n    void print() const {\r\n        cout << *root;\r\n    }\r\n\r\n\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    ll n, q;\r\n    cin >> n >> q;\r\n    SegTree<ll> tree(n, 0);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n//\r\n//int main2() {\r\n//    ios::sync_with_stdio(false);\r\n//    cin.tie(nullptr);\r\n//\r\n//    int n, m;\r\n//    int a[MAXN];\r\n//\r\n//\r\n//    cin >> n >> m;\r\n//\r\n//    SegTree<int> tree(n, 0);\r\n//\r\n//    for (int i = 0; i < n; ++i) {\r\n//        cin >> a[i];\r\n//        tree.pupdate(i, a[i]);\r\n//    }\r\n//\r\n//\r\n//    for (int i = 0; i < m; ++i) {\r\n//        string s;\r\n//        cin >> s;\r\n//        if (s == \"ru\") {\r\n//            int l, r, v;\r\n//            cin >> l >> r >> v;\r\n//            tree.rupdate(l, r, v);\r\n////            tree.print();\r\n////            cout << endl;\r\n//\r\n//        } else if (s == \"p\") {\r\n//            tree.print();\r\n//        } else if (s == \"pu\") {\r\n//            int p, v;\r\n//            cin >> p >> v;\r\n//            tree.pupdate(p, v);\r\n////            tree.print();\r\n////            cout << endl;\r\n//\r\n//        } else if (s == \"rq\") {\r\n//            int l, r;\r\n//            cin >> l >> r;\r\n//            cout << tree.rquery(l, r) << endl;\r\n//        }\r\n//    }\r\n//    return 0;\r\n//}"
    },
    {
        "username": "lithops",
        "id": 20255,
        "date": "2020-12-17 15:01:54",
        "code": "//\r\n// Created by Lithops on 2020/11/19.\r\n//\r\n// Segment Tree implementation using pointers and lazy propagation, encapsulated as a class\r\n\r\n#include <bits/stdc++.h>\r\n#include <ostream>\r\n\r\n#define MAXN 1002\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\ntemplate<class T>\r\nclass SegTree {\r\n\r\n    class Node {\r\n        int l, r, m;\r\n        Node *lch = nullptr, *rch = nullptr;\r\n        T val, lazy;\r\n        bool updated = true;\r\n        T init_v;\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        void modify0(T &a, const T &b) const {\r\n            a = b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void modify(T &a, const T &b) const {\r\n            a += b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        // in reality, used only when lazy-creating a node.\r\n        void lazy_modify0(T &a, const T &b) const {\r\n            a = b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void lazy_modify(T &a, const T &b) const {\r\n            a += b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        T merge(const T &a, const T &b) const {\r\n            return a + b;\r\n        }\r\n\r\n        void update_lazy(const T &new_val) {\r\n            if (updated) modify0(lazy, new_val);\r\n            else modify(lazy, new_val);\r\n            updated = false;\r\n        }\r\n\r\n        void propagate() {\r\n            if (updated) return;\r\n            create_ch();\r\n            lazy_modify(val, lazy);\r\n            if (l != r) {\r\n                lch->update_lazy(lazy);\r\n                rch->update_lazy(lazy);\r\n            }\r\n            updated = true;\r\n        }\r\n\r\n        void create_ch() {\r\n            if (l == r) return;\r\n            if (lch == nullptr) lch = new Node(init_v, l, m);\r\n            if (rch == nullptr) rch = new Node(init_v, m + 1, r);\r\n        }\r\n\r\n    public:\r\n        // [_l, _r]\r\n        // no lazy creation\r\n        template<class IT>\r\n        Node(const IT first, const IT last, int _l, int _r) : l(_l), r(_r) {\r\n            m = (l + r) / 2;\r\n            if (l == r) val = first[l];\r\n            else {\r\n                lch = new Node(first, last, l, m);\r\n                rch = new Node(first, last, m + 1, r);\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [_l, _r]\r\n        // uses lazy creation\r\n        Node(const T &v, int _l, int _r) : l(_l), r(_r), init_v(v) {\r\n            m = (l + r) / 2;\r\n            lazy_modify0(val, init_v);\r\n        }\r\n\r\n        void pupdate(int up, const T &uv) {\r\n            // assert(pl <= up && up <= pr);\r\n            create_ch();\r\n            propagate();\r\n            if (l == r) update_lazy(uv);\r\n            else {\r\n                if (up <= m) lch->pupdate(up, uv);\r\n                else rch->pupdate(up, uv);\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ul, ur)\r\n        void rupdate(int ul, int ur, const T &uv) {\r\n            // assert(l <= ul && ul < ur && ur <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ul == l && r == ur - 1) update_lazy(uv);\r\n            else {\r\n                if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n                else if (m < ul) rch->rupdate(ul, ur, uv);\r\n                else {\r\n                    lch->rupdate(ul, m + 1, uv);\r\n                    rch->rupdate(m + 1, ur, uv);\r\n                }\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ql, qr)\r\n        T rquery(int ql, int qr) {\r\n            // assert(l <= ql && ql < qr && qr <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ql == l && qr - 1 == r) return val;\r\n            else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n            else if (ql > m) return rch->rquery(ql, qr);\r\n            else return merge(lch->rquery(ql, m + 1), rch->rquery(m + 1, qr));\r\n        }\r\n\r\n        friend ostream &operator<<(ostream &os, const Node &node) {\r\n            os << node.l << \"~\" << node.r << \", val: \" << node.val << \" updated: \" << node.updated << \" lazy_update: \"\r\n               << node.lazy << endl;\r\n            if (node.lch != nullptr) os << *(node.lch);\r\n            if (node.rch != nullptr) os << *(node.rch);\r\n            return os;\r\n        }\r\n    } *root;\r\n\r\npublic:\r\n    // [first, last)\r\n    template<class IT>\r\n    SegTree(const IT first, const IT last) {\r\n        root = new Node(first, last, 0, last - first - 1);\r\n    }\r\n\r\n    SegTree(int count, const T &v) {\r\n        root = new Node(v, 0, count - 1);\r\n    }\r\n\r\n    void pupdate(int up, const T &new_val) {\r\n        root->pupdate(up, new_val);\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, const T &new_val) {\r\n        root->rupdate(ul, ur, new_val);\r\n    }\r\n\r\n    // [ql, qr)\r\n    T rquery(int ql, int qr) {\r\n        return root->rquery(ql, qr);\r\n    }\r\n\r\n    void print() const {\r\n        cout << *root;\r\n    }\r\n\r\n\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    ll n, q;\r\n    cin >> n >> q;\r\n    SegTree<ll> tree(n, 0);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nint main2() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int n, m;\r\n    int a[MAXN];\r\n\r\n\r\n    cin >> n >> m;\r\n\r\n    SegTree<int> tree(n, 0);\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cin >> a[i];\r\n        tree.pupdate(i, a[i]);\r\n    }\r\n\r\n\r\n    for (int i = 0; i < m; ++i) {\r\n        string s;\r\n        cin >> s;\r\n        if (s == \"ru\") {\r\n            int l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l, r, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"p\") {\r\n            tree.print();\r\n        } else if (s == \"pu\") {\r\n            int p, v;\r\n            cin >> p >> v;\r\n            tree.pupdate(p, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"rq\") {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l, r) << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "lithops",
        "id": 20251,
        "date": "2020-12-17 14:57:11",
        "code": "//\r\n// Created by Lithops on 2020/11/19.\r\n//\r\n// Segment Tree implementation using pointers and lazy propagation, encapsulated as a class\r\n\r\n#include <bits/stdc++.h>\r\n#include <ostream>\r\n\r\n#define MAXN 1002\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\ntemplate<class T>\r\nclass SegTree {\r\n\r\n    class Node {\r\n        int l, r, m;\r\n        Node *lch = nullptr, *rch = nullptr;\r\n        T val, lazy;\r\n        bool updated = true;\r\n        T init_v;\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        void modify0(T &a, const T &b) const {\r\n            a = b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void modify(T &a, const T &b) const {\r\n            a += b;\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is invalid\r\n        // in reality, used only when lazy-creating a node.\r\n        void lazy_modify0(T &a, const T &b) const {\r\n            a = b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        // used when value of a is valid\r\n        void lazy_modify(T &a, const T &b) const {\r\n            a += b * (r - l + 1);\r\n        }\r\n\r\n        // customisable\r\n        T merge(const T a, const T &b) const {\r\n            return a + b;\r\n        }\r\n\r\n        void update_lazy(const T new_val) {\r\n            if (updated) modify0(lazy, new_val);\r\n            else modify(lazy, new_val);\r\n            updated = false;\r\n        }\r\n\r\n        void propagate() {\r\n            if (updated) return;\r\n            create_ch();\r\n            lazy_modify(val, lazy);\r\n            if (l != r) {\r\n                lch->update_lazy(lazy);\r\n                rch->update_lazy(lazy);\r\n            }\r\n            updated = true;\r\n        }\r\n\r\n        void create_ch() {\r\n            if (l == r) return;\r\n            if (lch == nullptr) lch = new Node(init_v, l, m);\r\n            if (rch == nullptr) rch = new Node(init_v, m + 1, r);\r\n        }\r\n\r\n    public:\r\n        // [_l, _r]\r\n        // no lazy creation\r\n        template<class IT>\r\n        Node(const IT first, const IT last, int _l, int _r) : l(_l), r(_r) {\r\n            m = (l + r) / 2;\r\n            if (l == r) val = first[l];\r\n            else {\r\n                lch = new Node(first, last, l, m);\r\n                rch = new Node(first, last, m + 1, r);\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [_l, _r]\r\n        // uses lazy creation\r\n        Node(const T v, int _l, int _r) : l(_l), r(_r), init_v(v) {\r\n            m = (l + r) / 2;\r\n            lazy_modify0(val, init_v);\r\n        }\r\n\r\n        void pupdate(int up, T uv) {\r\n            // assert(pl <= up && up <= pr);\r\n            create_ch();\r\n            propagate();\r\n            if (l == r) update_lazy(uv);\r\n            else {\r\n                if (up <= m) lch->pupdate(up, uv);\r\n                else rch->pupdate(up, uv);\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ul, ur)\r\n        void rupdate(int ul, int ur, T uv) {\r\n            // assert(l <= ul && ul < ur && ur <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ul == l && r == ur - 1) update_lazy(uv);\r\n            else {\r\n                if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n                else if (m < ul) rch->rupdate(ul, ur, uv);\r\n                else {\r\n                    lch->rupdate(ul, m + 1, uv);\r\n                    rch->rupdate(m + 1, ur, uv);\r\n                }\r\n                lch->propagate();\r\n                rch->propagate();\r\n                val = merge(lch->val, rch->val);\r\n            }\r\n        }\r\n\r\n        // [ql, qr)\r\n        T rquery(int ql, int qr) {\r\n            // assert(l <= ql && ql < qr && qr <= r + 1);\r\n            create_ch();\r\n            propagate();\r\n            if (ql == l && qr - 1 == r) return val;\r\n            else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n            else if (ql > m) return rch->rquery(ql, qr);\r\n            else return merge(lch->rquery(ql, m + 1), rch->rquery(m + 1, qr));\r\n        }\r\n\r\n        friend ostream &operator<<(ostream &os, const Node &node) {\r\n            os << node.l << \"~\" << node.r << \", val: \" << node.val << \" updated: \" << node.updated << \" lazy_update: \"\r\n               << node.lazy << endl;\r\n            if (node.lch != nullptr) os << *(node.lch);\r\n            if (node.rch != nullptr) os << *(node.rch);\r\n            return os;\r\n        }\r\n    } *root;\r\n\r\npublic:\r\n    // [first, last)\r\n    template<class IT>\r\n    SegTree(const IT first, const IT last) {\r\n        root = new Node(first, last, 0, last - first - 1);\r\n    }\r\n\r\n    SegTree(int count, const T v) {\r\n        root = new Node(v, 0, count - 1);\r\n    }\r\n\r\n    void pupdate(int up, const T new_val) {\r\n        root->pupdate(up, new_val);\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(int ul, int ur, const T new_val) {\r\n        root->rupdate(ul, ur, new_val);\r\n    }\r\n\r\n    // [ql, qr)\r\n    T rquery(int ql, int qr) {\r\n        return root->rquery(ql, qr);\r\n    }\r\n\r\n    void print() const {\r\n        cout << *root;\r\n    }\r\n\r\n\r\n};\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    ll n, q;\r\n    cin >> n >> q;\r\n    SegTree<ll> tree(n, 0);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nint main2() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    int n, m;\r\n    int a[MAXN];\r\n\r\n\r\n    cin >> n >> m;\r\n\r\n    SegTree<int> tree(n, 0);\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cin >> a[i];\r\n        tree.pupdate(i, a[i]);\r\n    }\r\n\r\n\r\n    for (int i = 0; i < m; ++i) {\r\n        string s;\r\n        cin >> s;\r\n        if (s == \"ru\") {\r\n            int l, r, v;\r\n            cin >> l >> r >> v;\r\n            tree.rupdate(l, r, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"p\") {\r\n            tree.print();\r\n        } else if (s == \"pu\") {\r\n            int p, v;\r\n            cin >> p >> v;\r\n            tree.pupdate(p, v);\r\n//            tree.print();\r\n//            cout << endl;\r\n\r\n        } else if (s == \"rq\") {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            cout << tree.rquery(l, r) << endl;\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "lithops",
        "id": 19975,
        "date": "2020-12-16 19:57:23",
        "code": "//\r\n// Created by Lithops on 2020/12/14.\r\n//\r\n// lazy creation\r\n\r\n#include <bits/stdc++.h>\r\n\r\n#define MAXN\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\nclass Node {\r\n    ll l, r, m;\r\n    Node *lch = nullptr, *rch = nullptr;\r\n    ll val = 0, lazy = 0;\r\n\r\n    void create_ch() {\r\n        if (l != r && lch == nullptr) {\r\n            lch = new Node(l, m);\r\n            rch = new Node(m + 1, r);\r\n        }\r\n    }\r\n    void propagate() {\r\n        create_ch();\r\n        if (lazy == 0) return;\r\n        val += lazy * (r - l + 1); // lazy sum update\r\n        if (l != r) {\r\n            lch->lazy += lazy; // sum update\r\n            rch->lazy += lazy; // sum update\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\npublic:\r\n    // [_l, _r]\r\n    Node(ll _l, ll _r) : l(_l), r(_r) {\r\n        m = (l + r) / 2;\r\n//        if (l != r) {\r\n//            lch = new Node(l, m);\r\n//            rch = new Node(m + 1, r);\r\n//        }\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(ll ul, ll ur, ll uv) {\r\n        //create_ch();\r\n        propagate();\r\n        if (ul == l && r == ur - 1) lazy += uv;// sum update\r\n        else {\r\n            if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n            else if (m < ul) rch->rupdate(ul, ur, uv);\r\n            else {\r\n                lch->rupdate(ul, m + 1, uv);\r\n                rch->rupdate(m + 1, ur, uv);\r\n            }\r\n            lch->propagate();\r\n            rch->propagate();\r\n            val = lch->val + rch->val; // sum merge\r\n        }\r\n    }\r\n\r\n    // [ql, qr)\r\n    ll rquery(ll ql, ll qr) {\r\n        //create_ch();\r\n        propagate();\r\n        if (ql == l && qr - 1 == r) return val;\r\n        else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n        else if (ql > m) return rch->rquery(ql, qr);\r\n\r\n        else return lch->rquery(ql, m + 1) + rch->rquery(m + 1, qr); // sum\r\n    }\r\n\r\n    friend ostream &operator<<(ostream &os, const Node &node) {\r\n        os << node.l << \"~\" << node.r << \", val: \" << node.val << \" lazy_update: \"\r\n           << node.lazy << endl;\r\n        if (node.l != node.r) os << *(node.lch) << *(node.rch);\r\n        return os;\r\n    }\r\n} *root;\r\n\r\nll n, q;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    cin >> n >> q;\r\n    root = new Node(0, n - 1);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            root->rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << root->rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n}"
    },
    {
        "username": "lithops",
        "id": 19973,
        "date": "2020-12-16 19:54:11",
        "code": "//\r\n// Created by Lithops on 2020/12/14.\r\n//\r\n// lazy creation\r\n\r\n#include <bits/stdc++.h>\r\n\r\n#define MAXN\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\nclass Node {\r\n    ll l, r, m;\r\n    Node *lch = nullptr, *rch = nullptr;\r\n    ll val = 0, lazy = 0;\r\n\r\n    void create_ch() {\r\n        if (l != r && lch == nullptr) {\r\n            lch = new Node(l, m);\r\n            rch = new Node(m + 1, r);\r\n        }\r\n    }\r\n    void propagate() {\r\n        if (lazy == 0) return;\r\n        create_ch();\r\n        val += lazy * (r - l + 1); // lazy sum update\r\n        if (l != r) {\r\n            lch->lazy += lazy; // sum update\r\n            rch->lazy += lazy; // sum update\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\npublic:\r\n    // [_l, _r]\r\n    Node(ll _l, ll _r) : l(_l), r(_r) {\r\n        m = (l + r) / 2;\r\n//        if (l != r) {\r\n//            lch = new Node(l, m);\r\n//            rch = new Node(m + 1, r);\r\n//        }\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(ll ul, ll ur, ll uv) {\r\n        create_ch();\r\n        propagate();\r\n        if (ul == l && r == ur - 1) lazy += uv;// sum update\r\n        else {\r\n            if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n            else if (m < ul) rch->rupdate(ul, ur, uv);\r\n            else {\r\n                lch->rupdate(ul, m + 1, uv);\r\n                rch->rupdate(m + 1, ur, uv);\r\n            }\r\n            lch->propagate();\r\n            rch->propagate();\r\n            val = lch->val + rch->val; // sum merge\r\n        }\r\n    }\r\n\r\n    // [ql, qr)\r\n    ll rquery(ll ql, ll qr) {\r\n        create_ch();\r\n        propagate();\r\n        if (ql == l && qr - 1 == r) return val;\r\n        else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n        else if (ql > m) return rch->rquery(ql, qr);\r\n\r\n        else return lch->rquery(ql, m + 1) + rch->rquery(m + 1, qr); // sum\r\n    }\r\n\r\n    friend ostream &operator<<(ostream &os, const Node &node) {\r\n        os << node.l << \"~\" << node.r << \", val: \" << node.val << \" lazy_update: \"\r\n           << node.lazy << endl;\r\n        if (node.l != node.r) os << *(node.lch) << *(node.rch);\r\n        return os;\r\n    }\r\n} *root;\r\n\r\nll n, q;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    cin >> n >> q;\r\n    root = new Node(0, n - 1);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            root->rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << root->rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n}"
    },
    {
        "username": "lithops",
        "id": 19962,
        "date": "2020-12-16 19:32:55",
        "code": "//\r\n// Created by Lithops on 2020/12/14.\r\n//\r\n// lazy creation\r\n\r\n#include <bits/stdc++.h>\r\n\r\n#define MAXN\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\nclass Node {\r\n    ll l, r, m;\r\n    Node *lch = nullptr, *rch = nullptr;\r\n    ll val = 0, lazy = 0;\r\n\r\n    void create_ch() {\r\n        if (l != r && lch == nullptr) {\r\n            lch = new Node(l, m);\r\n            rch = new Node(m + 1, r);\r\n        }\r\n    }\r\n    void propagate() {\r\n        if (lazy == 0) return;\r\n        create_ch();\r\n        val += lazy * (r - l + 1); // lazy sum update\r\n        if (l != r) {\r\n            lch->lazy += lazy; // sum update\r\n            rch->lazy += lazy; // sum update\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\npublic:\r\n    // [_l, _r]\r\n    Node(ll _l, ll _r) : l(_l), r(_r) {\r\n        m = (l + r) / 2;\r\n//        if (l != r) {\r\n//            lch = new Node(l, m);\r\n//            rch = new Node(m + 1, r);\r\n//        }\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(ll ul, ll ur, ll uv) {\r\n        create_ch();\r\n        propagate();\r\n        if (ul == l && r == ur - 1) lazy += uv;// sum update\r\n        else {\r\n            if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n            else if (m < ul) rch->rupdate(ul, ur, uv);\r\n            else {\r\n                lch->rupdate(ul, m + 1, uv);\r\n                rch->rupdate(m + 1, ur, uv);\r\n            }\r\n            lch->propagate();\r\n            rch->propagate();\r\n            val = lch->val + rch->val; // sum merge\r\n        }\r\n    }\r\n\r\n    // [ql, qr)\r\n    ll rquery(ll ql, ll qr) {\r\n        create_ch();\r\n        propagate();\r\n        if (ql == l && qr - 1 == r) return val;\r\n        else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n        else if (ql > m) return rch->rquery(ql, qr);\r\n\r\n        else return lch->rquery(ql, m + 1) + rch->rquery(m + 1, qr); // sum\r\n    }\r\n\r\n    friend ostream &operator<<(ostream &os, const Node &node) {\r\n        os << node.l << \"~\" << node.r << \", val: \" << node.val << \" lazy_update: \"\r\n           << node.lazy << endl;\r\n        if (node.l != node.r) os << *(node.lch) << *(node.rch);\r\n        return os;\r\n    }\r\n} *root;\r\n\r\nll n, q;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    cin >> n >> q;\r\n    root = new Node(0, n - 1);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            root->rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << root->rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n}"
    },
    {
        "username": "lithops",
        "id": 19955,
        "date": "2020-12-16 19:29:37",
        "code": "//\r\n// Created by Lithops on 2020/12/14.\r\n//\r\n// lazy creation\r\n\r\n#include <bits/stdc++.h>\r\n\r\n#define MAXN\r\n#define INF 0x3f3f3f3f\r\n#define ll long long\r\n\r\nusing namespace std;\r\n\r\nclass Node {\r\n    ll l, r, m;\r\n    Node *lch = nullptr, *rch = nullptr;\r\n    ll val = 0, lazy = 0;\r\n\r\n    void propagate() {\r\n        if (lazy == 0) return;\r\n        if (l != r && lch == nullptr) {\r\n            lch = new Node(l, m);\r\n            rch = new Node(m + 1, r);\r\n        }\r\n        val += lazy * (r - l + 1); // lazy sum update\r\n        if (l != r) {\r\n            lch->lazy += lazy; // sum update\r\n            rch->lazy += lazy; // sum update\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\npublic:\r\n    // [_l, _r]\r\n    Node(ll _l, ll _r) : l(_l), r(_r) {\r\n        m = (l + r) / 2;\r\n//        if (l != r) {\r\n//            lch = new Node(l, m);\r\n//            rch = new Node(m + 1, r);\r\n//        }\r\n    }\r\n\r\n    // [ul, ur)\r\n    void rupdate(ll ul, ll ur, ll uv) {\r\n        if (l != r && lch == nullptr) {\r\n            lch = new Node(l, m);\r\n            rch = new Node(m + 1, r);\r\n            assert(lch != nullptr && rch != nullptr);\r\n        }\r\n        propagate();\r\n        if (ul == l && r == ur - 1) lazy += uv;// sum update\r\n        else {\r\n            if (ur - 1 <= m) lch->rupdate(ul, ur, uv);\r\n            else if (m < ul) rch->rupdate(ul, ur, uv);\r\n            else {\r\n                lch->rupdate(ul, m + 1, uv);\r\n                rch->rupdate(m + 1, ur, uv);\r\n            }\r\n            lch->propagate();\r\n            rch->propagate();\r\n            val = lch->val + rch->val; // sum merge\r\n        }\r\n    }\r\n\r\n    // [ql, qr)\r\n    ll rquery(ll ql, ll qr) {\r\n        if (l != r && lch == nullptr) {\r\n            lch = new Node(l, m);\r\n            rch = new Node(m + 1, r);\r\n        }\r\n        propagate();\r\n        if (ql == l && qr - 1 == r) return val;\r\n        else if (qr - 1 <= m) return lch->rquery(ql, qr);\r\n        else if (ql > m) return rch->rquery(ql, qr);\r\n\r\n        else return lch->rquery(ql, m + 1) + rch->rquery(m + 1, qr); // sum\r\n    }\r\n\r\n    friend ostream &operator<<(ostream &os, const Node &node) {\r\n        os << node.l << \"~\" << node.r << \", val: \" << node.val << \" lazy_update: \"\r\n           << node.lazy << endl;\r\n        if (node.l != node.r) os << *(node.lch) << *(node.rch);\r\n        return os;\r\n    }\r\n} *root;\r\n\r\nll n, q;\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(nullptr);\r\n\r\n    cin >> n >> q;\r\n    root = new Node(0, n - 1);\r\n    for (ll i = 0; i < q; ++i) {\r\n        ll cmd;\r\n        cin >> cmd;\r\n        if (cmd == 1) {\r\n            ll l, r, v;\r\n            cin >> l >> r >> v;\r\n            root->rupdate(l - 1, r, v);\r\n        } else {\r\n            ll l, r;\r\n            cin >> l >> r;\r\n            cout << root->rquery(l - 1, r) << endl;\r\n        }\r\n\r\n    }\r\n}"
    },
    {
        "username": "penguin",
        "id": 19817,
        "date": "2020-12-16 17:05:07",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node\r\n{\r\n    long long s, e, m; //range is [s,e], m is the middle point\r\n    long long val = 0; //sum of [s,e]\r\n    long long lazy = 0; //lazy tag of [s,e]\r\n    node *l = nullptr, *r = nullptr; \r\n    //create two children l and r, where l is [s,m] and [m+1,e]\r\n    \r\n    node (long long S, long long E) \r\n    { //constructor called node\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0; //initially all values are 0\r\n        //do not create children l and r right now\r\n        lazy = 0; \r\n        //lazy tag of 0 will mean there is no update (sentinel value)\r\n    }\r\n\r\n    void create()\r\n    { //lazily create children\r\n        if (l==nullptr) //node is not yet a leaf, so create two children\r\n        { //impt: dont create children if the node is already a leaf\r\n            l = new node(s, m); //create left child\r\n            r = new node(m+1, e); //create right child\r\n        }\r\n    }\r\n\r\n    void propogate()\r\n    {\r\n        if (lazy==0) return; //nothing happens / need to propogate\r\n        val+=lazy*(e-s+1); //(e-s+1) is the length of the range\r\n        if (s != e) \r\n        { //not a leaf, send lazy tags to children\r\n            create();\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0; //set our lazy tag value back to the sentinel\r\n    }\r\n\r\n    void update(long long S, long long E, long long V)\r\n    { //increment [S, E] by V\r\n        propogate();\r\n        if(s==S && e==E) lazy += V; //update covers range, update lazy tag\r\n        else\r\n        { //we have to go deeper\r\n            create();\r\n            if(E <= m) l->update(S, E, V); //[S,E] is in the left child\r\n            else if (m < S) r->update(S, E, V);//[S,E] is in the right child\r\n            else l->update(S, m, V),r->update(m+1, E, V);\r\n            l->propogate(),r->propogate(); \r\n            //remember to propogate your children before update yourself\r\n            val = l->val + r->val; //update the range sum\r\n        }\r\n    }\r\n\r\n    long long query(long long S, long long E)\r\n    {\r\n        propogate(); //remember to propogate\r\n        if(s == S && e == E) return val; //case 1\r\n        else \r\n        {\r\n            create();\r\n            if(E <= m) return l->query(S, E); \r\n            //case 2, recurse to left child\r\n            else if(m < S) return r->query(S, E);\r\n            //case 3, recurse to right child\r\n            else return l->query(S, m) + r->query(m+1, E);\r\n            //case 4, split the query range, recurse to both childs\r\n        }\r\n    }\r\n} *root = new node(0, 1e9+100);\r\n\r\nlong long n, q;\r\n\r\nint main ()\r\n{\r\n    ios::sync_with_stdio(false);\r\n    cin.tie(0);\r\n    cout.tie(0);\r\n    cin >> n >> q;\r\n    long long t, a, b, c;\r\n    while (q--)\r\n    {\r\n        cin >> t;\r\n        if (t==1)\r\n        {\r\n            cin >> a >> b >> c;\r\n            root->update(a, b, c);\r\n        }\r\n        else \r\n        {\r\n            cin >> a >> b;\r\n            cout << root->query(a, b) << \"\\n\";\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "penguin133",
        "id": 18092,
        "date": "2020-12-14 20:38:57",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n\tint s,e,m,val=0,lazy=0;\r\n\tnode *l= NULL, *r = NULL;\r\n\tnode(int _s, int _e){\r\n\t\ts = _s, e = _e, m = (s+e)/2;\r\n\t}\r\n\tvoid mc(){\r\n\t\tif(l == NULL){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\tvoid propo(){\r\n\t\tif(lazy != 0){\r\n\t\t\tval += (e-s+1)*lazy;\r\n\t\t\tif(s != e){\r\n\t\t\t\tmc();\r\n\t\t\t\tl->lazy+=lazy;\r\n\t\t\t\tr->lazy+=lazy;\r\n\t\t\t}\r\n\t\t\tlazy = 0;\r\n\t\t}\r\n\t}\r\n\tvoid update(int i, int j, int k){\r\n\t\tif(s == i && e == j)lazy += k;\r\n\t\telse{\r\n\t\t\tmc();\r\n\t\t\tif(j <= m)l->update(i,j,k);\r\n\t\t\telse if(i > m)r->update(i,j,k);\r\n\t\t\telse l->update(i,m,k), r->update(m+1, j, k);\r\n\t\t\tl->propo(), r->propo();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\tint query(int a, int b){\r\n\t\tpropo();\r\n\t\tif(s == a && e == b)return val;\r\n\t\telse{\r\n\t\t\tmc();\r\n\t\t\tif(b <= m)return l->query(a,b);\r\n\t\t\telse if(a > m)return r->query(a,b);\r\n\t\t\telse return l->query(a,m) + r->query(m+1, b);\r\n\t\t}\r\n\t}\r\n}*root = new node(0, 1e9+100);\r\n\r\nmain(){\r\n\tint n,q;\r\n\tcin >> n >> q;\r\n\tfor(int i=0;i<q;i++){\r\n\t\tint t;\r\n\t\tcin >> t;\r\n\t\tint a,b,c;\r\n\t\tif(t == 1){\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\troot->update(a,b,c);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << root->query(a,b) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "ceggyweggy",
        "id": 18068,
        "date": "2020-12-14 20:01:22",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long \r\n\r\nstruct node {\r\n\tint s, e, m;\r\n\tint val;\r\n\tint lazy;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\t\r\n\tnode (int S, int E) {\r\n\t\ts = S, e = E, m = (s+e)/2, val = 0, lazy = 0;\r\n    // if (s != e) {\r\n    //   l = new node(s, m);\r\n    //   r = new node(m+1, e);\r\n    // }\r\n\t}\r\n\t\r\n\tvoid create() {\r\n\t\tif (l != nullptr) return; \r\n\t\tif (s != e) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid propo() {\r\n\t\tif (lazy == 0) return; \r\n\t\tval += lazy*(e-s+1);\r\n\t\tif (s != e) {\r\n          \tcreate();\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\t\r\n\tvoid update(int S, int E, int V) {\r\n\t\tif (s == S && e == E) lazy += V;\r\n\t\telse {\r\n\t\t\tcreate();\r\n\t\t\tif (E <= m) l->update(S, E, V);\r\n\t\t\telse if (S > m) r->update(S, E, V);\r\n\t\t\telse {\r\n\t\t\t\tl->update(S, m, V); r->update(m+1, E, V);\r\n\t\t\t}\r\n\t\t\tl->propo(); r->propo();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\t\r\n\tint query(int S, int E) {\r\n\t\tpropo();\r\n\t\tif (s == S && e == E) return val;\r\n\t\telse {\r\n\t\t\tcreate(); \r\n\t\t\tif (E <= m) return l->query(S, E);\r\n\t\t\telse if (S > m) return r->query(S, E);\r\n\t\t\telse return l->query(S, m) + r->query(m+1, E);\r\n\t\t}\r\n\t}\r\n} *root = new node(1, 1e9+100);\r\n\r\nint n, q;\r\n\r\nmain() {\r\n  \tios_base::sync_with_stdio(0); cin.tie(0);\r\n\tcin >> n >> q;\r\n\twhile (q--) {\r\n\t\t// for (int i=1; i<=n; i++) cout << root->query(i, i) << ' ';\r\n\t\t// cout << '\\n';\r\n\t\tint a, b, c, d;\r\n\t\tcin >> a;\r\n\t\tif (a == 1) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\troot->update(b, c, d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << root->query(b, c) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "1010",
        "id": 17807,
        "date": "2020-12-14 16:15:53",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node{\r\n  long long s, e, m; //range is se, m is middle\r\n  long long lazy = 0, val = 0; // no val! owo!\r\n  node *l = nullptr, *r = nullptr; ///dont create them initially\r\n  node (long long S, long long E){\r\n    s = S, e = E, m = (s+e)/2;\r\n  }\r\n\r\n  void create(){ \r\n    if(l!=nullptr)return; // catch to fix MLE\r\n    if(s != e){ \r\n    l = new node(s, m);\r\n    r = new node(m+1, e);\r\n    }\r\n  }\r\n\r\n  void propogate(){\r\n    if (lazy==0) return; \r\n    val+=lazy*(e-s+1); \r\n    if (s != e){ \r\n      create();\r\n      l->lazy+=lazy;\r\n      r->lazy+=lazy;\r\n    }\r\n    lazy=0;\r\n  }\r\n\r\n  void update(long long S, long long E, long long V){ \r\n    if(s==S && e==E) lazy += V; \r\n    else{ \r\n      create(); //lazily create children //both will be uncreated\r\n      if(E <= m) l->update(S, E, V); \r\n      else if (m < S) r->update(S, E, V);\r\n      else l->update(S, m, V),r->update(m+1, E, V);\r\n      l->propogate(),r->propogate(); \r\n      val = l->val + r->val;\r\n    }\r\n  }\r\n\r\n  long long query(long long S, long long E){\r\n    //create(); //lazily create children\r\n    propogate(); \r\n    if(s == S && e == E) return val;\r\n    else{\r\n      create();\r\n      if(E <= m) return l->query(S, E); \r\n      else if(S >= m+1) return r->query(S, E);\r\n      else return l->query(S, m) + r->query(m+1, E);\r\n      //propogate(); \r\n    }\r\n  }\r\n\r\n} *root= new node(0, 1e9+100);\r\n\r\nint main(){\r\n  cin.tie(0);\r\n  long long n, q, qn, a, b, c;\r\n  cin >> a >> q; //a is actl n but for some reason throwing unused\r\n  for(long long i = 0; i < q; i++){\r\n    cin >> qn;\r\n    if(qn == 1){\r\n      cin >> a >> b >> c;\r\n      root->update(a,b,c);\r\n    }else{\r\n      cin >> a >> b;\r\n      cout << root->query(a,b) << \"\\n\";\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "poxman100",
        "id": 17732,
        "date": "2020-12-14 15:48:26",
        "code": "#include <bits/stdc++.h>\r\n#include <stdio.h>\r\n#include <iomanip>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n//#include <ext/pb_ds/tree_policy.hpp>\r\n//#include <functional> // for less\r\n\r\n\r\nusing namespace __gnu_pbds;\r\n\r\nusing namespace std;\r\n\r\n#define int long long\r\nint MOD = 300000;\r\n\r\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\r\n\r\nstruct node{\r\n\tint s, e, m;\r\n\tint val;\r\n\tint lazy;\r\n\tnode *l, *r;\r\n\r\n\tnode(int S, int E){\r\n\t\ts = S, e = E, m = (s+e)>>1;\r\n\t\tval = 0;\r\n\t\tlazy = 0;\r\n\t\tl = r = nullptr;\r\n\t}\r\n\r\n\tvoid propogate(){\r\n\t\tif (lazy == 0){\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tval += lazy*(e-s+1);\r\n\t\tif (s!=e){\r\n\t\t\tcreate();\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\r\n\tvoid create(){\r\n\t\tif (l==nullptr){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid update(int S, int E, int V){\r\n\t\tpropogate();\r\n\r\n\t\tif (s==S and e==E){\r\n\t\t\tlazy += V;\r\n\t\t} else{\r\n\t\t\tcreate();\r\n\t\t\tif (E<=m){\r\n\t\t\t\tl->update(S, E, V);\r\n\t\t\t} else if (S>m){\r\n\t\t\t\tr->update(S, E, V);\r\n\t\t\t} else{\r\n\t\t\t\tl->update(S, m, V);\r\n\t\t\t\tr->update(m+1, E, V);\r\n\t\t\t}\r\n\r\n\t\t\tl->propogate();\r\n\t\t\tr->propogate();\r\n\r\n\t\t\t//cout << \"omg\";\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\r\n\tint query(int S, int E){\r\n\t\tpropogate();\r\n\r\n\t\tif (s==S && e==E){\r\n\t\t\treturn val;\r\n\t\t} else if (E<=m){\r\n\t\t\tcreate();\r\n\t\t\treturn l->query(S, E);\r\n\t\t} else if (S>m){\r\n\t\t\tcreate();\r\n\t\t\treturn r->query(S, E);\r\n\t\t} else{\r\n\t\t\tcreate();\r\n\t\t\treturn l->query(S, m) + r->query(m+1, E);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nsigned main(int argc, char** argv) {\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n\t//std::cout << std::fixed;\r\n\t//std::cout << std::setprecision(1);\r\n\tcout << \"\";\r\n\r\n\tint N, Q;\r\n\tcin >> N >> Q;\r\n\r\n\tnode *root = new node(-100, N+100);\r\n\r\n\tfor (int i=0; i<Q; i++){\r\n\t\tint a;\r\n\t\tcin >> a;\r\n\t\tif (a == 1){\r\n\t\t\tint l, r, k;\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\troot->update(l, r, k);\r\n\t\t} else if (a == 2){\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->query(l, r) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "lowchooray",
        "id": 17444,
        "date": "2020-12-14 13:53:19",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node {\r\n  long long s,e,m,val,lazy;\r\n  node *l, *r;\r\n  node(long long S, long long E) {\r\n    s = S;\r\n    e = E;\r\n    m = (S+E)/2;\r\n    val = 0;\r\n    lazy = 0;\r\n  }\r\n  \r\n  void create() {\r\n    if(s==e) return;\r\n    l = new node(s, m);\r\n    r = new node(m+1, e);\r\n  }\r\n  void ppg() {\r\n    if(l==nullptr) create();\r\n    if(lazy==0) return;\r\n    val += (e-s+1)*lazy;\r\n    if(s!=e) {\r\n      l->lazy+=lazy;\r\n      r->lazy+=lazy;\r\n    }\r\n    lazy=0;\r\n  }\r\n  void upd(long long S, long long E, long long k) {\r\n    if(l==nullptr) create();\r\n    if(s==S && e==E) {\r\n      lazy+=k;\r\n    } else {\r\n      if(E<=m) {\r\n        l->upd(S,E,k);\r\n      } else if(S>m) {\r\n        r->upd(S,E,k);\r\n      } else {\r\n        l->upd(S,m,k);\r\n        r->upd(m+1,E,k);\r\n      }\r\n      l->ppg();\r\n      r->ppg();\r\n      val = l->val + r->val;\r\n    }\r\n  }\r\n  long long qry(long long S, long long E) {\r\n    if(l==nullptr) create();\r\n    ppg();\r\n    if(s==S && e==E) {\r\n      return val;\r\n    } else {\r\n      if(E<=m) return l->qry(S,E);\r\n      else if(S>=m+1) return r->qry(S,E);\r\n      else return l->qry(S,m)+r->qry(m+1,E);\r\n    }\r\n  }\r\n} *root;\r\n\r\nint main() {\r\n  long long n,q;\r\n  cin>>n>>q;\r\n  root = new node(1, n);\r\n  for(long long i=0; i<q; i++) {\r\n    long long x;\r\n    cin>>x;\r\n    if(x==1) {\r\n      long long s,e,k;\r\n      cin>>s>>e>>k;\r\n      root->upd(s,e,k);\r\n    } else {\r\n      long long s,e;\r\n      cin>>s>>e;\r\n      cout<<root->qry(s,e)<<endl;\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "nyoomeric",
        "id": 17432,
        "date": "2020-12-14 13:36:09",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\n#define pi pair<ll,ll>\r\n#define mp make_pair \r\n#define all(x) x.begin(), x.end()\r\n#define fs ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n#define MOD 1000000007\r\n#define mem(x,s) memset(x, s, sizeof(x))\r\n#define ct(x) cout<<x<<' ';\r\n#define nl cout<<'\\n';\r\n#define rep(i,s,e) for(ll i=s;i<=e;++i)\r\n#define lin cout<<\"_____\\n\";\r\n// return 1 means ... x is i\r\n\r\nll n, q;\r\n\r\nstruct node{\r\n\tll s,e,m,sum,lz;\r\n\tnode *l, *r;\r\n\tnode(ll _s, ll _e){\r\n\t\ts = _s, e = _e, m = (s+e)/2, sum = 0, lz=0;\r\n\t\tl = nullptr, r = nullptr;\r\n\t}\r\n\r\n\tvoid create(){\r\n\t\tif(s!=e){\r\n\t\t\tl = new node(s,m);\r\n\t\t\tr = new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid prop(){\r\n\t\tif(l==nullptr) create();  \r\n\t\tsum+=(lz)*(e-s+1LL);\r\n\t\tif(s!=e) {\r\n\t\t\tl->lz+=lz, r->lz+=lz;\r\n\t\t\t//l->prop(); \r\n\t\t\t//r->prop();\r\n\t\t}\r\n\t\tlz=0;\r\n\t}\r\n\r\n\tvoid upd(ll x, ll y, ll v){\r\n\t\tprop();  \r\n\t\tif(s==x && e==y) {\r\n\t\t\tlz += v; \r\n\t\t\tprop();\r\n\t\t\t//sum += (y-x+1)*v;\r\n\t\t}\r\n\t\telse{ \r\n\t\t\tif(y <=m) {\r\n\t\t\t\tl->upd(x,y,v);\r\n\t\t\t}\r\n\t\t\telse if(x>m){\r\n\t\t\t\tr->upd(x,y,v);\r\n\t\t\t}else {\r\n\t\t\t\tl->upd(x,m,v);\r\n\t\t\t\tr->upd(m+1,y,v);\r\n\t\t\t}\r\n\t\t\tl->prop(); r->prop();\r\n\t\t\tsum = l->sum+r->sum;\r\n\t\t}\r\n\t}\r\n\r\n\tll rsum(ll x, ll y){\r\n\t\tprop();\r\n\t\tif(s==x && y==e) return sum;\r\n\t\telse{\r\n \t\t\tif(y <= m) return l->rsum(x,y);\r\n\t\t\telse if(x > m) return r->rsum(x,y);\r\n\t\t\treturn l->rsum(x,m)+ r->rsum(m+1,y);\r\n\t\t}\r\n\t}   \r\n \r\n\tvoid vomit(ll x, ll y){\r\n\t\tct(\"VOMIT\") ct(x) ct(y) \r\n\t\tct(\"sum\") ct(sum) \r\n\t\tct(\"lazy\") ct(lz)  nl\r\n\t\tif(l==nullptr) create();\r\n\t\tif(s!=e) l->vomit(s,m), r->vomit(m+1,e);\r\n \t}\r\n} *root;\r\n\r\nvoid print(){\r\n\t//rep(i,1,n) cout<<root->rsum(i,i)<<' ';   nl\r\n}\r\n\r\nint main(){\t\r\n\tfs\r\n\t\r\n\tcin>>n>>q;\r\n\troot = new node(1,n);\r\n\twhile(q--){\r\n\t\tll a,b,c,d;\r\n\t\tcin>>a>>b>>c;\r\n\t\tif(b<1 || c>n) abort();\r\n\t\tif(a==1) {\r\n\t\t\tcin>>d;\r\n\t\t\troot->upd(b,c,d);\r\n\t//\t\tct(\"UPD\") ct(b) ct(c) ct(d) nl\r\n\t\t//\tct(\"SEG\")\r\n\t//\t rep(i,1,n) {ct(root->rsum(i,i))}\r\n\t//\t root->vomit(1,n);\r\n\t\t \r\n\t\t}\r\n\t\telse {\r\n\t\t\tcout<<root->rsum(b,c)<<'\\n';\r\n\t\t// \troot->vomit(1,n);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "username": "yblog",
        "id": 17186,
        "date": "2020-12-14 11:49:37",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node{\r\n\tint s,e,m,v;\r\n\tint lazy;\r\n\tnode *l, *r;\r\n\tnode(int _s, int _e){\r\n\t\ts = _s; e = _e; m = (s+e)/2;\r\n\t\tv=0;\r\n\t\tlazy=0;\r\n\t}\r\n\t\r\n\tvoid create(){\r\n\t\tif(s!=e){\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid propagate(){\r\n\t\tif(l == nullptr) create();\r\n\t\tif(lazy==0) return;\r\n\t\t\r\n\t\tv += lazy*(e-s+1);\r\n\t\tif(s!=e){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t}\r\n\t\r\n\tvoid update(int S, int E, int V){\r\n\t\tif(l == nullptr) create();\r\n\t\tif(s==S and e==E) lazy += V;\r\n\t\telse{\r\n\t\t\t//if(l == nullptr) create();\r\n\t\t\t\r\n\t\t\tif(E<=m) l->update(S, E, V);\r\n\t\t\telse if(m<S) r->update(S, E, V);\r\n\t\t\telse l->update(S, m, V), r->update(m+1, E, V);\r\n\t\t\t\r\n\t\t\tl->propagate(), r->propagate();\r\n\t\t\tv = l->v + r->v;\r\n\t\t}\r\n\t}\r\n\t\r\n\tint query(int S, int E){\r\n\t\tif(l == nullptr) create();\r\n\t\tpropagate();\r\n\t\t\r\n\t\tif(s == S and e == E) return v;\r\n\t\telse if(E<=m) return l->query(S, E);\r\n\t\telse if(S>=m+1) return r->query(S, E);\r\n\t\telse return l->query(S, m) + r->query(m+1, E);\r\n\t}\r\n\t/*\r\n\tint rmq(int x, int y){\r\n\t\tif(s == x and e == y) return v;\r\n\t\tif(x>m) return r->rmq(x, y);\r\n\t\tif(y<=m) return l->rmq(x, y);\r\n\t\treturn min(l->rmq(x, m), r->rmq(m+1, y));\r\n\t}\r\n\t*/\r\n}*root;\r\n\r\nint n, q;\r\nint x, L, R, k;\r\n\r\nint32_t main(){\r\n\tcin >> n >> q;\r\n\t\r\n\troot = new node(1, n);\r\n\t\r\n\tfor(int i=0; i<q; i++){\r\n\t\tcin >> x;\r\n\t\tif(x == 1){\r\n\t\t\tcin >> L >> R >> k;\r\n\t\t\troot->update(L, R, k);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin >> L >> R;\r\n\t\t\tcout << root->query(L, R) << \"\\n\";\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "Wenkai",
        "id": 17181,
        "date": "2020-12-14 11:49:05",
        "code": "#include <bits/stdc++.h>\r\n#define ll long long\r\n#define ull unsigned long long\r\n#define ii pair<int, int>\r\n#define llll pair<ll, ll>\r\n#define INF LLONG_MAX\r\n#define fast_input ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n\r\nusing namespace std;\r\n\r\n#define int ll\r\n\r\nstruct node {\r\n    int s, e, m;\r\n    node *l, *r;\r\n    int val;\r\n    int lazy;\r\n\r\n    void create_lr() {\r\n        if (s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m + 1, e);\r\n        }\r\n    }\r\n\r\n    node(int S, int E) { \r\n        s = S, e = E, m = (s + e) / 2;\r\n        val = 0; // change if necessary\r\n        lazy = 0;\r\n    }\r\n\r\n    void propogate() {\r\n        if (lazy == 0) return;\r\n        val += lazy * (e - s + 1);\r\n        if (s != e) { \r\n            if (l == nullptr) create_lr();\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\n    void update(int S, int E, int V) {\r\n        if (s == S && e == E) lazy += V;\r\n        else {\r\n            if (l == nullptr) create_lr();\r\n            if (E <= m) l->update(S, E, V);\r\n            else if (m < S) r->update(S, E, V);\r\n            else l->update(S, m, V), r->update(m + 1, E, V);\r\n\r\n            l->propogate();\r\n            r->propogate();\r\n            val = l->val + r->val; // change if necessary\r\n        }\r\n    }\r\n\r\n    int query(int S, int E) {\r\n        if (l == nullptr) create_lr();\r\n        propogate();\r\n        if (s == S && e == E) return val; \r\n        else if (E <= m) return l->query(S, E);\r\n        else if (S >= m+1) return r->query(S, E);\r\n        else return l->query(S, m) + r->query(m + 1, E); // change if necessary\r\n    }\r\n};\r\n\r\nint32_t main() {\r\n    //fast_input;\r\n    int N, Q;\r\n    cin >> N >> Q;\r\n    node* root = new node(1, N);\r\n    int type = 0, a = 0, b = 0, x = 0;\r\n    for (int i = 0; i < Q; i++) {\r\n        cin >> type;\r\n        if (type == 1) {\r\n            cin >> a >> b >> x;\r\n            root->update(a, b, x);\r\n        } \r\n        else {\r\n            cin >> a >> b;\r\n            cout << root->query(a, b) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "cstuart",
        "id": 17175,
        "date": "2020-12-14 11:46:42",
        "code": "#define _USE_MATH_DEFINES 1\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n#define MOD 1000000007ll\r\n#define INF 2000000000000000000ll\r\n#define EPS 1e-9\r\n\r\n#define getchar_unlocked _getchar_nolock\r\n#define putchar_unlocked _putchar_nolock\r\n\r\ntypedef long long           ll;\r\ntypedef long double         ld;\r\ntypedef pair <ll,ll>        pl;\r\ntypedef tuple <ll,ll,ll>    tl;\r\ntypedef tuple <ll,ll,ll,ll> ql;\r\n\r\nll N, Q, T, L, R, V;\r\n\r\nstruct Node {\r\n\t\r\n\tll range_start, range_end, range_mid, sum, lazy_prop;\r\n\tNode *left, *right;\r\n\t\r\n\tNode (ll _s, ll _e) {\r\n\t\trange_start = _s;\r\n\t\trange_end = _e;\r\n\t\trange_mid = (range_start + range_end) / 2;\r\n\t\tsum = 0;\r\n\t\tlazy_prop = 0;\r\n\t\tleft = nullptr;\r\n\t\tright = nullptr;\r\n\t}\r\n\t\r\n\tvoid makeChildren() {\r\n\t\tleft = new Node(range_start, range_mid);\r\n\t\tright = new Node(range_mid + 1, range_end);\r\n\t}\r\n\t\r\n\tvoid lazyPropagate() {\r\n\t\tsum += (range_end - range_start + 1) * lazy_prop;\r\n\t\tif (range_start != range_end) {\r\n\t\t\tif (left == nullptr) makeChildren();\r\n\t\t\tleft->lazy_prop += lazy_prop;\r\n\t\t\tright->lazy_prop += lazy_prop;\r\n\t\t}\r\n\t\tlazy_prop = 0;\r\n\t}\r\n\t\r\n\tvoid rangeUpdate(ll query_left, ll query_right, ll update_value) {\r\n\t\tif (lazy_prop != 0) lazyPropagate();\r\n\t\tif (query_right < range_start || range_end < query_left) return;\r\n\t\tif (query_left <= range_start && range_end <= query_right) {\r\n\t\t\tlazy_prop += update_value;\r\n\t\t\tlazyPropagate();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (left == nullptr) makeChildren();\r\n\t\tleft->rangeUpdate(query_left, query_right, update_value);\r\n\t\tright->rangeUpdate(query_left, query_right, update_value);\r\n\t\tsum = left->sum + right->sum;\r\n\t}\r\n\t\r\n\tll rangeQuery(ll query_left, ll query_right) {\r\n\t\tif (lazy_prop != 0) lazyPropagate();\r\n\t\tif (query_right < range_start || range_end < query_left) return 0;\r\n\t\tif (query_left <= range_start && range_end <= query_right) return sum;\r\n\t\tif (left == nullptr) makeChildren();\r\n\t\treturn left->rangeQuery(query_left, query_right) + right->rangeQuery(query_left, query_right);\r\n\t}\r\n\t\r\n} *root;\r\n\r\nint main() {\r\n\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\t\r\n\tcin >> N >> Q;\r\n\troot = new Node(1, N);\r\n\t\r\n\tfor (ll q = 1; q <= Q; q++) {\r\n\t\tcin >> T;\r\n\t\tif (T == 1) {\r\n\t\t\tcin >> L >> R >> V;\r\n\t\t\troot->rangeUpdate(L, R, V);\r\n\t\t} else {\r\n\t\t\tcin >> L >> R;\r\n\t\t\tcout << root->rangeQuery(L, R) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\t\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "username": "xp",
        "id": 17144,
        "date": "2020-12-14 11:37:20",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node {\r\n\tint s, e, m;\r\n\tnode *l, *r;\r\n\tlong long sum, lazy;\r\n\t\r\n\tnode(int _s, int _e) {\r\n\t\ts = _s, e = _e, m = (s+e)/2;\r\n\t\tsum = lazy = 0;\r\n\t\tl = r = NULL;\r\n\t}\r\n\t\r\n\tvoid create() {\r\n\t\tif(s != e) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid prop() {\r\n\t\tsum += lazy * (e-s+1);\r\n\t\tif(s!=e) {\r\n\t\t\tif(l == NULL) create();\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\t\t\t\r\n\tvoid update(int a, int b, int nv) {\r\n\t\tif(a == s && b == e) lazy += nv;\r\n\t\telse {\r\n\t\t\tif(l == NULL) create();\r\n\t\t\tif (b <= m) l->update(a, b, nv);\r\n\t\t\telse if(a > m) r->update(a, b, nv);\r\n\t\t\telse {\r\n\t\t\t\tl->update(a, m, nv);\r\n\t\t\t\tr->update(m+1, b, nv);\r\n\t\t\t}\r\n\t\t\tl->prop(); r->prop();\r\n\t\t\tsum = l->sum + r->sum;\r\n\t\t}\r\n\t}\r\n\t\r\n\tlong long query(int a, int b) {\r\n\t\tprop();\r\n\t\tif(a == s && b == e) return sum;\r\n\t\tif(l==nullptr) create();\r\n\t\tif(a > m) return r->query(a, b);\r\n\t\tif(b <= m) return l->query(a, b);\r\n\t\treturn l->query(a, m) + r->query(m+1, b);\r\n\t}\r\n\t\r\n}* root;\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\t\r\n\tint n, q;\r\n\tcin >> n >> q;\r\n\troot = new node(1, n);\r\n\t\r\n\tfor(int i=0; i<q; i++) {\r\n\t\tint c;\r\n\t\tcin >> c;\r\n\t\tif(c==1) {\r\n\t\t\tint a, b, v;\r\n\t\t\tcin >> a >> b >> v;\r\n\t\t\troot->update(a, b, v);\r\n\t\t}\r\n\t\telse if(c==2) {\r\n\t\t\tint a, b;\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << root->query(a, b) << '\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "xp",
        "id": 17135,
        "date": "2020-12-14 11:35:04",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node {\r\n\tint s, e, m;\r\n\tnode *l, *r;\r\n\tlong long sum, lazy;\r\n\t\r\n\tnode(int _s, int _e) {\r\n\t\ts = _s, e = _e, m = (s+e)/2;\r\n\t\tsum = lazy = 0;\r\n\t\tl = r = nullptr;\r\n\t}\r\n\t\r\n\tvoid create() {\r\n\t\tif(s != e) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid prop() {\r\n\t\tsum += lazy * (e-s+1);\r\n\t\tif(s!=e) {\r\n\t\t\tif(l == nullptr) create();\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\t\t\t\r\n\tvoid update(int a, int b, int nv) {\r\n\t\tprop();\r\n\t\tif(a == s && b == e) lazy += nv;\r\n\t\telse {\r\n\t\t\tif(l == nullptr) create();\r\n\t\t\tprop();\r\n\t\t\tif (b <= m) l->update(a, b, nv);\r\n\t\t\telse if(a > m) r->update(a, b, nv);\r\n\t\t\telse {\r\n\t\t\t\tl->update(a, m, nv);\r\n\t\t\t\tr->update(m+1, b, nv);\r\n\t\t\t}\r\n\t\t\tl->prop();\r\n\t\t\tr->prop();\r\n\t\t\tsum = l->sum + r->sum;\r\n\t\t}\r\n\t}\r\n\t\r\n\tlong long query(int a, int b) {\r\n\t\tprop();\r\n\t\tif(a == s && b == e) return sum;\r\n\t\tif(l==nullptr) create();\r\n\t\tprop();\r\n\t\tif(a > m) return r->query(a, b);\r\n\t\tif(b <= m) return l->query(a, b);\r\n\t\treturn l->query(a, m) + r->query(m+1, b);\r\n\t}\r\n\t\r\n}* root;\r\n\r\nint main() {\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\t\r\n\tint n, q;\r\n\tcin >> n >> q;\r\n\troot = new node(1, n);\r\n\t\r\n\tfor(int i=0; i<q; i++) {\r\n\t\tint c;\r\n\t\tcin >> c;\r\n\t\tif(c==1) {\r\n\t\t\tint a, b, v;\r\n\t\t\tcin >> a >> b >> v;\r\n\t\t\troot->update(a, b, v);\r\n\t\t}\r\n\t\telse if(c==2) {\r\n\t\t\tint a, b;\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << root->query(a, b) << '\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "rence1712",
        "id": 17132,
        "date": "2020-12-14 11:34:04",
        "code": "#include <bits/stdc++.h>\r\n#include <string>\r\n#include <vector>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node{\r\n    int s, e, m;\r\n    int val = 0, lazy = 0;\r\n    node *l = nullptr, *r = nullptr; ///dont create them initially\r\n    \r\n    node (int _s, int _e){\r\n        s = _s, e = _e, m = s+e >> 1;\r\n    }\r\n    \r\n    void makechild(){ ///lazily create children\r\n        if (l == nullptr) { ///currently no children\r\n            l = new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n    \r\n    void propo() {\r\n        if (lazy != 0) { ///neeed to propogate\r\n            val +=(e-s+1)*lazy;\r\n            \r\n            if(s!=e) {\r\n                makechild();\r\n                \r\n                l -> lazy += lazy;\r\n                r -> lazy += lazy;\r\n            }\r\n            lazy = 0;\r\n        }\r\n    }\r\n    \r\n    void update(int i, int j, int k){ ///updating [i,j] += k\r\n        propo();\r\n        \r\n        if (s==i && e==j) lazy += k;\r\n        else {\r\n            makechild();\r\n            \r\n            if (j <= m) l -> update(i,j,k);\r\n            else if (m < i) r -> update(i,j,k);\r\n            else l -> update(i,m,k), r->update(m+1,j,k);\r\n            \r\n            l -> propo(), r -> propo();\r\n            val = l->val + r -> val;\r\n        }\r\n    }\r\n    \r\n    int query(int i, int j){ ///query [i,j]\r\n        propo();\r\n        \r\n        if(s==i && e==j) return val;\r\n        else {\r\n            makechild();\r\n            \r\n            if(j <= m) return l -> query(i,j);\r\n            else if(m < i) return r ->  query(i,j);\r\n            else return l -> query(i,m) + r ->  query(m+1,j);\r\n        }\r\n    }\r\n} *root = new node(-100, 1e9+100);\r\n\r\nint N, Q;\r\n\r\nmain() {\r\n    cin >> N >> Q;\r\n    int a, b, c, t;\r\n    while (Q--) {\r\n        cin >> t;\r\n        if (t == 1) {\r\n            cin >> a >> b >> c;\r\n            root -> update (a,b,c);\r\n        }\r\n        else{\r\n             cin >> a >> b;\r\n             cout << root -> query(a,b) << endl;\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "cstuart",
        "id": 17074,
        "date": "2020-12-14 11:11:38",
        "code": "#define _USE_MATH_DEFINES 1\r\n#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n#define MOD 1000000007ll\r\n#define INF 2000000000000000000ll\r\n#define EPS 1e-9\r\n\r\n#define getchar_unlocked _getchar_nolock\r\n#define putchar_unlocked _putchar_nolock\r\n\r\ntypedef long long           ll;\r\ntypedef long double         ld;\r\ntypedef pair <ll,ll>        pl;\r\ntypedef tuple <ll,ll,ll>    tl;\r\ntypedef tuple <ll,ll,ll,ll> ql;\r\n\r\nll N, Q, T, L, R, V;\r\n\r\nstruct Node {\r\n\t\r\n\tll range_start, range_end, range_mid, sum, lazy_prop;\r\n\tNode *left, *right;\r\n\t\r\n\tNode (ll _s, ll _e) {\r\n\t\trange_start = _s;\r\n\t\trange_end = _e;\r\n\t\trange_mid = (range_start + range_end) / 2;\r\n\t\tsum = 0;\r\n\t\tlazy_prop = 0;\r\n\t\tleft = NULL;\r\n\t\tright = NULL;\r\n\t}\r\n\t\r\n\tvoid makeChildren() {\r\n\t\tleft = new Node(range_start, range_mid);\r\n\t\tright = new Node(range_mid + 1, range_end);\r\n\t}\r\n\t\r\n\tvoid lazyPropagate() {\r\n\t\tsum += (range_end - range_start + 1) * lazy_prop;\r\n\t\tif (range_start != range_end) {\r\n\t\t\tif (left == NULL) makeChildren();\r\n\t\t\tleft->lazy_prop += lazy_prop;\r\n\t\t\tright->lazy_prop += lazy_prop;\r\n\t\t}\r\n\t\tlazy_prop = 0;\r\n\t}\r\n\t\r\n\tvoid rangeUpdate(ll query_left, ll query_right, ll update_value) {\r\n\t\tif (lazy_prop != 0) lazyPropagate();\r\n\t\tif (query_right < range_start || range_end < query_left) return;\r\n\t\tif (query_left <= range_start && range_end <= query_right) {\r\n\t\t\tlazy_prop += update_value;\r\n\t\t\tlazyPropagate();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (left == NULL) makeChildren();\r\n\t\tleft->rangeUpdate(query_left, query_right, update_value);\r\n\t\tright->rangeUpdate(query_left, query_right, update_value);\r\n\t\tsum = left->sum + right->sum;\r\n\t}\r\n\t\r\n\tll rangeQuery(ll query_left, ll query_right) {\r\n\t\tif (lazy_prop != 0) lazyPropagate();\r\n\t\tif (query_right < range_start || range_end < query_left) return 0;\r\n\t\tif (query_left <= range_start && range_end <= query_right) return sum;\r\n\t\tif (left == NULL) makeChildren();\r\n\t\treturn left->rangeQuery(query_left, query_right) + right->rangeQuery(query_left, query_right);\r\n\t}\r\n\t\r\n} *root;\r\n\r\nint main() {\r\n\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\t\r\n\tcin >> N >> Q;\r\n\troot = new Node(1, N);\r\n\t\r\n\tfor (ll q = 1; q <= Q; q++) {\r\n\t\tcin >> T;\r\n\t\tif (T == 1) {\r\n\t\t\tcin >> L >> R >> V;\r\n\t\t\troot->rangeUpdate(L, R, V);\r\n\t\t} else {\r\n\t\t\tcin >> L >> R;\r\n\t\t\tcout << root->rangeQuery(L, R) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\t\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "username": "nigelh",
        "id": 17025,
        "date": "2020-12-14 10:55:28",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nstruct node{\r\n\tlong long s, e, m; \r\n\tlong long val = 0; \r\n\tlong long lazy = 0; \r\n\tnode *l = nullptr, *r = nullptr; \r\n\tnode (long long S, long long E){ \r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t}\r\n\tvoid makeChild(){\r\n\t\tif (l==nullptr){\r\n\t\t\tl = new node(s,m);\r\n\t\t\tr = new node(m+1, e);\r\n\r\n\t\t}\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif (lazy==0) return; \r\n\t\tval+=lazy*(e-s+1); \r\n\t\tif (s != e){ \r\n\t\t\tmakeChild();\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0; \r\n\t}\r\n\tvoid update(long long S, long long E, long long V){ \r\n\t\tpropogate();\r\n\t\tif(s==S && e==E) lazy += V; \r\n\t\telse{ \r\n\t\t\tmakeChild();\r\n\t\t\tif(E <= m) l->update(S, E, V);\r\n\t\t\telse if (m < S) r->update(S, E, V); \r\n\t\t\telse l->update(S, m, V),r->update(m+1, E, V);\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n}\r\n\tlong long query(long long S, long long E){\r\n\t\tpropogate(); \r\n\t\tif(s == S && e == E) return val;\r\n\t\telse{\r\n\t\t\tmakeChild(); \r\n\t\t\tif(E <= m) return l->query(S, E); \r\n\t\t\telse if(S >= m+1) return r->query(S, E); \r\n\t\t\telse return l->query(S, m) + r->query(m+1, E);\r\n\t\t}\r\n\t}\r\n} *root = new node(-100, 1e9+100);\r\nint main(){\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n\tlong long N, Q, a, b, c, d;\r\n\tcin >> N >> Q;\r\n\troot = new node(0,N+10);\r\n\tfor (long long i = 0; i < Q; i++){\r\n\t\tcin >> a;\r\n\t\tif (a == 1){\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse if (a == 2){\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << root->query(b,c) << '\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "huangqr",
        "id": 17019,
        "date": "2020-12-14 10:53:25",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef pair<ll,ll>pl;\r\n\r\nstruct node{\r\n\tll v,sum=0,lazy=0,s,e,m;\r\n\tnode *l,*r;\r\n\tnode(ll ss,ll ee,ll x){\r\n\t\ts=ss,e=ee,m=(s+e)/2;\r\n\t\tl=r=NULL;\r\n\t\tv=x;\r\n\t\tsum=(e-s+1)*x;\r\n\t}\r\n\tvoid cc(){\r\n\t\tif(s==e||l!=NULL)return;\r\n\t\tl=new node(s,m,0);\r\n\t\tr=new node(m+1,e,0);\r\n\t}\r\n\tll value(){\r\n\t\tcc();\r\n\t\tif(lazy==0)return sum;\r\n\t\tv+=lazy;\r\n\t\tsum+=(e-s+1)*lazy;\r\n\t\tif(s!=e){\r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0;\r\n\t\treturn sum;\r\n\t}\r\n\tvoid update(ll a,ll b,ll x){\r\n\t\tcc();\r\n\t\tvalue();\r\n\t\tif(s==a&&e==b){\r\n\t\t\tlazy+=x;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tif(l==NULL)cc();\r\n\t\t\tif(a>m)r->update(a,b,x);\r\n\t\t\telse if(b<=m)l->update(a,b,x);\r\n\t\t\telse l->update(a,m,x),r->update(m+1,b,x);\r\n\t\t\tsum=l->value()+r->value();\r\n\t\t}\r\n\t}\r\n\tll query(ll a,ll b){\r\n\t\tcc();\r\n\t\tvalue();\r\n\t\tif(l==NULL||(s==a&&b==e))return sum;\r\n\t\telse if(a>m)return r->query(a,b);\r\n\t\telse if(b<=m)return l->query(a,b);\r\n\t\telse return l->query(a,m)+r->query(m+1,b);\r\n\t}\r\n}*root;\r\n\r\nint main(){\r\n\tios_base::sync_with_stdio(0),cin.tie(NULL);\r\n\tll n,q,a,b,c,d;\r\n\tcin>>n;\r\n\troot=new node(0,n+1,0);\r\n\tcin>>q;\r\n\tfor(int i=0;i<q;i++){\r\n\t\tcin>>a;\r\n\t\tif(a==1){\r\n\t\t\tcin>>b>>c>>d;\r\n\t\t\troot->update(b,c,d);\r\n\t\t}\r\n\t\telse{\r\n\t\t\tcin>>b>>c;\r\n\t\t\tcout<<root->query(b,c)<<\"\\n\";\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}"
    },
    {
        "username": "quekyp",
        "id": 16997,
        "date": "2020-12-14 10:43:42",
        "code": "#include <iostream>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nint N, Q;\r\n\r\nstruct node {\r\n    int s, e, m;\r\n    long long val;\r\n    long long lazy;\r\n    node *l, *r;\r\n\r\n    node (int S, int E) {\r\n        s = S, e = E, m = (s + e) / 2;\r\n        val = 0;\r\n        lazy = 0;\r\n    }\r\n\r\n    void create() {\r\n        if (s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m + 1, e);\r\n        }\r\n    }\r\n\r\n    void propogate() {\r\n        if (l == nullptr) create();\r\n        if (lazy == 0) return;\r\n        val += lazy * (e - s + 1LL);\r\n        if (s != e) {\r\n            (l -> lazy) += lazy;\r\n            (r -> lazy) += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\n    void update(int S, int E, long long V) {\r\n        if (l == nullptr) create();\r\n        if (s == S && e == E) lazy += V;\r\n        else {\r\n            if (E <= m) l -> update(S, E, V);\r\n            else if (m < S) r -> update(S, E, V);\r\n            else {\r\n                l -> update(S, m, V);\r\n                r -> update(m + 1, E, V);\r\n            }\r\n            l -> propogate();\r\n            r -> propogate();\r\n            val = l -> val + r -> val;\r\n        }\r\n    }\r\n\r\n    long long query(int S, int E) {\r\n        if (l == nullptr) create();\r\n        propogate();\r\n        if (s == S && e == E) return val;\r\n        else if (E <= m) return l -> query(S, E);\r\n        else if (S >= m + 1) return r -> query(S, E);\r\n        else return l -> query(S, m) + r -> query(m + 1, E);\r\n    }\r\n};\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n\r\n    cin >> N >> Q;\r\n\r\n    node *root = new node(1, N);\r\n\r\n    for (int i = 0; i < Q; i++) {\r\n        int type;\r\n        cin >> type;\r\n        if (type - 1) {\r\n            int l, r;\r\n            cin >> l >> r;\r\n            long long q = root -> query(l, r);\r\n            cout << q << '\\n';\r\n        } else {\r\n            int l, r, k;\r\n            cin >> l >> r >> k;\r\n            root -> update(l, r, k);\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "myrcella",
        "id": 16987,
        "date": "2020-12-14 10:38:08",
        "code": "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define fi first\r\n#define se second\r\n#define pii pair<int,int>\r\n#define pb push_back\r\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\r\n#define pq priority_queue\r\n#define inf 0x3f3f3f3f\r\n#define rep(i,a,b) for (int i=a;i<(b);i++)\r\n#define MP make_pair\r\n#define SZ(x) (int(x.size()))\r\n#define ll long long\r\n#define mod 1000000007\r\nvoid inc(int &a,int b) {a=(a+b)%mod;}\r\nvoid dec(int &a,int b) {a=(a-b+mod)%mod;}\r\nint lowbit(int x) {return x&(-x);}\r\nll p0w(ll base,int p) {ll ret=1;while(p){if (p%2==1) ret=ret*base%mod;base=base*base%mod;p/=2;}return ret;}\r\n\r\nconst int maxn=5e6+10;\r\n\r\nint n,m;\r\nll tree[maxn],add[maxn];\r\nint lc[maxn],rc[maxn];\r\nint tot=1;\r\n\r\nvoid fill(int c,int cl,int cr,ll val) {\r\n\ttree[c]+=1ll*(cr-cl+1)*val;\r\n\tadd[c]+=val;\r\n}\r\n\r\nvoid push_down(int c,int cl,int cr) {\r\n\tif (lc[c]==-1) lc[c]=++tot;\r\n\tif (rc[c]==-1) rc[c]=++tot;\r\n\tint mid=cl+cr>>1;\r\n\tfill(lc[c],cl,mid,add[c]);\r\n\tfill(rc[c],mid+1,cr,add[c]);\r\n\tadd[c]=0;\r\n}\r\n\r\nvoid update(int &c,int cl,int cr,int l,int r,ll val) {\r\n\tif (c==-1) c=++tot;\r\n\tif (l<=cl&&cr<=r) {\r\n\t\tfill(c,cl,cr,val);\r\n\t\treturn;\r\n\t}\r\n\tint mid=cl+cr>>1;\r\n\tif (add[c]!=0) push_down(c,cl,cr);\r\n\tif (l<=mid) update(lc[c],cl,mid,l,r,val);\r\n\tif (r>mid) update(rc[c],mid+1,cr,l,r,val);\r\n\tif (lc[c]==-1) tree[c]=tree[rc[c]];\r\n\telse if (rc[c]==-1) tree[c]=tree[lc[c]];\r\n\telse tree[c]=tree[lc[c]]+tree[rc[c]];\r\n//\tcout<<cl<<\" \"<<cr<<\" \"<<tree[c]<<endl;\r\n\treturn;\r\n}\r\n\r\nll query(int c,int cl,int cr,int l,int r) {\r\n\tif (c==-1) return 0;\r\n\tif (l<=cl&&cr<=r) return tree[c];\r\n\tint mid=cl+cr>>1;\r\n\tif (add[c]!=0) push_down(c,cl,cr);\r\n\tll ret=0;\r\n\tif (l<=mid) ret+=query(lc[c],cl,mid,l,r);\r\n\tif (r>mid) ret+=query(rc[c],mid+1,cr,l,r);\r\n\treturn ret;\r\n}\r\n\r\nint main() {\r\n//\tstd::ios::sync_with_stdio(false);\r\n\tmemset(tree,0,sizeof(tree));\r\n\tmemset(add,0,sizeof(add));\r\n\tmemset(lc,-1,sizeof(lc));\r\n\tmemset(rc,-1,sizeof(rc));\r\n\tscanf(\"%d%d\",&n,&m);\r\n\tint rt=1;\r\n\twhile (m--) {\r\n\t\tint op,l,r;\r\n\t\tscanf(\"%d%d%d\",&op,&l,&r);\r\n\t\tif (op==1) {\r\n\t\t\tint k;\r\n\t\t\tscanf(\"%d\",&k);\r\n\t\t\tupdate(rt,1,n,l,r,k);\r\n\t\t}\r\n\t\telse printf(\"%lld\\n\",query(rt,1,n,l,r));\r\n\t}\r\n\tassert(tot<maxn);\r\n\treturn 0;\r\n}\r\n"
    },
    {
        "username": "origami100",
        "id": 16952,
        "date": "2020-12-14 10:28:33",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nstruct node{\r\n\tll s, e, m, v, lazyadd;\r\n\tnode *l, *r;\r\n\tnode(ll _s, ll _e): s(_s), e(_e){\r\n\t\tm = (s + e) / 2;\r\n\t\tv = 0;\r\n\t\tlazyadd = 0;\r\n\t\tl = NULL;\r\n\t\tr = NULL;\r\n\t}\r\n\tvoid add(ll x, ll y, ll val) {\r\n    \tif (s == x && e == y) lazyadd += val;\r\n    \telse {\r\n        \tif (x > m){\r\n        \t\tif(r == NULL){\r\n        \t\t\tr = new node(m + 1, e);\r\n\t\t\t\t}\r\n\t\t\t\tr->add(x, y, val);\r\n\t\t\t}\r\n            else if (y <= m){\r\n            \tif(l == NULL){\r\n            \t\tl = new node(s, m);\r\n\t\t\t\t}\r\n\t\t\t\tl->add(x, y, val);\r\n\t\t\t}\r\n            else{\r\n            \tif(l == NULL){\r\n            \t\tl = new node(s, m);\r\n\t\t\t\t}\r\n\t\t\t\tl->add(x, m, val);\r\n\t\t\t\tif(r == NULL){\r\n        \t\t\tr = new node(m + 1, e);\r\n\t\t\t\t}\r\n\t\t\t\tr->add(m + 1, y, val);\r\n\t\t\t}\r\n\t\t\tif(l == NULL){\r\n\t\t\t\tv = r->value();\r\n\t\t\t}else if(r == NULL){\r\n\t\t\t\tv = l->value();\r\n\t\t\t}else{\r\n\t\t\t\tv = l->value() + r->value();\r\n\t\t\t}\r\n    \t}\r\n\t}\r\n\tll value() {\r\n\t\tif(lazyadd == 0) return v;\r\n    \tif (s==e) { v+=lazyadd; lazyadd=0; return v; }\r\n    \tv += lazyadd * (e - s + 1);\r\n    \tif(r == NULL){\r\n    \t\tr = new node(m + 1, e);\r\n\t\t}\r\n\t\tr->lazyadd += lazyadd;\r\n\t\tif(l == NULL){\r\n\t\t\tl = new node(s, m);\r\n\t\t}\r\n\t\tl->lazyadd += lazyadd;\r\n    \tlazyadd = 0;\r\n    \treturn v;\r\n\t}\r\n\tll query(ll x, ll y) {\r\n    \tvalue();\r\n    \tif (s==x && e==y) return v;\r\n    \tif (x>m){\r\n    \t\tif(r == NULL){\r\n    \t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\treturn r->query(x, y);\r\n\t\t}\r\n    \tif (y<=m){\r\n    \t\tif(l == NULL){\r\n    \t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\treturn l->query(x, y);\r\n\t\t}\r\n\t\tll res = 0;\r\n\t\tif(l == NULL) res += 0;\r\n\t\telse res += l->query(x, m);\r\n\t\tif(r == NULL) res += 0;\r\n\t\telse res += r->query(m + 1, y);\r\n\t\treturn res;\r\n\t}\r\n\tvoid debug(){\r\n\t\tcout << s << ' ' << e << \": \" << v << ' ' << lazyadd << '\\n';\r\n\t\tif(s != e){\r\n\t\t\tl->debug();\r\n\t\t\tr->debug();\r\n\t\t}\r\n\t}\r\n} *root;\r\nint main(){\r\n\tios_base::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tll n, q;\r\n\tcin >> n >> q;\r\n\troot = new node(0, n - 1);\r\n\tfor(ll i = 0; i < q; i++){\r\n\t\tll t;\r\n\t\tcin >> t;\r\n\t\tif(t == 1){\r\n\t\t\tll l, r, k;\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\tl--; r--;\r\n\t\t\troot->add(l, r, k);\r\n\t\t}else{\r\n\t\t\tll l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tl--; r--;\r\n\t\t\tcout << root->query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n}"
    },
    {
        "username": "chicken",
        "id": 16951,
        "date": "2020-12-14 10:28:32",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\n\r\nstruct node{\r\n    ll s, e, m, v, lazy;\r\n    node *l, *r;\r\n    node(ll _s, ll _e){\r\n        s = _s; e = _e;\r\n        m = (s + e) / 2;\r\n        v = 0; lazy = 0;\r\n    }\r\n    void create(){\r\n        if(s != e){\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n    void propo(){\r\n        if(l == nullptr) create();\r\n        v += (e-s+1) * lazy;\r\n        if(s != e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n    ll query(ll x, ll y){\r\n        propo();\r\n        if(s == x && e == y) return v;\r\n        if(x > m) return r->query(x, y);\r\n        if(y <= m) return l->query(x, y);\r\n        return l->query(x, m) + r->query(m+1, y);\r\n    }\r\n    void update(ll x, ll y, ll val){\r\n        propo();\r\n        if(s == x && e == y){\r\n            lazy += val;\r\n            return;\r\n        } else{\r\n            if(x > m) r->update(x, y, val);\r\n            else if(y <= m) l->update(x, y, val);\r\n            else{\r\n                l->update(x, m, val);\r\n                r->update(m+1, y, val);\r\n            }\r\n            l->propo();\r\n            r->propo();\r\n            v = l->v + r->v;\r\n        }\r\n    }\r\n} *root = new node(-100, 1e9+100);\r\n\r\nint main(){\r\n    ll n, q; cin >> n >> q;\r\n    for(ll i = 0; i < q; i ++){\r\n        ll inst; cin >> inst;\r\n        if(inst == 1){\r\n            ll x, y, v;\r\n            cin >> x >> y >> v;\r\n            root->update(x, y, v);\r\n        } else{\r\n            ll x, y;\r\n            cin >> x >> y;\r\n            cout << root->query(x, y) << '\\n';\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "kym",
        "id": 16912,
        "date": "2020-12-14 10:10:05",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int ll \r\n#define FOR(i,s,e) for(ll i = s; i <= (ll)e; ++i)\r\n#define DEC(i,s,e) for(ll i = s; i >= (ll)e; --i)\r\n#define IAMSPEED ios_base::sync_with_stdio(false); cin.tie(0);\r\n#ifdef LOCAL\r\n#define db(x) cerr << #x << \"=\" << x << \"\\n\"\r\n#define db2(x, y) cerr << #x << \"=\" << x << \" , \" << #y << \"=\" << y << \"\\n\"\r\n#define db3(a,b,c) cerr<<#a<<\"=\"<<a<<\",\"<<#b<<\"=\"<<b<<\",\"<<#c<<\"=\"<<c<<\"\\n\"\r\n#define dbv(v) cerr << #v << \":\"; for (auto ite : v) cerr << ite << ' '; cerr <<\"\\n\"\r\n#define dbvp(v) cerr << #v << \":\"; for (auto ite : v) cerr << \"{\"  << ite.f << ',' << ite.s << \"} \"; cerr << \"\\n\"\r\n#define dba(a,ss,ee) cerr << #a << \":\"; FOR(ite,ss,ee) cerr << a[ite] << ' '; cerr << \"\\n\"\r\n#else\r\n#define db(x)\r\n#define db2(x,y)\r\n#define db3(a,b,c)\r\n#define dbv(v)\r\n#define dbvp(v)\r\n#define dba(a,ss,ee)\r\n#endif\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\n#define ll long long \r\n#define pb push_back\r\n#define all(x) (x).begin(), (x).end()\r\n#define f first\r\n#define s second\r\n#define g0(x) get<0>(x)\r\n#define g1(x) get<1>(x)\r\n#define g2(x) get<2>(x)\r\n#define g3(x) get<3>(x)\r\n#define reach cerr << \"LINE: \" << __LINE__ << \"\\n\";\r\ntypedef pair <ll, ll> pi;\r\ntypedef tuple<ll,ll,ll> ti3;\r\nstring cts(char x) {string t(1,x); return t;}\r\nll rand(ll a, ll b) { return a + rng() % (b-a+1); }\r\nconst int MOD = 1e9 + 7;\r\nconst int inf = (int)1e9 + 500;\r\nconst long long oo = (ll)1e18 + 500;\r\ntemplate <typename T> bool chmax(T& a, const T b) { return a<b ? a = b, 1 : 0; }\r\ntemplate <typename T> bool chmin(T& a, const T b) { return a>b ? a = b, 1 : 0; }\r\nconst int MAXN = -1;\r\n#ifndef LOCAL\r\n#define cerr if(0)cout\r\n#endif\r\nstruct node {\r\n    node *l, *r;\r\n    int val, s, m, e, lazyadd;\r\n    node(int _s, int _e): s(_s), e(_e), m((_s+_e)/2), val(0), lazyadd(0), l(NULL), r(NULL) {}\r\n    int value() { //returns the value of the current node after lazy propagating\r\n        if (s == e) {\r\n\t\t\tval+=lazyadd;\r\n\t\t\tlazyadd=0;\r\n\t\t\treturn val;\r\n\t\t}\r\n        if (lazyadd == 0) return val;\r\n        val += lazyadd * (e-s+1);\r\n        if (l == NULL) l = new node(s, m);\r\n        if (r == NULL) r = new node(m+1, e);\r\n        l->lazyadd += lazyadd, r->lazyadd += lazyadd;\r\n        lazyadd = 0;\r\n        return val;\r\n    }\r\n    void add(int x, int y, int v) {\r\n        if (s == x && e == y) lazyadd += v;\r\n        else {\r\n            if (x > m) {\r\n                if (r == NULL) r = new node(m+1, e);\r\n                r->add(x, y, v);\r\n            }\r\n            else if (y <= m) {\r\n                if (l == NULL) l = new node(s, m);\r\n                l->add(x, y, v);\r\n            }\r\n            else {\r\n                if (r == NULL) r = new node(m+1, e);\r\n                if (l == NULL) l = new node(s, m);\r\n                l->add(x, m, v), r->add(m+1, y, v);\r\n            }\r\n            if (l != NULL && r != NULL) val = l->value() + r->value(); //Change here for max\r\n            else if (l == NULL) val = r->value();\r\n            else if (r == NULL) val = l->value();\r\n        }\r\n    }\r\n    int query(int x, int y) {\r\n        value();\r\n        if (s == x && e == y) return value();\r\n        if (x > m) return (r==NULL)? 0:r->query(x, y);\r\n        if (y <= m) return (l==NULL)? 0:l->query(x, y);\r\n        if (l == NULL && r != NULL) return r->query(m+1, y);\r\n        if (l != NULL && r == NULL) return l->query(x, m);\r\n        if (l != NULL && r != NULL) return l->query(x, m)+r->query(m+1, y); //Change here for max\r\n        return 0;\r\n    }\r\n} *root;\r\n\t\t\r\n\t\r\nint n, Q;\r\n\r\nint32_t main() \r\n{\r\n\tIAMSPEED\r\n\tcin >> n >> Q;\r\n\troot=new node(0,1e9);\r\n\twhile(Q--) {\r\n\t\tint op; cin >> op;\r\n\t\tif(op==1){\r\n\t\t\tint l,r,k;cin>>l>>r>>k;\r\n\t\t\troot->add(l,r,k);\r\n\t\t} else {\r\n\t\t\tint l,r ; cin >> l >> r;\r\n\t\t\tcout << root->query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n"
    },
    {
        "username": "fqdingsky",
        "id": 16907,
        "date": "2020-12-14 10:07:43",
        "code": "#import <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\n\r\nint main(){\r\n  ll N, Q;\r\n  cin >> N >> Q;\r\n  root = new node(0, N);\r\n\r\n  for(ll i = 0; i < Q; i++){\r\n    int num;\r\n    cin >> num;\r\n    if(num == 1){\r\n      ll l, r, k;\r\n      cin >> l >> r >> k;\r\n      root->add(l, r, k);\r\n    }\r\n    else{\r\n      ll l, r;\r\n      cin >> l >> r;\r\n      cout << root->range_sum(l, r) << \"\\n\";\r\n\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "maomao90",
        "id": 16901,
        "date": "2020-12-14 10:04:18",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node {\r\n    int lo, hi, mid;\r\n    ll mn, mx, sum;\r\n    bool isSet;\r\n    ll lazyAdd, lazySet;\r\n    node *l, *r;\r\n    node (int lo, int hi, ll arr[] = NULL): lo(lo), hi(hi), mid((lo + hi) / 2), mn(0), mx(0), sum(0), isSet(0), lazyAdd(0), lazySet(0), l(NULL), r(NULL) {\r\n        if (arr == NULL) return;\r\n        if (lo == hi) mn = mx = sum = arr[lo];\r\n        else {\r\n            l = new node(lo, mid, arr), r = new node(mid + 1, hi, arr);\r\n            combine();\r\n        }\r\n    }\r\n    void makeChild() {\r\n        if (lo == hi) return;\r\n        if (l != NULL) return;\r\n        l = new node(lo, mid);\r\n        r = new node(mid + 1, hi);\r\n    }\r\n    void selfSet(ll v) {\r\n        isSet = 1;\r\n        mn = mx = lazySet = v;\r\n        sum = v * (hi - lo + 1);\r\n        lazyAdd = 0;\r\n    }\r\n    void selfAdd(ll v) {\r\n        if (isSet) {\r\n\t\t\tselfSet(v + lazySet);\r\n\t\t\treturn;\r\n\t\t}\r\n        mn += v, mx += v, lazyAdd += v;\r\n        sum += v * (hi - lo + 1);\r\n    }\r\n    void propo() {\r\n        if (lo == hi) return;\r\n        if (isSet) {\r\n            l -> selfSet(lazySet), r -> selfSet(lazySet);\r\n            isSet = lazySet = 0;\r\n        }   \r\n        if (lazyAdd != 0) {\r\n            l -> selfAdd(lazyAdd), r -> selfAdd(lazyAdd);\r\n            lazyAdd = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l -> sum + r -> sum;\r\n        mn = min(l -> mn, r -> mn);\r\n        mx = max(l -> mx, r -> mx);\r\n    }\r\n\tvoid add(int p, ll v) {\r\n\t\tadd(p, p, v);\r\n\t}\r\n    void add(int s, int e, ll v) {\r\n\t\tif (e < s) return;\r\n\t\tif (lo >= s && hi <= e) {\r\n\t\t\tselfAdd(v);\r\n\t\t\treturn;\r\n\t\t}\r\n        makeChild(); \r\n\t\tpropo();\r\n        if (s <= mid) l -> add(s, e, v);\r\n        if (e > mid) r -> add(s, e, v);\r\n        combine();\r\n    }\r\n\tvoid set(int p, ll v) {\r\n\t\tset(p, p, v);\r\n\t}\r\n    void set(int s, int e, ll v) {\r\n\t\tif (e < s) return;\r\n\t\tif (lo >= s && hi <= e) {\r\n\t\t\tselfSet(v);\r\n\t\t\treturn;\r\n\t\t}\r\n        makeChild(); \r\n\t\tpropo();\r\n        if (s <= mid) l -> set(s, e, v);\r\n        if (e > mid) r -> set(s, e, v);\r\n        combine();\r\n    }\r\n    ll rangeSum(int s, int e) {\r\n\t\tif (lo >= s && hi <= e) return sum;\r\n        if (l == NULL || isSet) return (sum / (hi - lo + 1)) * (e - s + 1);\r\n        propo();\r\n        if (e <= mid) return l -> rangeSum(s, e);\r\n        if (s > mid) return r -> rangeSum(s, e);\r\n        return l -> rangeSum(s, mid) + r -> rangeSum(mid + 1, e);\r\n    }\r\n    ll rangeMin(int s, int e) {\r\n        if (lo == s && hi == e) return mn;\r\n        if (l == NULL || isSet) return mn;\r\n        propo();\r\n        if (e <= mid) return l -> rangeMin(s, e);\r\n        if (s > mid) return r -> rangeMin(s, e);\r\n        return min(l -> rangeMin(s, mid), r -> rangeMin(mid + 1, e));\r\n    }\r\n    ll rangeMax(int s, int e) {\r\n        if (lo == s && hi == e) return mx;\r\n        if (l == NULL || isSet) return mx;\r\n        propo();\r\n        if (e <= mid) return l -> rangeMax(s, e);\r\n        if (s > mid) return r -> rangeMax(s, e);\r\n        return max(l -> rangeMax(s, mid), r -> rangeMax(mid + 1, e));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main() {\r\n\tint n, q; scanf(\"%d%d\", &n, &q);\r\n\troot = new node(1, n);\r\n\tfor (int i = 0; i < q; i++) {\r\n\t\tint t, l, r; scanf(\"%d%d%d\", &t, &l, &r);\r\n\t\tif (t == 1) {\r\n\t\t\tint k; scanf(\"%d\", &k);\r\n\t\t\troot -> add(l, r, k);\r\n\t\t} else {\r\n\t\t\tprintf(\"%lld\\n\", root -> rangeSum(l, r));\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n"
    },
    {
        "username": "jiahng",
        "id": 16609,
        "date": "2020-12-13 16:29:36",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\ntypedef pair<ll,ll> pi;\r\ntypedef vector <ll> vi;\r\ntypedef vector <pi> vpi;\r\ntypedef pair<pi,ll> pii;\r\ntypedef set <ll> si;\r\ntypedef long double ld;\r\n#define f first\r\n#define s second\r\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\r\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\r\n#define pb push_back\r\n#define all(x) (x).begin(), (x).end()\r\n#define lbd(x, y) lower_bound(all(x), y)\r\n#define ubd(x, y) upper_bound(all(x), y)\r\n#define aFOR(i,x) for (auto i: x)\r\n#define mem(x,i) memset(x,i,sizeof x)\r\n#define fast ios_base::sync_with_stdio(false),cin.tie(0)\r\n#define int ll\r\nint N,Q;\r\nstruct node{\r\n\tint s,e,m,val = 0,lazy = 0;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\t\r\n\tnode(int ss,int ee){\r\n\t\ts = ss; e = ee; m = (s + e) / 2;\r\n\t}\r\n\t\r\n\tvoid create(){\r\n\t\tif (l == nullptr){\r\n\t\t\tl = new node(s,m);\r\n\t\t\tr = new node(m + 1, e);\r\n\t\t}\r\n\t}\r\n\t\t\t\r\n\tvoid prop(){\r\n\t\tif (s == e || lazy == 0) return;\r\n\t\tcreate();\r\n\t\tl->lazy += lazy; r->lazy += lazy;\r\n\t\tl->val += (l->e - l->s + 1) * lazy;\r\n\t\tr->val += (r->e - r->s + 1) * lazy;\r\n\t\tlazy = 0;\r\n\t}\r\n\t\r\n\tint qry(int a,int b){\r\n\t\tprop();\r\n\t\tif (a <= s && e <= b) return val;\r\n\t\telse if (a > e || s > b) return 0;\r\n\t\tcreate();\r\n\t\treturn l->qry(a,b) + r->qry(a,b);\r\n\t}\r\n\t\r\n\tvoid upd(int a,int b,int c){\r\n\t\tprop();\r\n\t\tif (a <= s && e <= b){\r\n\t\t\tval += (e - s + 1) * c;\r\n\t\t\tlazy += c;\r\n\t\t\treturn;\r\n\t\t}else if (a > e || s > b) return;\r\n\t\tcreate();\r\n\t\tl->upd(a,b,c); r->upd(a,b,c);\r\n\t\tval = l->val + r->val;\r\n\t}\r\n}*root;\r\n\r\nint32_t main(){\r\n\tfast;\r\n\t\r\n\tcin >> N >> Q;\r\n\t\r\n\troot = new node(1,N);\r\n\tint a,b,c,t;\r\n\tFOR(i,1,Q){\r\n\t\tcin >> t;\r\n\t\tif (t == 1){\r\n\t\t\tcin >> a >> b >> c;\r\n\t\t\troot->upd(a,b,c);\r\n\t\t}else{\r\n\t\t\tcin >> a >> b;\r\n\t\t\tcout << root->qry(a,b) << '\\n';\r\n\t\t}\r\n\t}\r\n\t\t\r\n\t\r\n}\r\n\r\n"
    },
    {
        "username": "YeoBL20",
        "id": 16601,
        "date": "2020-12-13 16:21:36",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\nstruct node{\r\n\tint s, e, m, val ,lazy;\r\n\tnode *l, *r; \r\n\tnode (int S, int E){ \r\n\t\ts = S, e = E, m = (s+e)/2;\r\n\t\tval = 0; \r\n\t\tlazy = 0; \r\n\t}\r\n\tvoid create(){\r\n\t\tif(s != e){ \r\n\t\t\t\tl = new node(s, m);\r\n\t\t\t\tr = new node(m+1, e); \r\n\t\t}\r\n\t}\r\n\tvoid propogate(){\r\n\t\tif (lazy==0) return; \r\n\t\tval+=lazy*(e-s+1); \r\n\t\tif (l==nullptr) create();\r\n\t\tif (s != e){ \r\n\t\t\tl->lazy+=lazy;\r\n\t\t\tr->lazy+=lazy;\r\n\t\t}\r\n\t\tlazy=0; \r\n\t}\r\n\tvoid update(int S, int E, int V){ \r\n\t\tif (l==nullptr) create();\r\n\t\tif(s==S && e==E) lazy += V; \r\n\t\telse{ \r\n\t\t\tif(E <= m) l->update(S, E, V); \r\n\t\t\telse if (m < S) r->update(S, E, V); \r\n\t\t\telse l->update(S, m, V),r->update(m+1, E, V);\r\n\t\t\tl->propogate(),r->propogate();\r\n\t\t\tval = l->val + r->val; \r\n\t\t}\r\n\t}\r\n\tint query(int S, int E){\r\n\t\tif (l==nullptr) create();\r\n\t\tpropogate(); \r\n\t\tif(s == S && e == E) return val; \r\n\t\telse if(E <= m) return l->query(S, E); \r\n\t\telse if(S >= m+1) return r->query(S, E); \r\n\t\telse return l->query(S, m) + r->query(m+1, E); \r\n\t}\r\n} *root;\r\nint32_t main(){\r\n  ios::sync_with_stdio(false);\r\n  cin.tie(0);\r\n  cout.tie(0);\r\n  int a,b,c,d,e; cin >> a >> b;\r\n  root = new node(1,a);\r\n  while (b--){\r\n    cin >> c;\r\n    if (c==1){\r\n      cin >> c >> d >> e;\r\n      root->update(c,d,e);\r\n    }\r\n    else{\r\n      cin >> c >> d;\r\n      cout << root->query(c,d) << '\\n';\r\n    }\r\n  }\r\n}\r\n"
    },
    {
        "username": "codingisfun",
        "id": 16530,
        "date": "2020-12-13 14:18:14",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint N, Q;\r\nstruct st\r\n{\r\n    private:int s, e;\r\n    private:long long total = 0, lazy = 0;\r\n    private:st *L = nullptr, *R = nullptr;\r\n\r\n    public:st(int _s, int _e)\r\n    {\r\n        s = _s;\r\n        e = _e;\r\n        total = 0;\r\n        lazy = 0;\r\n        if(s != e)\r\n        {\r\n            L = nullptr;\r\n            R = nullptr;\r\n        }\r\n    }\r\n\r\n    private:void makeChild()\r\n    {\r\n        if(s != e)\r\n        {\r\n            if(L == nullptr)\r\n            {\r\n                int m = s + ((e - s) >> 1);\r\n                L = new st(s, m);\r\n                R = new st(m + 1, e);\r\n            }\r\n        }\r\n    }\r\n\r\n    private:void propagate()\r\n    {\r\n        if(lazy != 0)\r\n        {\r\n            total += lazy * (e - s + 1);\r\n            if(s != e)\r\n            {\r\n                makeChild();\r\n                L -> lazy += lazy;\r\n                R -> lazy += lazy;\r\n            }\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    public:void update(int us, int ue, long long delta)\r\n    {\r\n        propagate();\r\n        if(us <= s && e <= ue)\r\n        {\r\n            lazy += delta;\r\n            propagate();\r\n            return;\r\n        }\r\n\r\n        else if(s > ue || us > e)\r\n            return;\r\n\r\n        else\r\n        {\r\n            makeChild();\r\n            L -> update(us, ue, delta);\r\n            R -> update(us, ue, delta);\r\n            total = (L -> total) + (R -> total);\r\n        }\r\n    }\r\n\r\n    public:long long query(int qs, int qe)\r\n    {\r\n        propagate();\r\n        if(qs <= s && e <= qe)\r\n            return total;\r\n\r\n        else if(qs > e || s > qe)\r\n            return 0;\r\n\r\n        else\r\n        {\r\n            makeChild();\r\n            return L -> query(qs, qe) + R -> query(qs, qe);\r\n        }\r\n    }\r\n};\r\n\r\nst *root = new st(-100, (int)(1E9) + 100);\r\nint main()\r\n{\r\n    scanf(\"%d%d\", &N, &Q);\r\n    for(int i = 1; i <= Q; i++)\r\n    {\r\n        int type;\r\n        scanf(\"%d\", &type);\r\n\r\n        if(type == 1)\r\n        {\r\n            int us, ue;\r\n            long long delta;\r\n            scanf(\"%d%d%lld\", &us, &ue, &delta);\r\n            root -> update(us, ue, delta);\r\n        }\r\n\r\n        else\r\n        {\r\n            int qs, qe;\r\n            scanf(\"%d%d\", &qs, &qe);\r\n            printf(\"%lld\\n\", root -> query(qs, qe));\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "dsyz",
        "id": 16496,
        "date": "2020-12-13 13:23:51",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\n#define MAXN (10005)\r\nstruct node{\r\n  ll s,e,m,val,lazy;\r\n  node *l,*r;\r\n  node(ll S,ll E){\r\n    s = S;\r\n    e = E;\r\n    m = (s + e) / 2;\r\n    val = 0;\r\n    lazy = 0;\r\n    // if(s != e){\r\n    //   l = new node(s,m);\r\n    //   r = new node(m + 1,e);\r\n    // }\r\n  }\r\n  void create(){\r\n    if(l == nullptr && s != e){\r\n      l = new node(s,m);\r\n      r = new node(m + 1,e);\r\n    }\r\n  }\r\n  void propagate(){\r\n    create();\r\n    if(lazy == 0){\r\n      return;\r\n    }\r\n    val += lazy * (e - s + 1);\r\n    if(s != e){\r\n      l->lazy += lazy;\r\n      r->lazy += lazy;\r\n    }\r\n    lazy = 0;\r\n  }\r\n  void update(ll S,ll E,ll v){\r\n    if(s == S && e == E) lazy += v;\r\n    else{\r\n      create();\r\n      if(E <= m) l->update(S,E,v);\r\n      else if(S > m) r->update(S,E,v);\r\n      else l->update(S,m,v),r->update(m + 1,E,v);\r\n      l->propagate(),r->propagate();\r\n      val = l->val + r->val;\r\n    }\r\n  }\r\n  long long query(ll S,ll E){\r\n    create();\r\n    propagate();\r\n    if(s == S && e == E) return val;\r\n    else if(S > m) return r->query(S,E);\r\n    else if(E <= m) return l->query(S,E);\r\n    else return l->query(S,m) + r-> query(m + 1,E);\r\n  }\r\n} *root;\r\nint main() {\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  ll N,Q;\r\n  cin>>N>>Q;\r\n  root = new node(0,N + 1);\r\n  for(ll i = 0;i < Q;i++){\r\n    ll a;\r\n    cin>>a;\r\n    if(a == 1){\r\n      ll L,R,k;\r\n      cin>>L>>R>>k;\r\n      root -> update(L - 1,R - 1,k);\r\n    }else if(a == 2){\r\n      ll L,R;\r\n      cin>>L>>R;\r\n      cout<<root -> query(L - 1,R - 1)<<'\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "gyheva",
        "id": 16441,
        "date": "2020-12-13 02:25:05",
        "code": "\r\n#include<iostream>\r\n#include<cstdio>\r\n#include<set>\r\n#include<queue>\r\n#include<cmath>\r\n//#include<bits/stdc++.h>\r\nusing namespace std;\r\nint n,q,rt,m,l,r;\r\nlong long k;\r\nstruct node{\r\n    int ls[4600000],rs[4600000],cnt;\r\n    long long sum[4600000],adv[4600000];\r\n    void build(int &o,int l,int r){\r\n        o=++cnt;\r\n        //cout<<o<<\" \"<<l<<\" \"<<r<<endl;\r\n        adv[o]=sum[o]=0;\r\n    }\r\n    void pushup(int o,int l,int r){\r\n        sum[o]=sum[ls[o]]+sum[rs[o]];\r\n    }\r\n    void puttag(int o,int l,int r,long long ad){\r\n        adv[o]+=ad;\r\n        sum[o]+=(long long)(r-l+1)*ad;\r\n    }\r\n    void pushdown(int o,int l,int r){\r\n        if(adv[o]==0||l==r) return;\r\n        int mid=(l+r)>>1;\r\n        //cout<<\"pushdown:\"<<o<<\" \"<<ls[o]<<\" \"<<rs[o]<<endl;\r\n        puttag(ls[o],l,mid,adv[o]);\r\n        puttag(rs[o],mid+1,r,adv[o]);\r\n        adv[o]=0;\r\n    }\r\n    \r\n    void add(int o,int l,int r,int ql,int qr,long long ad){\r\n        if(ql<=l&&r<=qr){\r\n            puttag(o,l,r,ad);\r\n            return;\r\n        }\r\n        int mid=(l+r)>>1;\r\n        if(ls[o]==0) build(ls[o],l,mid);\r\n        if(rs[o]==0) build(rs[o],mid+1,r);\r\n        pushdown(o,l,r);\r\n        if(ql<=mid) add(ls[o],l,mid,ql,qr,ad);\r\n        if(qr>mid) add(rs[o],mid+1,r,ql,qr,ad);\r\n        pushup(o,l,r);\r\n    }\r\n    long long query(int o,int l,int r,int ql,int qr){\r\n        if(ql<=l&&r<=qr) return sum[o];\r\n        int mid=(l+r)>>1;\r\n        long long ans=0;\r\n        if(ls[o]==0) build(ls[o],l,mid);\r\n        if(rs[o]==0) build(rs[o],mid+1,r);\r\n        pushdown(o,l,r);\r\n        if(ql<=mid) ans+=query(ls[o],l,mid,ql,qr);\r\n        if(qr>mid) ans+=query(rs[o],mid+1,r,ql,qr);\r\n        return ans;\r\n    }\r\n}tr;\r\nint main(){\r\n    scanf(\"%d%d\",&n,&q);\r\n    tr.build(rt,1,n);\r\n    for(int i=1;i<=q;i++){\r\n        scanf(\"%d%d%d\",&m,&l,&r);\r\n        if(m==1){\r\n            scanf(\"%lld\",&k);\r\n            tr.add(rt,1,n,l,r,k);\r\n        }\r\n        else{\r\n            printf(\"%lld\\n\",tr.query(rt,1,n,l,r));\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "dsyz",
        "id": 16423,
        "date": "2020-12-13 00:53:53",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing ll = long long;\r\n#define MAXN (10005)\r\nstruct node{\r\n  ll s,e,m,val,lazy;\r\n  node *l,*r;\r\n  node(ll S,ll E){\r\n    s = S;\r\n    e = E;\r\n    m = (s + e) / 2;\r\n    val = 0;\r\n    lazy = 0;\r\n    // if(s != e){\r\n    //   l = new node(s,m);\r\n    //   r = new node(m + 1,e);\r\n    // }\r\n  }\r\n  void create(){\r\n    if(s != e){\r\n      l = new node(s,m);\r\n      r = new node(m + 1,e);\r\n    }\r\n  }\r\n  void propagate(){\r\n    if(l == nullptr) create();\r\n    if(lazy == 0){\r\n      return;\r\n    }\r\n    val += lazy * (e - s + 1);\r\n    if(s != e){\r\n      l->lazy += lazy;\r\n      r->lazy += lazy;\r\n    }\r\n    lazy = 0;\r\n  }\r\n  void update(ll S,ll E,ll v){\r\n    if(s == S && e == E) lazy += v;\r\n    else{\r\n      if(l == nullptr) create();\r\n      if(E <= m) l->update(S,E,v);\r\n      else if(S > m) r->update(S,E,v);\r\n      else l->update(S,m,v),r->update(m + 1,E,v);\r\n      l->propagate(),r->propagate();\r\n      val = l->val + r->val;\r\n    }\r\n  }\r\n  long long query(ll S,ll E){\r\n    if(l == nullptr) create();\r\n    propagate();\r\n    if(s == S && e == E) return val;\r\n    else if(S > m) return r->query(S,E);\r\n    else if(E <= m) return l->query(S,E);\r\n    else return l->query(S,m) + r-> query(m + 1,E);\r\n  }\r\n} *root;\r\nint main() {\r\n  ios_base::sync_with_stdio(false);cin.tie(0);\r\n  ll N,Q;\r\n  cin>>N>>Q;\r\n  root = new node(0,N + 1);\r\n  for(ll i = 0;i < Q;i++){\r\n    ll a;\r\n    cin>>a;\r\n    if(a == 1){\r\n      ll L,R,k;\r\n      cin>>L>>R>>k;\r\n      root -> update(L - 1,R - 1,k);\r\n    }else if(a == 2){\r\n      ll L,R;\r\n      cin>>L>>R;\r\n      cout<<root -> query(L - 1,R - 1)<<'\\n';\r\n    }\r\n  }\r\n}"
    },
    {
        "username": "JustAWallaby",
        "id": 16419,
        "date": "2020-12-13 00:17:38",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\ntypedef pair<int,int> pi;\r\n#define f first\r\n#define s second\r\n#define FAST ios_base::sync_with_stdio(0); cin.tie(0);\r\n#define all(x) x.begin(),x.end()\r\ntypedef pair<int, pi> pii;\r\n\r\nconst int maxn = 500010;\r\nconst int INF = LLONG_MAX/2;\r\n\r\nstruct node {\r\n\tint s,e,m,v;\r\n\tint lazy = 0;\r\n\tnode *l = 0, *r = 0;\r\n\t\r\n\tnode (int _s, int _e) {\r\n\t\ts = _s; e = _e; m = (s + e)/2;\r\n\t\tv = lazy = 0;\r\n\t}\r\n\t\r\n\tvoid create() {\r\n\t\tif (s != e) {\r\n\t\t\tl = new node(s,m);\r\n\t\t\tr = new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\t\r\n\tvoid push() {\r\n\t\tif (lazy == 0) return;\r\n\t\tv += lazy * (e - s + 1);\r\n\t\tif (s != e) {\r\n\t\t\tif (l == 0) create();\r\n\t\t\tl -> lazy += lazy;\r\n\t\t\tr -> lazy += lazy;\r\n\t\t}\r\n\t\t\r\n\t\tlazy = 0;\r\n\t}\r\n\r\n\r\n\tvoid upd(int x, int y, int newv) {\r\n\t\tif (s == x and e == y) lazy += newv;\r\n\t\telse {\r\n\t\t\tif (l == 0) create();\r\n\t\t\t\r\n\t\t\tif (x > m) r -> upd(x,y,newv);\r\n\t\t\telse if (y <= m) l -> upd(x,y,newv);\r\n\t\t\telse l -> upd(x,m,newv), r -> upd(m+1,y,newv);\r\n\t\t\t\r\n\t\t\tl -> push();\r\n\t\t\tr -> push();\r\n\t\t\tv = l -> v + r -> v;\r\n\t\t}\r\n\t}\r\n\t\r\n\tint rsum(int x, int y) {\r\n\t\tif (l == 0) create();\r\n\t\t\r\n\t\tpush();\r\n\t\tif (s == x and e == y) return v;\r\n\t\telse if (x > m) return r -> rsum(x,y);\r\n\t\telse if (y <= m) return l -> rsum(x,y);\r\n\t\telse return l -> rsum(x,m) + r -> rsum(m+1,y);\r\n\t}\r\n}*root;\r\n\r\nint32_t main() {\r\n\tFAST\r\n\tint n, Q; cin >> n >> Q;\r\n\t\r\n\troot = new node(1, n);\r\n\tfor (int i =0;i<Q;i++) {\r\n\t\tint type; cin >> type;\r\n\t\tif (type == 1) {\r\n\t\t\tint l,r,k; cin >> l >> r >> k;\r\n\t\t\troot -> upd(l,r,k);\r\n\t\t} else {\r\n\t\t\tint l,r; cin >> l >> r;\r\n\t\t\tcout << root -> rsum(l,r) << \"\\n\";\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
    },
    {
        "username": "siewjh",
        "id": 16387,
        "date": "2020-12-12 22:51:26",
        "code": "#include <iostream>\r\nusing namespace std;\r\nstruct node {\r\n\tint s, e, m; long long val, lazy;\r\n\tnode* l = nullptr, * r = nullptr;\r\n\tnode(int _s, int _e) {\r\n\t\ts = _s, e = _e, m = (s + e) / 2, val = 0, lazy = 0;\r\n\t}\r\n\tvoid makechild() {\r\n\t\tif (l == nullptr) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m + 1, e);\r\n\t\t}\r\n\t}\r\n\tvoid propo() {\r\n\t\tif (lazy == 0) return;\r\n\t\tval += lazy * (long long)(e - s + 1);\r\n\t\tif (s != e) {\r\n\t\t\tmakechild();\r\n\t\t\tl->lazy += lazy;\r\n\t\t\tr->lazy += lazy;\r\n\t\t}\r\n\t\tlazy = 0;\r\n\t}\r\n\tvoid update(int left, int right, long long v) {\r\n\t\tif (s == left && e == right) lazy += v;\r\n\t\telse {\r\n\t\t\tmakechild();\r\n\t\t\tif (right <= m) l->update(left, right, v);\r\n\t\t\telse if (left > m) r->update(left, right, v);\r\n\t\t\telse {\r\n\t\t\t\tl->update(left, m, v);\r\n\t\t\t\tr->update(m + 1, right, v);\r\n\t\t\t}\r\n\t\t\tl->propo(); r->propo();\r\n\t\t\tval = l->val + r->val;\r\n\t\t}\r\n\t}\r\n\tlong long query(int left, int right) {\r\n\t\tpropo();\r\n\t\tif (s == left && e == right) return val;\r\n\t\telse {\r\n\t\t\tmakechild();\r\n\t\t\tif (right <= m) return l->query(left, right);\r\n\t\t\telse if (left > m) return r->query(left, right);\r\n\t\t\telse return l->query(left, m) + r->query(m + 1, right);\r\n\t\t}\r\n\t}\r\n}*root;\r\nint main() {\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(0); cout.tie(0);\r\n\tint nums, op; cin >> nums >> op;\r\n\troot = new node(1, nums);\r\n\tfor (int i = 0; i < op; i++) {\r\n\t\tint x; cin >> x;\r\n\t\tif (x == 1) {\r\n\t\t\tint l, r; long long v; cin >> l >> r >> v;\r\n\t\t\troot->update(l, r, v);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint l, r; cin >> l >> r;\r\n\t\t\tcout << root->query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}"
    },
    {
        "username": "dedekindcompleteness21",
        "id": 16367,
        "date": "2020-12-12 21:37:43",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n    int s,e,m;\r\n    int val,lazy;\r\n    node *l=nullptr, *r=nullptr;\r\n\r\n    node (int S, int E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n        //do not create the children here right now\r\n    }\r\n\r\n    void propogate(){\r\n        if (lazy==0) return; //nothing happens\r\n\r\n        val += lazy*(e-s+1); //(e-s+1) is the length of the range\r\n        if (l==nullptr) create();\r\n        if (s != e){//not a leaf, send tag to children\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n\r\n        lazy=0; //set our lazy tag value back to the sentinel\r\n    }\r\n\r\n    void create(){\r\n        if (s!=e){//important --> dont create children if already leaf\r\n            l = new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n\r\n    void update(int S, int E, int V){\r\n        if (l==nullptr && s!=e) create();\r\n        if (s==S && e == E) lazy+=V; //update covers range, update lazy tag\r\n        else{ // so we have to go deeper\r\n            if (E <= m) l->update(S,E,V); //all in the left child\r\n            else if (m<S) r->update(S,E,V); //all in the right child\r\n\r\n            else l->update(S,m,V), r-> update(m+1, E,V);\r\n\r\n            l->propogate(), r->propogate();\r\n            //remember to propogate the children before you update yourself\r\n\r\n            val = l->val+r->val; //update the range sum\r\n        }\r\n    }\r\n\r\n    int query(int S, int E){\r\n        if (l==nullptr) create();\r\n        propogate(); //remember to propogate\r\n\r\n        if (s==S && e==E) return val; //case 1\r\n        else if (E<=m) return l->query(S,E);\r\n        else if (S>=m+1) return r->query(S,E);\r\n        else return l->query(S,m) + r-> query(m+1, E);\r\n    }\r\n}*root= new node(1,1000000010);\r\n\r\n\r\nint32_t main(){\r\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n    int n,q;\r\n    cin>>n>>q;\r\n\r\n    for (int i=0; i<q; i++){\r\n        int a;\r\n        cin>>a;\r\n        if (a==1){\r\n            int l,r,k;\r\n            cin>>l>>r>>k;\r\n            root->update(l,r,k);\r\n        }\r\n        else{\r\n            int l,r;\r\n            cin>>l>>r;\r\n            cout<<root->query(l,r)<<'\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "AJR",
        "id": 16314,
        "date": "2020-12-12 18:25:55",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node{\r\n    int s, e, m;\r\n    int val;\r\n    int lazy;\r\n    node *l = nullptr, *r = nullptr;\r\n    node (int S, int E){\r\n        s = S;\r\n        e = E;\r\n        m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n        l = nullptr; r = nullptr;\r\n    }\r\n    void create(){\r\n        if(l==nullptr){\r\n            if(s != e){\r\n                l = new node(s, m);\r\n                r = new node(m+1, e);\r\n            }\r\n        }\r\n    }\r\n    \r\n    void propogate(){\r\n        create();\r\n        if (lazy==0) return;\r\n        val+=lazy*(e-s+1);\r\n        if (s != e){\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0;\r\n    }\r\n    \r\n    void update(int S, int E, int V){\r\n        create();\r\n        propogate();\r\n        if(s==S && e==E) lazy += V;\r\n        else{\r\n            if(E <= m) l->update(S, E, V);\r\n            else if (m < S) r->update(S, E, V);\r\n            else l->update(S, m, V),r->update(m+1, E, V);\r\n            l->propogate(),r->propogate();\r\n            val = l->val + r->val;\r\n        }\r\n    }\r\n    \r\n    int query(int S, int E){\r\n        propogate();\r\n        if(l == nullptr) create();\r\n        if(s == S && e == E) return val;\r\n        else if(E <= m) return l->query(S, E);\r\n        else if(S >= m+1) return r->query(S, E);\r\n        else return l->query(S, m) + r->query(m+1, E);\r\n    }\r\n} *root = new node(1,1000000010);\r\n\r\n\r\ntypedef long long ll;\r\nint arraysize, functions;\r\nint32_t main(){\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cin >> arraysize >> functions;\r\n    root = new node(0, arraysize);\r\n    for(int i = 0; i < functions; i++){\r\n        int b;\r\n        cin >> b;\r\n        if(b == 1){\r\n            int start, end, plus; cin >> start >> end >> plus;\r\n            root -> update(start, end, plus);\r\n        }\r\n        else{\r\n            int start, end;\r\n            cin >> start >> end;\r\n            cout << root -> query(start, end) << '\\n';\r\n        }\r\n    }\r\n}\r\n\r\n//5 5\r\n//1 2 3 1\r\n//2 3 5\r\n//1 1 3 4\r\n//2 1 1\r\n//2 1 5\r\n"
    },
    {
        "username": "nianhe",
        "id": 16310,
        "date": "2020-12-12 18:19:49",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node{\r\n    int s, e, m;\r\n    int val;\r\n    int lazy;\r\n    node *l=nullptr, *r=nullptr;\r\n    node (int S, int E){\r\n        s = S;\r\n        e = E;\r\n        m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n\r\n    }\r\n    void create(){\r\n        if(s != e){\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n    \r\n    void propogate(){\r\n        if (lazy==0) return;\r\n        \r\n        \r\n        val+=lazy*(e-s+1);\r\n        if (l==nullptr) create();\r\n        if (s != e){\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n        lazy=0;\r\n    }\r\n    \r\n    void update(int S, int E, int V){\r\n        if (l==nullptr) create();\r\n        if(s==S && e==E) lazy += V;\r\n        else{\r\n            if(E <= m) l->update(S, E, V);\r\n            else if (m < S) r->update(S, E, V);\r\n            else l->update(S, m, V), r->update(m+1, E, V);\r\n            l->propogate(),r->propogate();\r\n            val = l->val + r->val;\r\n        }\r\n    }\r\n    \r\n    int query(int S, int E){\r\n        if(l == nullptr) create();\r\n        propogate();\r\n        \r\n        if(s == S && e == E) return val;\r\n        else if(E <= m) return l->query(S, E);\r\n        else if(S >= m+1) return r->query(S, E);\r\n        else return l->query(S, m) + r->query(m+1, E);\r\n    }\r\n} *root=new node(1,1000000010);\r\n\r\n\r\ntypedef long long ll;\r\nint arraysize, functions;\r\nint32_t main(){\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(0);\r\n    cin >> arraysize >> functions;\r\n    //root = new node(0, arraysize);\r\n    for(int i = 0; i < functions; i++){\r\n        int b;\r\n        cin >> b;\r\n        if(b == 1){\r\n            int start, end, plus; cin >> start >> end >> plus;\r\n            root -> update(start, end, plus);\r\n        }\r\n        else{\r\n            int start, end;\r\n            cin >> start >> end;\r\n            cout << root -> query(start, end) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "nianhe",
        "id": 16302,
        "date": "2020-12-12 18:16:58",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n    int s,e,m;\r\n    int val,lazy;\r\n    node *l=nullptr, *r=nullptr;\r\n\r\n    node (int S, int E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n        //do not create the children here right now\r\n    }\r\n\r\n    void propogate(){\r\n        if (lazy==0) return; //nothing happens\r\n\r\n        val += lazy*(e-s+1); //(e-s+1) is the length of the range\r\n        if (l==nullptr) create();\r\n        if (s != e){//not a leaf, send tag to children\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n\r\n        lazy=0; //set our lazy tag value back to the sentinel\r\n    }\r\n\r\n    void create(){\r\n        if (s!=e){//important --> dont create children if already leaf\r\n            l = new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n\r\n    void update(int S, int E, int V){\r\n        if (l==nullptr && s!=e) create();\r\n        if (s==S && e == E) lazy+=V; //update covers range, update lazy tag\r\n        else{ // so we have to go deeper\r\n            if (E <= m) l->update(S,E,V); //all in the left child\r\n            else if (m<S) r->update(S,E,V); //all in the right child\r\n\r\n            else l->update(S,m,V), r-> update(m+1, E,V);\r\n\r\n            l->propogate(), r->propogate();\r\n            //remember to propogate the children before you update yourself\r\n\r\n            val = l->val+r->val; //update the range sum\r\n        }\r\n    }\r\n\r\n    int query(int S, int E){\r\n        if (l==nullptr) create();\r\n        propogate(); //remember to propogate\r\n\r\n        if (s==S && e==E) return val; //case 1\r\n        else if (E<=m) return l->query(S,E);\r\n        else if (S>=m+1) return r->query(S,E);\r\n        else return l->query(S,m) + r-> query(m+1, E);\r\n    }\r\n}*root= new node(1,1000000010);\r\n\r\n\r\nint32_t main(){\r\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n    int n,q;\r\n    cin>>n>>q;\r\n\r\n    for (int i=0; i<q; i++){\r\n        int a;\r\n        cin>>a;\r\n        if (a==1){\r\n            int l,r,k;\r\n            cin>>l>>r>>k;\r\n            root->update(l,r,k);\r\n        }\r\n        else{\r\n            int l,r;\r\n            cin>>l>>r;\r\n            cout<<root->query(l,r)<<'\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "nianhe",
        "id": 16277,
        "date": "2020-12-12 17:49:27",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node{\r\n    int s,e,m;\r\n    int val,lazy;\r\n    node *l=nullptr, *r=nullptr;\r\n\r\n    node (int S, int E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n        lazy = 0;\r\n        //do not create the children here right now\r\n    }\r\n\r\n    void propogate(){\r\n        if (lazy==0) return; //nothing happens\r\n\r\n        val += lazy*(e-s+1); //(e-s+1) is the length of the range\r\n        if (l==nullptr) create();\r\n        if (s != e){//not a leaf, send tag to children\r\n            l->lazy+=lazy;\r\n            r->lazy+=lazy;\r\n        }\r\n\r\n        lazy=0; //set our lazy tag value back to the sentinel\r\n    }\r\n\r\n    void create(){\r\n        if (s!=e){//important --> dont create children if already leaf\r\n            l = new node(s,m);\r\n            r = new node(m+1,e);\r\n        }\r\n    }\r\n\r\n    void update(int S, int E, int V){\r\n        if (l==nullptr && s!=e) create();\r\n        if (s==S && e == E) lazy+=V; //update covers range, update lazy tag\r\n        else{ // so we have to go deeper\r\n            if (E <= m) l->update(S,E,V); //all in the left child\r\n            else if (m<S) r->update(S,E,V); //all in the right child\r\n\r\n            else l->update(S,m,V), r-> update(m+1, E,V);\r\n\r\n            l->propogate(), r->propogate();\r\n            //remember to propogate the children before you update yourself\r\n\r\n            val = l->val+r->val; //update the range sum\r\n        }\r\n    }\r\n\r\n    int query(int S, int E){\r\n        if (l==nullptr) create();\r\n        propogate(); //remember to propogate\r\n\r\n        if (s==S && e==E) return val; //case 1\r\n        else if (E<=m) return l->query(S,E);\r\n        else if (S>=m+1) return r->query(S,E);\r\n        else return l->query(S,m) + r-> query(m+1, E);\r\n    }\r\n}*root= new node(1,1000000010);\r\n\r\n\r\nint32_t main(){\r\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\r\n    int n,q;\r\n    cin>>n>>q;\r\n\r\n    for (int i=0; i<q; i++){\r\n        int a;\r\n        cin>>a;\r\n        if (a==1){\r\n            int l,r,k;\r\n            cin>>l>>r>>k;\r\n            root->update(l,r,k);\r\n        }\r\n        else{\r\n            int l,r;\r\n            cin>>l>>r;\r\n            cout<<root->query(l,r)<<'\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "vishalmohanty",
        "id": 16234,
        "date": "2020-12-12 16:55:14",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(0);\r\n    int n, q;\r\n    cin >> n >> q;\r\n\r\n    struct node{\r\n        int s, e, m;\r\n        long long val = 0;\r\n        long long lazy = 0;\r\n        node *l=nullptr, *r=nullptr;\r\n        node (int S, int E){\r\n            s = S, e = E, m = (s+e)/2;\r\n        }\r\n\r\n        void makeChild(){\r\n            if (l== nullptr){\r\n                l = new node(s, m);\r\n                r = new node(m+1, e);\r\n            }\r\n        }\r\n        void propogate(){\r\n            if (lazy==0) return;\r\n            val+=lazy*(e-s+1);\r\n            if (s != e){\r\n                makeChild();\r\n                l->lazy+=lazy;\r\n                r->lazy+=lazy;\r\n            }\r\n            lazy=0;\r\n        }\r\n        void update(int S, int E, long long V){\r\n            if(s==S && e==E) lazy += V;\r\n            else{\r\n                makeChild();\r\n                if(E <= m) l->update(S, E, V);\r\n                else if (m < S) r->update(S, E, V);\r\n                else l->update(S, m, V),r->update(m+1, E, V);\r\n                l->propogate(),r->propogate();\r\n\r\n                val = l->val + r->val;\r\n            }\r\n        }\r\n        long long query(int S, int E){\r\n            propogate();\r\n            if(s == S && e == E) return val;\r\n            else{\r\n                makeChild();\r\n                if(E <= m) return l->query(S, E);\r\n                else if(S >= m+1) return r->query(S, E);\r\n                else return l->query(S, m) + r->query(m+1, E);}\r\n        }\r\n    } *root;\r\n    root = new node(0, n+5);\r\n    int l, a, b;\r\n    long long c;\r\n    for (int i = 0; i < q; i++){\r\n        cin >> l >> a >> b;\r\n        if (l == 1){\r\n            cin >> c;\r\n            root->update(a, b, c);\r\n        }\r\n        else{\r\n            cout << root->query(a, b) << \"\\n\";\r\n        }\r\n    }\r\n    return 0;\r\n}"
    },
    {
        "username": "fyss006",
        "id": 16232,
        "date": "2020-12-12 16:54:58",
        "code": "#pragma GCC optimize(2)\r\n#pragma GCC optimize(3)\r\n#pragma GCC optimize(\"Ofast\")\r\n#pragma GCC optimize(\"inline\")\r\n#include<algorithm>\r\n#include<iostream>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<cstdio>\r\n#include<map>\r\n#include<cmath>\r\n#include<stack>\r\n#define Rint register int\r\n#define ll long long\r\nusing namespace std;\r\nll sum[10000005],m,n;\r\nll a[10000005],lazy[10000005],root,cnt;\r\nll ls[10000005],rs[10000005];\r\ninline void f(ll &p, ll l, ll r, ll v){\r\n    if(!p){\r\n        p=++cnt;\r\n    }\r\n    lazy[p]+=v;\r\n    sum[p]+=v*(r-l+1);\r\n    return;\r\n}\r\ninline void pushdown(ll p, ll l, ll r){\r\n    if(!lazy[p]) return;\r\n    ll mid; mid=(l+r)>>1;\r\n    f(ls[p],l,mid,lazy[p]); f(rs[p],mid+1,r,lazy[p]);\r\n    lazy[p]=0;\r\n}\r\n\r\ninline void update(ll &k,ll l, ll r, ll x, ll y, ll v){\r\n    if(!k){\r\n        k=++cnt;\r\n    }\r\n    if(l>=x&&r<=y){\r\n        f(k,l,r,v);\r\n        return;\r\n    }\r\n    pushdown(k,l,r);\r\n    ll mid;\r\n    mid=(l+r)>>1;\r\n    if(x<=mid) update(ls[k],l,mid,x,y,v);\r\n    if(y>mid) update(rs[k],mid+1,r,x,y,v);\r\n    sum[k]=sum[ls[k]]+sum[rs[k]];\r\n    return;\r\n}\r\ninline ll check(ll k, ll l,ll r, ll x, ll y){\r\n    if(!k) return 0;\r\n    if(l>=x&&r<=y){\r\n        return sum[k];\r\n    }\r\n    ll mid,ans=0;\r\n    mid=(l+r)>>1;\r\n    pushdown(k,l,r);\r\n    if(x<=mid){\r\n        ans+=check(ls[k],l,mid,x,y);\r\n    }\r\n    if(mid<y){\r\n        ans+=check(rs[k],mid+1,r,x,y);\r\n    }\r\n    return ans;\r\n}\r\nint main(){\r\n    std::ios::sync_with_stdio(false);\r\n    cin>>n>>m;\r\n    for(int i=1;i<=m;i++){\r\n        ll b,x,y,z;\r\n        cin>>b>>x>>y;\r\n        if(b==1){\r\n            cin>>z;\r\n            update(root,1,n,x,y,z);\r\n        }else{\r\n            cout<<check(root,1,n,x,y)<<endl;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n"
    },
    {
        "username": "exdanlol",
        "id": 16209,
        "date": "2020-12-12 16:34:28",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node{\r\n    int s, e, m, lazy = 0;\r\n    int val = 0;\r\n    node *l = nullptr, *r = nullptr;\r\n\r\n    node (int S, int E){\r\n        s = S, e = E, m = (s+e)/2;\r\n        val = 0;\r\n    }\r\n\r\n    void create(){\r\n        if (s != e){\r\n            l = new node(s, m);\r\n            r = new node(m+1, e);\r\n        }\r\n    }\r\n\r\n    void prop(){\r\n        if (lazy == 0) return;\r\n        if (l == nullptr) create();\r\n\r\n        val += lazy*(e-s+1);\r\n        if (s!=e){\r\n            l->lazy += lazy;\r\n            r->lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\n    void update(int S, int E, int V){\r\n        //printf(\"in %d %d %d %d %d\\n\", S, E, s, e, V);\r\n        if (s == S && e == E) {\r\n            lazy += V;\r\n            //printf(\"done\");\r\n        }\r\n        else{\r\n            if (l == nullptr) create();\r\n            //printf(\"out %d %d %d\\n\", S, E, V);\r\n\r\n            if (E <= m) l->update(S, E, V);\r\n            else if (m < S) r->update(S, E, V);\r\n            else {\r\n                l->update(S, m, V);\r\n                r->update(m+1, E, V);\r\n            }\r\n\r\n            l->prop(), r->prop();\r\n\r\n            val = l->val+ r->val;\r\n        }\r\n    }\r\n\r\n    int query(int S, int E){\r\n        if (l == nullptr) create();\r\n        prop();\r\n\r\n        if (s == S && e == E) return val;\r\n        else if (E<=m) return l->query(S, E);\r\n        else if (S >= m+1) return r->query(S, E);\r\n        else return l->query(S,m) + r->query(m+1, E);\r\n    }\r\n};\r\n\r\n\r\nint n, q, a, l, r, k;\r\nmain(){\r\n    scanf(\"%lld%lld\", &n, &q);\r\n    node root(0, n+5);\r\n    for (int i = 0; i < q; ++i){\r\n        scanf(\"%lld\", &a);\r\n        if (a == 1){\r\n            scanf(\"%lld%lld%lld\", &l, &r, &k);\r\n            root.update(l, r, k);\r\n        }\r\n        else{\r\n            scanf(\"%lld%lld\", &l, &r);\r\n            if (l > r) swap(l, r);\r\n            printf(\"%lld\\n\", root.query(l, r));\r\n        }\r\n    }\r\n    return 0;\r\n\r\n}\r\n"
    },
    {
        "username": "ecxx",
        "id": 16190,
        "date": "2020-12-12 16:20:20",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node {\r\n\tlong long s,e,m,val=0,lazy;\r\n\tnode *LL=NULL, *RR=NULL;\r\n\r\n\tnode(long long _s, long long _e) {\r\n\t\ts=_s;e=_e;m=(s+e)>>1;\r\n\t\tval=0;lazy=0;\r\n\r\n\t\tif (s==e) return;\r\n\t\t\r\n\t}\r\n\r\n\tvoid make() {\r\n\t\tif (!LL) {\r\n\t\t\tLL = new node(s,m);\r\n\t\t\tRR = new node(m+1,e);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid propo() {\r\n\r\n\t\tmake();\r\n\r\n\t\tif (lazy==0) return;\r\n\t\tval += lazy*(e-s+1);\r\n\r\n\t\tif (s!=e) {\r\n\t\t\tLL->lazy+=lazy;\r\n\t\t\tRR->lazy+=lazy;\r\n\t\t}\r\n\r\n\t\tlazy-=lazy;\r\n\r\n\t}\r\n\r\n\tvoid update(long long _s, long long _e, long long _v) {\r\n\t\tif (s==_s && e==_e) lazy += _v;\r\n\t\telse {\r\n\t\t\tmake();\r\n\t\t\tif (_e <= m) LL->update(_s,_e,_v);\r\n\t\t\telse if (m < _s) RR->update(_s,_e,_v);\r\n\t\t\telse {\r\n\t\t\t\tLL->update(_s, m, _v);\r\n\t\t\t\tRR->update(m+1, _e, _v);\r\n\t\t\t}\r\n\t\t\tLL->propo();\r\n\t\t\tRR->propo();\r\n\t\t\tval = LL->val + RR->val;\r\n\t\t}\r\n\t}\r\n\r\n\tlong long query(long long _s, long long _e) {\r\n\t\tpropo();\r\n\t\tif (s==_s && e==_e) return val;\r\n\t\telse if (_e<=m) return LL->query(_s,_e);\r\n\t\telse if (m <_s) return RR->query(_s,_e);\r\n\t\telse return LL->query(_s,m) + RR->query(m+1,_e);\r\n\t}\r\n\r\n};\r\n\r\nint main() {\r\n\tlong long N,Q,a,b,c,d;\r\n\tcin >> N >> Q;\r\n\r\n\tnode nod(0LL,N+1);\r\n\r\n\tfor (long long i = 0LL; i < Q; i++) {\r\n\t\tcin >> a;\r\n\t\tif (a==1LL) {\r\n\t\t\tcin >> b >> c >> d;\r\n\t\t\tnod.update(b,c,d);\r\n\t\t} else {\r\n\t\t\tcin >> b >> c;\r\n\t\t\tcout << nod.query(b,c) << endl;\r\n\t\t}\r\n\t}\r\n\r\n}"
    },
    {
        "username": "DPHB",
        "id": 16183,
        "date": "2020-12-12 16:14:37",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node {\r\n    long long s, e, m, val, lazy;\r\n    node *l = nullptr, *r = nullptr;\r\n\r\n    node(long long S, long long E) {\r\n        s = S, e = E, m = (s + e) / 2;\r\n        val = 0, lazy = 0;\r\n    }\r\n\r\n    void create() {\r\n        if (s != e) {\r\n            l = new node(s, m);\r\n            r = new node(m + 1, e);\r\n        }\r\n    }\r\n\r\n    void propogate() {\r\n        if (l == nullptr) {\r\n            create();\r\n        }\r\n        if (lazy == 0) {\r\n            return;\r\n        }\r\n        val += lazy * (e - s + 1);\r\n        if (s != e) {\r\n            l -> lazy += lazy;\r\n            r -> lazy += lazy;\r\n        }\r\n        lazy = 0;\r\n    }\r\n\r\n    void update(long long S, long long E, long long V) {\r\n        \r\n        if (s == S && e == E) {\r\n            lazy += V;\r\n        }\r\n        else {\r\n            propogate();\r\n            if (E <= m) {\r\n                l -> update(S, E, V);\r\n            }\r\n            else if (m < S) {\r\n                r -> update(S, E, V);\r\n            }\r\n            else {\r\n                l -> update(S, m, V);\r\n                r -> update(m + 1, E, V);\r\n            }\r\n            l -> propogate();\r\n            r -> propogate();\r\n            val = l -> val + r -> val;\r\n        }\r\n    }\r\n\r\n    long long query(long long S, long long E) {\r\n        propogate();\r\n        if (s == S && e == E) {\r\n            return val;\r\n        }\r\n        if (l == nullptr) {\r\n            create();\r\n        }\r\n        if (E <= m) {\r\n            return l -> query(S, E);\r\n        }\r\n        if (S >= m + 1) {\r\n            return r -> query(S, E);\r\n        }\r\n        return l -> query(S, m) + r -> query(m + 1, E);\r\n    }\r\n\r\n} *root;\r\n\r\nint main() {\r\n    long long N, Q, A, L, R, K;\r\n    vector<long long> ans;\r\n    cin >> N >> Q;\r\n    root = new node(1, N);\r\n    for (long long a = 0; a < Q; a++) {\r\n        cin >> A;\r\n        if (A == 1) {\r\n            cin >> L >> R >> K;\r\n            root -> update(L, R, K);\r\n        }\r\n        if (A == 2) {\r\n            cin >> L >> R;\r\n            ans.push_back(root -> query(L, R));\r\n        }\r\n    }\r\n    for (long long x : ans){\r\n        cout << x << \"\\n\";\r\n    }\r\n}\r\n"
    },
    {
        "username": "wehh",
        "id": 16181,
        "date": "2020-12-12 16:09:27",
        "code": "#include <bits/stdc++.h>\r\n#define int long long\r\nusing namespace std;\r\n\r\nstruct node{\r\n    int s,e,m,val=0,lazy=0;\r\n    node *l=nullptr,*r=nullptr;\r\n\r\n    node(int S,int E){\r\n        s=S; e=E; m=(s+e)>>1;\r\n    }\r\n\r\n    void makeChild(){\r\n        if(s==e) return;\r\n        l=new node(s,m); r=new node(m+1,e);\r\n    }\r\n\r\n    void propo(){\r\n        if(l==nullptr) makeChild();\r\n        if(lazy!=0){\r\n            val+=lazy*(e-s+1);\r\n            if(s!=e){\r\n                l->lazy+=lazy;\r\n                r->lazy+=lazy;\r\n            }\r\n            lazy=0;\r\n        }\r\n    }\r\n\r\n    void update(int i,int j,int V){\r\n        if(l==nullptr) makeChild();\r\n        if(s==i && e==j){\r\n            lazy+=V;\r\n            return;\r\n        }\r\n\r\n        if(j<=m) l->update(i,j,V);\r\n        else if(i>m) r->update(i,j,V);\r\n        else{\r\n            l->update(i,m,V);\r\n            r->update(m+1,j,V);\r\n        }\r\n        l->propo();r->propo();\r\n        val=l->val + r->val;\r\n    }\r\n\r\n\r\n    int query(int S,int E){\r\n        if(l==nullptr) makeChild();\r\n        propo();\r\n        if(s==S && e==E) return val;\r\n\r\n        if(E<=m) return l->query(S,E);\r\n        else if(S>m) return r->query(S,E);\r\n        return l->query(S,m)+r->query(m+1,E);\r\n    }\r\n\r\n} *uwu;\r\n\r\nmain(){\r\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\r\n\r\n    int n,q;\r\n    cin >> n >> q;\r\n    uwu = new node(1,n+10);\r\n    for(int i=0;q>i;i++){\r\n        int t;\r\n        cin >> t;\r\n        if(t==1){\r\n            int a,b,c;\r\n            cin >> a >> b >> c;\r\n            uwu->update(a,b,c);\r\n        }\r\n        else{\r\n            int b,c;\r\n            cin >> b >> c;\r\n            cout << uwu->query(b,c) << \"\\n\";\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "jamessng",
        "id": 16167,
        "date": "2020-12-12 15:59:55",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\n\r\nstruct node{\r\n    int s, e, m;\r\n    ll v, lz;\r\n    node *l, *r;\r\n\r\n    node(int _s, int _e){\r\n        s = _s; e = _e; m = (s + e) / 2;\r\n        v = 0; lz = 0;\r\n        l = nullptr; r = nullptr;\r\n    }\r\n\r\n    void propo(){\r\n        v += lz * (e - s + 1);\r\n        if (s != e){\r\n            if (l == nullptr) create();\r\n            l -> lz += lz;\r\n            r -> lz += lz;\r\n        }\r\n        lz = 0;\r\n    }\r\n\r\n    void create(){\r\n        //printf(\"create\");\r\n        if (s != e){\r\n            l = new node(s, m);\r\n            r = new node(m + 1, e);\r\n        }\r\n    }\r\n\r\n    void up(int x, int y, int k){\r\n        //printf(\"%d %d %d %d %d\\n\", s, e, x, y, k);\r\n        if (s == x && e == y){\r\n            lz += k; return;\r\n        }\r\n        if (l == nullptr || r == nullptr) create();\r\n        if (y <= m){\r\n            //printf(\"2\");\r\n            l -> up(x, y, k);\r\n            //printf(\"3\");\r\n        }\r\n        else if (x > m){\r\n            r -> up(x, y, k);\r\n        }\r\n        else{\r\n            l -> up(x, m, k);\r\n            r -> up(m + 1, y, k);\r\n        }\r\n        //printf(\"1\");\r\n        l -> propo(); r -> propo();\r\n        v = l -> v + r -> v;\r\n    }\r\n\r\n    ll query(int x, int y){\r\n        propo();\r\n        if (s == x && e == y) return v;\r\n        if (l == nullptr || r == nullptr) create();\r\n        if (y <= m) return l -> query(x, y);\r\n        if (x > m) return r -> query(x, y);\r\n        return l -> query(x, m) + r -> query(m + 1, y);\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n    int n, q; scanf(\"%d%d\", &n, &q);\r\n    root = new node(1, n);\r\n    for (int i = 0; i < q; ++i){\r\n        int t; scanf(\"%d\", &t);\r\n        if (t == 1){\r\n            int l, r, k; scanf(\"%d%d%d\", &l, &r, &k);\r\n            root -> up(l, r, k);\r\n        }\r\n        else{\r\n            int l, r; scanf(\"%d%d\", &l, &r);\r\n            printf(\"%lld\\n\", root -> query(l, r));\r\n        }\r\n    }\r\n}\r\n"
    },
    {
        "username": "joelau",
        "id": 16156,
        "date": "2020-12-12 15:53:35",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nint N,Q;\r\n\r\nstruct node{\r\n    int s,e,m; long long v = 0, lazy = 0; node *l = nullptr, *r = nullptr;\r\n    node(int S, int E) {\r\n        s = S, e = E, m = (s+e)/2;\r\n    }\r\n    void create() {\r\n        if (s != e) l = new node(s,m), r = new node(m+1,e);\r\n    }\r\n    void propo() {\r\n        if (l == nullptr) create();\r\n        if (lazy != 0) {\r\n            v += (e-s+1)*lazy;\r\n            if (s != e) l->lazy += lazy, r->lazy += lazy;\r\n            lazy = 0;\r\n        }\r\n    }\r\n    void update(int x, int y, int nv) {\r\n        if (l == nullptr) create();\r\n        if (s == x && e == y) lazy += nv;\r\n        else {\r\n            if (x > m) r -> update(x,y,nv);\r\n            else if (y <= m) l -> update(x,y,nv);\r\n            else l -> update(x,m,nv), r -> update(m+1,y,nv);\r\n            l -> propo(), r -> propo();\r\n            v = l->v + r->v;\r\n        }\r\n    }\r\n    long long query(int x, int y) {\r\n        if (l == nullptr) create();\r\n        propo();\r\n        if (s == x && e == y) return v;\r\n        else if (x > m) return r -> query(x,y);\r\n        else if (y <= m) return l -> query(x,y);\r\n        else return l -> query(x,m) + r -> query(m+1,y);\r\n    }\r\n}*root;\r\n\r\nint main() {\r\n    scanf(\"%d %d\", &N, &Q);\r\n    root = new node(0,N-1);\r\n    for (int i = 0; i < Q; ++i) {\r\n        int t,l,r; scanf(\"%d %d %d\", &t, &l, &r); l--, r--;\r\n        if (t == 1) {\r\n            int k; scanf(\"%d\", &k);\r\n            root -> update(l,r,k);\r\n        }\r\n        else printf(\"%lld\\n\", root -> query(l,r));\r\n    }\r\n\r\n    return 0;\r\n}\r\n"
    },
    {
        "username": "Deadeye",
        "id": 16135,
        "date": "2020-12-12 15:40:35",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n#define pb push_back\r\n#define fi first\r\n#define si second\r\ntypedef pair<int,int> pi;\r\n\r\n#ifdef LOCAL\r\n#define debug(...) __f(#__VA_ARGS__, __VA_ARGS__)\r\n#else\r\n#define debug(...) 69\r\n#endif\r\ntemplate <typename Arg>\r\nvoid __f(string name, Arg arg) {\r\n\tcerr << name << \" = \" << arg << endl;\r\n}\r\ntemplate <typename Head, typename... Tail>\r\nvoid __f(string names, Head head, Tail... tail) {\r\n\tstring cur = \"\";\r\n\tfor (auto ch: names){if(ch==','){break;}else{cur+=ch;}}\r\n\tstring nxt = names.substr(cur.size()+2);\r\n\tcerr << cur << \" = \" << head << \", \";\r\n\t__f(nxt, tail...);\r\n}\r\n\r\nint N, Q;\r\n\r\nstruct node {\r\n\tint s,e,m,v=0,lazy=0;\r\n\tnode *l = nullptr, *r = nullptr;\r\n\tnode (int _s, int _e) {\r\n\t\ts = _s, e = _e, m = (s + e) / 2;\r\n\t}\r\n\tvoid create() {\r\n\t\tif (l == nullptr) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m + 1, e);\r\n\t\t}\r\n\t}\r\n\tvoid prop() {\r\n\t\tif (lazy != 0) {\r\n\t\t\tcreate();\r\n\t\t\tv += lazy * (e - s + 1);\r\n\t\t\tif (s != e) {\r\n\t\t\t\tl->lazy\t+= lazy;\r\n\t\t\t\tr->lazy += lazy;\r\n\t\t\t}\r\n\t\t\tlazy = 0;\r\n\t\t}\r\n\t}\r\n\tvoid update(int qs, int qe, int nv) {\r\n\t\tprop();\r\n\t\tif (qs == s && qe == e) {\r\n\t\t\tlazy += nv;\r\n\t\t\treturn;\r\n\t\t} else {\r\n\t\t\tcreate();\r\n\t\t\tif (qs > m) r->update(qs, qe, nv);\r\n\t\t\telse if (qe <= m) l->update(qs, qe, nv);\r\n\t\t\telse l->update(qs, m, nv), r->update(m + 1, qe, nv);\r\n\t\t\tl->prop(), r->prop();\r\n\t\t\tv = l->v + r->v;\r\n\t\t}\r\n\t}\r\n\tint query(int qs, int qe) {\r\n\t\tprop();\r\n\t\tif (qs == s && qe == e) return v;\r\n\t\telse {\r\n\t\t\tcreate();\r\n\t\t\tif (qs > m) return r->query(qs, qe);\r\n\t\t\telse if (qe <= m) return l->query(qs, qe);\r\n\t\t\treturn l->query(qs, m) + r->query(m + 1, qe);\r\n\t\t}\r\n\t}\r\n} *st;\r\n\r\n\r\nint32_t main() {\r\n\tios_base::sync_with_stdio(0); cin.tie(0);\r\n\tcin >> N >> Q;\r\n\tst = new node(0, (int)1e9);\r\n\twhile (Q--) {\r\n\t\tint op;\r\n\t\tcin >> op;\r\n\t\tif (op == 1) {\r\n\t\t\tint l,r,k; cin >> l >> r >> k;\r\n\t\t\tst->update(l, r, k);\r\n\t\t} else {\r\n\t\t\tint l,r; cin >> l >> r;\r\n\t\t\tcout << st->query(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n"
    },
    {
        "username": "Halogen",
        "id": 16129,
        "date": "2020-12-12 15:36:46",
        "code": "#include <bits/stdc++.h>\r\n\r\nusing namespace std;\r\n\r\nstruct node {\r\n    long long s, e, m, v;\r\n    long long lazy;\r\n    node *l, *r;\r\n\r\n    node(long long _s, long long _e) {\r\n        s = _s;\r\n        e = _e;\r\n        v = lazy = 0;\r\n        if (s == e) return;\r\n\r\n        m = (s + e) / 2;\r\n    }\r\n\r\n    void create() {\r\n        if (s == e) return;\r\n        if (l != nullptr) return;\r\n        l = new node(s, m);\r\n        r = new node(m + 1, e);\r\n    }\r\n    \r\n    void propo() {\r\n        create();\r\n        if (lazy != 0) {\r\n            v += lazy * (e - s + 1);\r\n            if (s != e){\r\n                r -> lazy += lazy;\r\n                l -> lazy += lazy;\r\n            }\r\n            lazy = 0;\r\n        }\r\n    }\r\n\r\n    void up(long long x, long long y, long long c) {\r\n        create();\r\n        propo();\r\n\r\n        if (x == s && y == e) {\r\n            v += c * (e - s + 1);\r\n            if (s == e) return;\r\n            l -> lazy += c;\r\n            r -> lazy += c;\r\n        }\r\n        else {\r\n            if (y <= m) l -> up(x, y, c);\r\n            else if (x > m) r -> up(x, y, c);\r\n            else { l -> up(x, m, c); r -> up(m + 1, y, c); }\r\n            \r\n            l -> propo(); r -> propo();\r\n            v = l -> v + r -> v;\r\n        }\r\n\r\n    }\r\n\r\n    long long query(long long x, long long y) {\r\n        create();\r\n        propo();\r\n\r\n        if (s == x && e == y) return v;\r\n        if (x > m) return r -> query(x, y);\r\n        if (y <= m) return l -> query(x, y);\r\n        else return l -> query(x, m) + r -> query(m + 1, y);\r\n    }\r\n}*root;\r\n\r\nint main() {\r\n    long long N; scanf(\"%lld\", &N);\r\n    root = new node(0, 1000000005);\r\n    long long Q; scanf(\"%lld\", &Q);\r\n    \r\n    for (long long i = 0; i < Q; i++) {\r\n        long long cmd; scanf(\"%lld\", &cmd);\r\n        if (cmd == 1) {\r\n            long long a, b, c; \r\n            scanf(\"%lld %lld %lld\", &a, &b, &c); \r\n            root -> up(a, b, c);\r\n        }\r\n        if (cmd == 2) {\r\n            long long x, y; scanf(\"%lld %lld\", &x, &y);\r\n            printf(\"%lld\\n\", root -> query(x, y));\r\n        }\r\n    }\r\n}   "
    },
    {
        "username": "lida",
        "id": 16105,
        "date": "2020-12-12 15:21:07",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n#define int long long\r\n\r\nstruct node{\r\n    int s,e,m;\r\n    int val=0,lazy=0;\r\n    node *l=nullptr,*r=nullptr;\r\n\r\n    node (int _s,int _e){\r\n        s=_s,e=_e,m=s+e>>1;\r\n    }\r\n\r\n    void makeChild(){\r\n        if (l==nullptr){\r\n            l=new node(s,m);\r\n            r=new node(m+1,e);\r\n        }\r\n    }\r\n\r\n    void propo(){\r\n        if (lazy!=0){ ///need to propogate\r\n            val+=(e-s+1)*lazy;\r\n\r\n            if (s!=e){\r\n                makeChild();\r\n\r\n                l->lazy+=lazy;\r\n                r->lazy+=lazy;\r\n            }\r\n            lazy=0;\r\n        }\r\n    }\r\n\r\n    void update(int i,int j,int k){ ///updating [i,j] +=k\r\n        propo();\r\n\r\n        if (s==i && e==j) lazy+=k;\r\n        else{\r\n            makeChild();\r\n\r\n            if (j<=m) l->update(i,j,k);\r\n            else if (m<i) r->update(i,j,k);\r\n            else l->update(i,m,k),r->update(m+1,j,k);\r\n\r\n            l->propo(),r->propo();\r\n            val=l->val+r->val;\r\n        }\r\n    }\r\n\r\n    int query(int i,int j){\r\n        propo();\r\n\r\n        if (s==i && e==j) return val;\r\n        else{\r\n            makeChild();\r\n\r\n            if (j<=m) return l->query(i,j);\r\n            else if (m<i) return r->query(i,j);\r\n            else return l->query(i,m)+r->query(m+1,j);\r\n        }\r\n    }\r\n\r\n} *root=new node(-100,1e9+100);\r\n\r\nint n,q;\r\n\r\nmain(){\r\n    cin>>n>>q;\r\n\r\n    int t,a,b,c;\r\n    while (q--){\r\n        cin>>t;\r\n        if (t==1){\r\n            cin>>a>>b>>c;\r\n            root->update(a,b,c);\r\n        }\r\n        else{\r\n            cin>>a>>b;\r\n            cout<<root->query(a,b)<<endl;\r\n        }\r\n\r\n    }\r\n}\r\n"
    },
    {
        "username": "UnovaFrosmoth",
        "id": 16098,
        "date": "2020-12-12 15:14:32",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define ll long long\r\nconst int N=4e5+5;\r\nstruct seg{\r\n    int l=0,r=0;\r\n    ll sum=0,add=0;\r\n}tr[N*17];\r\nint n,q,idx=1;\r\ninline void pushdown(int u,int l,int r){\r\n    int mid=l+r>>1,x,y;\r\n    if(tr[u].l==0)tr[u].l=++idx;\r\n    if(tr[u].r==0)tr[u].r=++idx;\r\n    //printf(\"%d %d %d %d %d\\n\",u,l,r,tr[u].l,tr[u].r);\r\n    x=tr[u].l,y=tr[u].r;\r\n    tr[x].sum+=(ll)(mid-l+1)*tr[u].add;\r\n    tr[x].add+=tr[u].add;\r\n    tr[y].sum+=(ll)(r-mid)*tr[u].add;\r\n    tr[y].add+=tr[u].add;\r\n    tr[u].add=0;\r\n}\r\ninline void pushup(int u){tr[u].sum=tr[tr[u].l].sum+tr[tr[u].r].sum;}\r\ninline void update(int u,int l,int r,int x,int y,int k){\r\n    //printf(\"up%d %d %d\\n\",u,l,r);\r\n    if(l>=x&&r<=y){\r\n        tr[u].sum+=(ll)k*(r-l+1);\r\n        tr[u].add+=(ll)k;\r\n        return;\r\n    }\r\n    int mid=l+r>>1;\r\n    pushdown(u,l,r);\r\n    if(mid>=x)update(tr[u].l,l,mid,x,y,k);\r\n    if(mid<y)update(tr[u].r,mid+1,r,x,y,k);\r\n    pushup(u);\r\n    return;\r\n}\r\ninline ll query(int u,int l,int r,int x,int y){\r\n    if(l>=x&&r<=y)return tr[u].sum;\r\n    int mid=l+r>>1;\r\n    ll res=0;\r\n    pushdown(u,l,r);\r\n    if(mid>=x)res+=query(tr[u].l,l,mid,x,y);\r\n    if(mid<y)res+=query(tr[u].r,mid+1,r,x,y);\r\n    return res;\r\n}\r\nint main(){\r\n    scanf(\"%d%d\",&n,&q);\r\n    while(q--){\r\n        int op,l,r,k;\r\n        scanf(\"%d%d%d\",&op,&l,&r);\r\n        if(op==1){\r\n            scanf(\"%d\",&k);\r\n            update(1,1,n,l,r,k);\r\n        }\r\n        else {\r\n            printf(\"%lld\\n\",query(1,1,n,l,r));\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "xinghui",
        "id": 16093,
        "date": "2020-12-12 15:09:14",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntypedef long long ll;\r\nstruct node {\r\n    int s, e;\r\n    ll mn, mx, sum;\r\n    bool lset;\r\n    ll add_val, set_val;\r\n    node *l, *r;\r\n    node (int _s, int _e, int A[] = NULL): s(_s), e(_e), mn(0), mx(0), sum(0), lset(0), add_val(0), set_val(0), l(NULL), r(NULL) {\r\n        if (A == NULL) return;\r\n        if (s == e) mn = mx = sum = A[s];\r\n        else {\r\n            l = new node(s, (s+e)>>1, A), r = new node((s+e+2)>>1, e, A);\r\n            combine();\r\n        }\r\n    }\r\n    void create_children() {\r\n        if (s == e) return;\r\n        if (l != NULL) return;\r\n        int m = (s+e)>>1;\r\n        l = new node(s, m);\r\n        r = new node(m+1, e);\r\n    }\r\n    void self_set(ll v) {\r\n        lset = 1;\r\n        mn = mx = set_val = v;\r\n        sum = v * (e-s+1);\r\n        add_val = 0;\r\n    }\r\n    void self_add(ll v) {\r\n        if (lset) { self_set(v + set_val); return; }\r\n        mn += v, mx += v, add_val += v;\r\n        sum += v*(e-s+1);\r\n    }\r\n    void lazy_propagate() {\r\n        if (s == e) return;\r\n        if (lset) {\r\n            l->self_set(set_val), r->self_set(set_val);\r\n            lset = set_val = 0;\r\n        }   \r\n        if (add_val != 0) {\r\n            l->self_add(add_val), r->self_add(add_val);\r\n            add_val = 0;\r\n        }\r\n    }\r\n    void combine() {\r\n        if (l == NULL) return;\r\n        sum = l->sum + r->sum;\r\n        mn = min(l->mn, r->mn);\r\n        mx = max(l->mx, r->mx);\r\n    }\r\n    void add(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_add(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->add(x, min(y, m), v);\r\n        if (y > m) r->add(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    void set(int x, int y, ll v) {\r\n        if (s == x && e == y) { self_set(v); return; }\r\n        int m = (s+e)>>1;\r\n        create_children(); lazy_propagate();\r\n        if (x <= m) l->set(x, min(y, m), v);\r\n        if (y > m) r->set(max(x, m+1), y, v);\r\n        combine();\r\n    }\r\n    ll range_sum(int x, int y) {\r\n        if (s == x && e == y) return sum;\r\n        if (l == NULL || lset) return (sum / (e-s+1)) * (y-x+1);\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_sum(x, y);\r\n        if (x > m) return r->range_sum(x, y);\r\n        return l->range_sum(x, m) + r->range_sum(m+1, y);\r\n    }\r\n    ll range_min(int x, int y) {\r\n        if (s == x && e == y) return mn;\r\n        if (l == NULL || lset) return mn;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_min(x, y);\r\n        if (x > m) return r->range_min(x, y);\r\n        return min(l->range_min(x, m), r->range_min(m+1, y));\r\n    }\r\n    ll range_max(int x, int y) {\r\n        if (s == x && e == y) return mx;\r\n        if (l == NULL || lset) return mx;\r\n        int m = (s+e)>>1;\r\n        lazy_propagate();\r\n        if (y <= m) return l->range_max(x, y);\r\n        if (x > m) return r->range_max(x, y);\r\n        return max(l->range_max(x, m), r->range_max(m+1, y));\r\n    }\r\n    ~node() {\r\n        if (l != NULL) delete l;\r\n        if (r != NULL) delete r;\r\n    }\r\n} *root;\r\n\r\nint main(){\r\n\tint N, Q;\r\n\tscanf(\"%d%d\", &N, &Q);\r\n\troot=new node(0, 1000000000);\r\n\twhile (Q--){\r\n\t\tint x, y, z;\r\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\r\n\t\tif (x==1){\r\n\t\t\tint v;\r\n\t\t\tscanf(\"%d\", &v);\r\n\t\t\troot->add(y, z, v);\r\n\t\t}\r\n\t\telse printf(\"%lld\\n\", root->range_sum(y, z));\r\n\t}\r\n}"
    },
    {
        "username": "jamielim",
        "id": 16078,
        "date": "2020-12-12 14:58:30",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint n,q;\r\nint arr[400005];\r\n\r\nstruct node{\r\n\tint s,e,m;\r\n\tlong long v,lazy;\r\n\tnode *l,*r;\r\n\tnode(int S,int E){\r\n\t\ts=S;e=E;m=(s+e)/2;\r\n\t\tv=lazy=0;\r\n\t}\r\n\tvoid create(){\r\n\t\tif(l==NULL)l=new node(s,m);\r\n\t\tif(r==NULL)r=new node(m+1,e);\r\n\t}\r\n\tvoid laze(){\r\n\t\tif(s==e){v+=lazy;lazy=0;return;}\r\n\t\tcreate();\r\n\t\tl->lazy+=lazy;r->lazy+=lazy;\r\n\t\tv+=lazy*(long long)(e-s+1);lazy=0;return;\r\n\t}\r\n\tvoid upd(int x,int y,int k){\r\n\t\tif(s==x&&e==y){lazy+=k;laze();return;}\r\n\t\tcreate();\r\n\t\tif(y<=m)l->upd(x,y,k);\r\n\t\telse if(x>m)r->upd(x,y,k);\r\n\t\telse l->upd(x,m,k),r->upd(m+1,y,k);\r\n\t\tl->laze();r->laze();\r\n\t\tv=l->v+r->v;\r\n\t}\r\n\tlong long qry(int x,int y){\r\n\t\tlaze();\r\n\t\tif(s==x&&e==y)return v;\r\n\t\tif(y<=m)return l->qry(x,y);\r\n\t\tif(x>m)return r->qry(x,y);\r\n\t\treturn l->qry(x,m)+r->qry(m+1,y);\r\n\t}\r\n}*root=new node(0,1000000005);\r\n\r\nint main(){\r\n\tscanf(\"%d%d\",&n,&q);\r\n\tint op,l,r,k;\r\n\twhile(q--){\r\n\t\tscanf(\"%d%d%d\",&op,&l,&r);\r\n\t\tif(op==1){\r\n\t\t\tscanf(\"%d\",&k);\r\n\t\t\troot->upd(l,r,k);\r\n\t\t}else{\r\n\t\t\tprintf(\"%lld\\n\",root->qry(l,r));\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "Ziwyy",
        "id": 16075,
        "date": "2020-12-12 14:57:14",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\n\r\nstruct node {\r\n\tint s, e, m, v, lazyadd;\r\n\tnode *l, *r;\r\n\tnode(int _s, int _e) {\r\n\t\ts = _s; e = _e; m = (s+e)/2; // initialize variables\r\n\t\tv = 0; lazyadd = 0;\r\n\t\t\r\n\t\tl = nullptr;\r\n\t\tr = nullptr;\r\n\t}\r\n\tint rmq(int x, int y) {\r\n\t\tvalue();\r\n\t\tif (s==x && e==y) return v;\r\n\t\t\r\n\t\tif (l==nullptr) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t\t\r\n\t\tif (x>m) return r->rmq(x, y);\r\n\t\tif (y<=m) return l->rmq(x, y);\r\n\t\treturn l->rmq(x, m) + r->rmq(m+1, y);\r\n\t}\r\n\tint value() { //propagate lazyadd to children, return value\r\n\t\tif (s==e) { v+=lazyadd; lazyadd=0; return v; }\r\n\t\tv += (e-s+1) * lazyadd;\r\n\t\tif (l==nullptr) {\r\n\t\t\tl = new node(s, m);\r\n\t\t\tr = new node(m+1, e);\r\n\t\t}\r\n\t\tr->lazyadd += lazyadd; l->lazyadd += lazyadd;\r\n\t\tlazyadd = 0;\r\n\t\treturn v;\r\n\t}\r\n\tvoid add(int x, int y, int val) {\r\n\t\tif (s == x && e == y) lazyadd += val; \r\n\t\telse {\r\n\t\t\tif (l==nullptr) {\r\n\t\t\t\tl = new node(s, m);\r\n\t\t\t\tr = new node(m+1, e);\r\n\t\t\t}\r\n\t\t\tif (x > m) r->add(x, y, val);\r\n\t\t\telse if (y <= m) l->add(x, y, val);\r\n\t\t\telse l->add(x, m, val), r->add(m+1, y, val);\r\n\t\t\tv = l->value() + r->value(); \r\n\t\t}\r\n\t}\r\n} *root;\r\n\r\nint N, Q;\r\n\r\nint32_t main() {\r\n\tios_base::sync_with_stdio(false);\r\n\tcin.tie(0);\r\n\tcin >> N >> Q;\r\n\troot = new node(1, N);\r\n\twhile (Q--) {\r\n\t\tint qt;\r\n\t\tcin >> qt;\r\n\t\tif (qt == 1) {\r\n\t\t\tint l, r, k;\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\troot->add(l, r, k);\r\n\t\t} else {\r\n\t\t\tint l, r;\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->rmq(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "pavement",
        "id": 16057,
        "date": "2020-12-12 14:35:36",
        "code": "#include <bits/stdc++.h>\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace std;\r\nusing namespace __gnu_pbds;\r\n#define int long long\r\n#ifdef WIN_32\r\n#define getchar_unlocked _getchar_nolock\r\n#endif\r\n#define mp make_pair\r\n#define mt make_tuple\r\n#define pb push_back\r\n#define pf push_front\r\n#define ppb pop_back\r\n#define ppf pop_front\r\n#define eb emplace_back\r\n#define g0(a) get<0>(a)\r\n#define g1(a) get<1>(a)\r\n#define g2(a) get<2>(a)\r\n#define g3(a) get<3>(a)\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\r\ntypedef double db;\r\ntypedef long long ll;\r\ntypedef long double ld;\r\ntypedef long double ld;\r\ntypedef pair<int, int> ii;\r\ntypedef tuple<int, int, int> iii;\r\ntypedef tuple<int, int, int, int> iiii;\r\ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\r\n\r\nint N, Q;\r\n\r\nstruct node {\r\n\tnode *left = nullptr, *right = nullptr;\r\n\tint S, E, val, pv;\r\n\tnode(int _s, int _e) : S(_s), E(_e), val(0), pv(0) {}\r\n\tvoid cc() {\r\n\t\tif (left != nullptr) return;\r\n\t\tint M = (S + E) >> 1;\r\n\t\tleft = new node(S, M);\r\n\t\tright = new node(M + 1, E);\r\n\t}\r\n\tvoid prop() {\r\n\t\tif (S == E || !pv) return;\r\n\t\tcc();\r\n\t\tleft->val += (left->E - left->S + 1) * pv;\r\n\t\tleft->pv += pv;\r\n\t\tright->val += (right->E - right->S + 1) * pv;\r\n\t\tright->pv += pv;\r\n\t\tpv = 0;\r\n\t}\r\n\tint qry(int l, int r) {\r\n\t\tif (l > E || r < S) return 0;\r\n\t\tif (l <= S && E <= r) return val;\r\n\t\tcc();\r\n\t\tprop();\r\n\t\treturn left->qry(l, r) + right->qry(l, r);\r\n\t}\r\n\tvoid upd(int l, int r, int v) {\r\n\t\tif (l > E || r < S) return;\r\n\t\tif (l <= S && E <= r) {\r\n\t\t\tpv += v;\r\n\t\t\tval += (E - S + 1) * v;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcc();\r\n\t\tprop();\r\n\t\tleft->upd(l, r, v);\r\n\t\tright->upd(l, r, v);\r\n\t\tval = left->val + right->val;\r\n\t}\r\n} *root;\r\n\r\nmain() {\r\n\tios::sync_with_stdio(0);\r\n\tcin.tie(0);\r\n\tcin >> N >> Q;\r\n\troot = new node(1, N);\r\n\tfor (int t, l, r, k; Q--; ) {\r\n\t\tcin >> t;\r\n\t\tif (t == 1) {\r\n\t\t\tcin >> l >> r >> k;\r\n\t\t\troot->upd(l, r, k);\r\n\t\t} else {\r\n\t\t\tcin >> l >> r;\r\n\t\t\tcout << root->qry(l, r) << '\\n';\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
        "username": "username",
        "id": 16044,
        "date": "2020-12-12 14:19:24",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define pb push_back\r\n#define mp make_pair\r\nint n,q;\r\nstruct node{\r\n    node *l,*r;\r\n    int s,m,e;\r\n    long long val,lazyadd;\r\n    node(int ss,int ee){\r\n        s=ss;\r\n        e=ee;\r\n        m=(s+e)/2;\r\n        val=lazyadd=0;\r\n        l=r=NULL;\r\n    }\r\n    long long value(){\r\n        if (s==e) return val+lazyadd;\r\n        if (l==NULL) l=new node(s,m);\r\n        if (r==NULL) r=new node(m+1,e);\r\n        val+=lazyadd*(e-s+1);\r\n        l->lazyadd+=lazyadd;\r\n        r->lazyadd+=lazyadd;\r\n        lazyadd=0;\r\n        return val;\r\n    }\r\n    void upd(int x,int y,long long v){\r\n        value();\r\n        if (s==x && e==y){\r\n            lazyadd+=v;\r\n            return;\r\n        }\r\n        if (x>m) r->upd(x,y,v);\r\n        else if (y<=m) l->upd(x,y,v);\r\n        else l->upd(x,m,v),r->upd(m+1,y,v);\r\n        val=l->value()+r->value();\r\n    }\r\n    long long qry(int x,int y){\r\n        value();\r\n        if (s==x && e==y) return value();\r\n        if (x>m) return r->qry(x,y);\r\n        if (y<=m) return l->qry(x,y);\r\n        return l->qry(x,m)+r->qry(m+1,y);\r\n    }\r\n}*root;\r\nint main(){\r\n    ios_base::sync_with_stdio(false);\r\n    cin.tie(NULL);\r\n    cin>>n>>q;\r\n    root=new node(1,n);\r\n    while (q--){\r\n        int tc,l,r,k;\r\n        cin>>tc>>l>>r;\r\n        if (tc==1){\r\n            cin>>k;\r\n            root->upd(l,r,k);\r\n        }\r\n        else {\r\n            cout<<(root->qry(l,r))<<'\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "syy",
        "id": 15544,
        "date": "2020-12-12 09:57:57",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef long double ld;\r\n#define FOR(i, a, b) for(ll i = (ll)a; i <= (ll)b; i++)\r\n#define DEC(i, a, b) for(ll i = (ll)a; i >= (ll)b; i--)\r\ntypedef pair<ll, ll> pi;\r\ntypedef pair<pi, ll> pii;\r\ntypedef pair<ll, pi> ipi;\r\ntypedef pair<pi, pi> pipi;\r\n#define f first\r\n#define s second\r\ntypedef vector<ll> vi;\r\ntypedef vector<pi> vpi;\r\ntypedef vector<pii> vpii;\r\n#define pb push_back\r\n#define pf push_front\r\n#define all(v) v.begin(), v.end()\r\n#define size(v) (ll) v.size()\r\n#define disc(v) sort(all(v)); v.resize(unique(all(v)) - v.begin());\r\n#define INF (ll) 1e9 + 100\r\n#define LLINF (ll) 1e18\r\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\r\n#define sandybridge __attribute__((optimize(\"Ofast\"), target(\"arch=sandybridge\")))\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\r\ninline ll rand(ll x, ll y) { ++y; return (rng() % (y-x)) + x; } //inclusivesss\r\n\r\nll n, q, t, a, b, c;\r\n\r\nstruct node {\r\n\tll s, e, m, v, add;\r\n\tnode *l, *r;\r\n\tnode(ll S, ll E) {\r\n\t\ts = S, e = E, m = (s+e)/2, v = 0, add = 0, l = 0, r = 0;\r\n\t}\r\n\tll value() {\r\n\t\tv += add * (e-s+1);\r\n\t\tif (s != e) {\r\n\t\t\tif (!l) l = new node(s, m);\r\n\t\t\tif (!r) r = new node(m+1, e);\r\n\t\t\tl->add += add;\r\n\t\t\tr->add += add;\r\n\t\t}\r\n\t\tadd = 0;\r\n\t\treturn v;\r\n\t}\r\n\tvoid up(ll x, ll y, ll nv) {\r\n\t\tvalue();\r\n\t\tif (s == x and e == y) {add += nv; return;}\r\n\t\telse if (y <= m) {\r\n\t\t\tif (!l) l = new node(s, m);\r\n\t\t\tl->up(x, y, nv);\r\n\t\t} else if (x > m) {\r\n\t\t\tif (!r) r = new node(m+1, e);\r\n\t\t\tr->up(x, y, nv);\r\n\t\t} else {\r\n\t\t\tif (!l) l = new node(s, m);\r\n\t\t\tif (!r) r = new node(m+1, e);\r\n\t\t\tl->up(x, m, nv), r->up(m+1, y, nv);\r\n\t\t}\r\n\t\tv = (l ? l->value() : 0) + (r ? r->value() : 0);\r\n\t}\r\n\tll query(ll x, ll y) {\r\n\t\tvalue();\r\n\t\tif (s == x and e == y) return v;\r\n\t\telse if (y <= m) return (l ? l->query(x, y) : 0);\r\n\t\telse if (x > m) return (r ? r->query(x, y) : 0);\r\n\t\telse return (l ? l->query(x, m) : 0) + (r ? r->query(m+1, y) : 0);\r\n\t}\r\n} *seg;\r\n\r\nint main() {\r\n\tfastio; cin >> n >> q;\r\n\tseg = new node(1, n);\r\n\twhile (q--) {\r\n\t\tcin >> t >> a >> b;\r\n\t\tif (t == 1) {\r\n\t\t\tcin >> c;\r\n\t\t\tseg->up(a, b, c);\r\n\t\t} else cout << seg->query(a, b) << \"\\n\";\r\n\t}\r\n}\r\n"
    },
    {
        "username": "syy",
        "id": 15543,
        "date": "2020-12-12 09:57:24",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\ntypedef long double ld;\r\n#define FOR(i, a, b) for(ll i = (ll)a; i <= (ll)b; i++)\r\n#define DEC(i, a, b) for(ll i = (ll)a; i >= (ll)b; i--)\r\ntypedef pair<ll, ll> pi;\r\ntypedef pair<pi, ll> pii;\r\ntypedef pair<ll, pi> ipi;\r\ntypedef pair<pi, pi> pipi;\r\n#define f first\r\n#define s second\r\ntypedef vector<ll> vi;\r\ntypedef vector<pi> vpi;\r\ntypedef vector<pii> vpii;\r\n#define pb push_back\r\n#define pf push_front\r\n#define all(v) v.begin(), v.end()\r\n#define size(v) (ll) v.size()\r\n#define disc(v) sort(all(v)); v.resize(unique(all(v)) - v.begin());\r\n#define INF (ll) 1e9 + 100\r\n#define LLINF (ll) 1e18\r\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\r\n#define sandybridge __attribute__((optimize(\"Ofast\"), target(\"arch=sandybridge\")))\r\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\r\ninline ll rand(ll x, ll y) { ++y; return (rng() % (y-x)) + x; } //inclusivesss\r\n\r\nll n, q, t, a, b, c;\r\n\r\nstruct node {\r\n\tll s, e, m, v, add;\r\n\tnode *l, *r;\r\n\tnode(ll S, ll E) {\r\n\t\ts = S, e = E, m = (s+e)/2, v = 0, add = 0, l = 0, r = 0;\r\n\t}\r\n\tll value() {\r\n\t\tv += add * (e-s+1);\r\n\t\tif (s != e) {\r\n\t\t\tif (!l) l = new node(s, m);\r\n\t\t\tif (!r) r = new node(m+1, e);\r\n\t\t\tl->add += add;\r\n\t\t\tr->add += add;\r\n\t\t}\r\n\t\tadd = 0;\r\n\t\treturn v;\r\n\t}\r\n\tvoid up(ll x, ll y, ll nv) {\r\n\t\tvalue();\r\n\t\tif (s == x and e == y) {add += nv; return;}\r\n\t\telse if (y <= m) {\r\n\t\t\tif (!l) l = new node(s, m);\r\n\t\t\tl->up(x, y, nv);\r\n\t\t} else if (x > m) {\r\n\t\t\tif (!r) r = new node(m+1, e);\r\n\t\t\tr->up(x, y, nv);\r\n\t\t} else {\r\n\t\t\tif (!l) l = new node(s, m);\r\n\t\t\tif (!r) r = new node(m+1, e);\r\n\t\t\tl->up(x, m, nv), r->up(m+1, y, nv);\r\n\t\t}\r\n\t\tv = (l ? l->value() : 0) + (r ? r->value() : 0);\r\n\t}\r\n\tll query(ll x, ll y) {\r\n\t\tvalue();\r\n\t\tif (s == x and e == y) return v;\r\n\t\telse if (y <= m) return (l ? l->query(x, y) : 0);\r\n\t\telse if (x > m) return (r ? r->query(x, y) : 0);\r\n\t\telse return (l ? l->query(x, m) : 0) + (r ? r->query(m+1, y) : 0);\r\n\t}\r\n\tvoid prll() {\r\n\t\tvalue();\r\n\t\tcout << s << \" \" << e << \" \" << v << '\\n';\r\n\t\tif (l) l->prll();\r\n\t\tif (r) r->prll();\r\n\t}\r\n} *seg;\r\n\r\nint main() {\r\n\tfastio; cin >> n >> q;\r\n\tseg = new node(1, n);\r\n\twhile (q--) {\r\n\t\tcin >> t >> a >> b;\r\n\t\tif (t == 1) {\r\n\t\t\tcin >> c;\r\n\t\t\tseg->up(a, b, c);\r\n\t\t} else cout << seg->query(a, b) << \"\\n\";\r\n\t\t//~ seg->prll();\r\n\t}\r\n}\r\n"
    },
    {
        "username": "zaneyu",
        "id": 15537,
        "date": "2020-12-12 09:49:25",
        "code": "/*input\r\n5 5\r\n1 2 3 1\r\n2 3 5\r\n1 1 3 4\r\n2 1 1\r\n2 1 5\r\n*/\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n#include <ext/pb_ds/assoc_container.hpp>\r\n#include <ext/pb_ds/tree_policy.hpp>\r\nusing namespace __gnu_pbds;\r\ntypedef tree<long long, null_type, less_equal<long long>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\r\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\r\n//order_of_key #of elements less than x\r\n// find_by_order kth element\r\nusing ll = long long;\r\nusing ld = long double;\r\nusing pii = pair<ll,ll>;\r\n#define f first\r\n#define s second\r\n#define pb push_back\r\n#define REP(i,n) for(int i=0;i<n;i++)\r\n#define REP1(i,n) for(int i=1;i<=n;i++)\r\n#define FILL(n,x) memset(n,x,sizeof(n))\r\n#define ALL(_a) _a.begin(),_a.end()\r\n#define sz(x) (int)x.size()\r\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\r\nconst ll INF64=4e18;\r\nconst ll INF=0x3f3f3f3f;\r\nconst ll MOD=1e9+7;\r\nconst ld PI=acos(-1);\r\nconst ld eps=1e-6;\r\n#define lowb(x) x&(-x)\r\n#define MNTO(x,y) x=min(x,(__typeof__(x))y)\r\n#define MXTO(x,y) x=max(x,(__typeof__(x))y)\r\nll sub(ll a,ll b){\r\n    ll x=a-b;\r\n    while(x<0) x+=MOD;\r\n    while(x>MOD) x-=MOD;\r\n    return x;\r\n}\r\nll mult(ll a,ll b){\r\n    return (a*b)%MOD;\r\n}\r\nll mypow(ll a,ll b){\r\n    if(b<=0) return 1;\r\n    ll res=1LL;\r\n    while(b){\r\n        if(b&1) res=(res*a)%MOD;\r\n        a=(a*a)%MOD;\r\n        b>>=1;\r\n    }\r\n    return res;\r\n}\r\nconst ll maxn=4e5+5;\r\nconst ll maxlg=__lg(maxn)+2; \r\n#define int ll\r\nstruct node{\r\n    ll sum=0,lazy=0;\r\n    int lc=0,rc=0;\r\n}seg[80*maxn];\r\n//check this line\r\nint tot=2;\r\ninline void pushdown(int idx,int l,int r){\r\n    if(!seg[idx].lazy) return;\r\n    seg[idx].sum+=((r-l+1)*seg[idx].lazy);\r\n    if(l!=r){\r\n        if(!seg[idx].lc) seg[idx].lc=(tot++);\r\n        if(!seg[idx].rc) seg[idx].rc=(tot++);\r\n        seg[seg[idx].lc].lazy+=seg[idx].lazy;\r\n        seg[seg[idx].rc].lazy+=seg[idx].lazy;\r\n    }\r\n    seg[idx].lazy=0;\r\n}\r\ninline void mdf(int &idx,int l,int r,int ql,int qr,int x){\r\n    if(!idx){\r\n        idx=(tot++);\r\n    }\r\n    pushdown(idx,l,r);\r\n    if(r<ql or l>qr) return;\r\n    if(ql<=l and r<=qr){\r\n        seg[idx].lazy+=x;\r\n        pushdown(idx,l,r);\r\n        return;\r\n    }\r\n    int mid=(l+r)/2;\r\n    mdf(seg[idx].lc,l,mid,ql,qr,x);\r\n    mdf(seg[idx].rc,mid+1,r,ql,qr,x);\r\n    seg[idx].sum=(seg[seg[idx].lc].sum+seg[seg[idx].rc].sum);\r\n}\r\ninline ll query(int &idx,int l,int r,int ql,int qr){\r\n    if(r<ql or l>qr) return 0;\r\n    if(!idx){\r\n        idx=(tot++);\r\n    }\r\n    pushdown(idx,l,r);\r\n    if(ql<=l and r<=qr){\r\n        return seg[idx].sum;\r\n    }\r\n    int mid=(l+r)/2;\r\n    return (query(seg[idx].lc,l,mid,ql,qr)+query(seg[idx].rc,mid+1,r,ql,qr));\r\n}\r\nint rt=1;\r\nint32_t main(){\r\n    ios::sync_with_stdio(false),cin.tie(0);\r\n    int n,q;\r\n    cin>>n>>q;\r\n    while(q--){\r\n        int a,b,c;\r\n        cin>>a>>b>>c;\r\n        --b;\r\n        --c;\r\n        if(a==1){\r\n            int x;\r\n            cin>>x;\r\n            mdf(rt,0,n-1,b,c,x);\r\n        }\r\n        else{\r\n            cout<<query(rt,0,n-1,b,c)<<'\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "ryangohca",
        "id": 15527,
        "date": "2020-12-12 09:26:38",
        "code": "#include <bits/stdc++.h>\r\nusing namespace std;\r\n#define int long long\r\nstruct node {\r\n    node *l, *r;\r\n    int val, lazy;\r\n    node(): val(0), l(NULL), r(NULL), lazy(0){}\r\n    int value(int s, int e){\r\n        val += (e-s+1) * lazy;\r\n        if (s==e){\r\n            lazy = 0;\r\n            return val;\r\n        }\r\n        if (l == NULL) l = new node();\r\n        l->lazy += lazy;\r\n        if (r == NULL) r = new node();\r\n        r->lazy += lazy;\r\n        lazy = 0;\r\n        return val;\r\n    }\r\n    void update(int s, int e, int x, int y, int v) {\r\n        int m = (s + e) / 2;\r\n        if (s==x && e==y){\r\n           lazy += v;\r\n           return;\r\n        }\r\n        if (y <= m){\r\n            if (l == NULL) l = new node();\r\n            l->update(s, m, x, y, v);\r\n        } else if (x > m){\r\n            if (r == NULL) r = new node();\r\n            r->update(m+1, e, x, y, v);\r\n        } else {\r\n            if (l==NULL) l = new node();\r\n            if (r==NULL) r = new node();\r\n            l->update(s, m, x, m, v);\r\n            r->update(m+1, e, m+1, y, v);\r\n        }\r\n        val = (l==NULL?0:l->value(s, m)) + (r==NULL?0:r->value(m+1, e));\r\n    }\r\n    int query(int s, int e, int x, int y) {\r\n        value(s, e);\r\n        if (s == x && e == y) return val;\r\n        int m = (s + e) / 2;\r\n        if (x > m) return (r==NULL)? 0:r->query(m + 1, e, x, y);\r\n        if (y <= m) return (l==NULL)? 0:l->query(s, m, x, y);\r\n        if (l == NULL && r != NULL) return r->query(m+1, e, m+1, y);\r\n        if (l != NULL && r == NULL) return l->query(s, m, x, m);\r\n        if (l != NULL && r != NULL) return l->query(s, m, x, m) + r->query(m+1, e, m+1, y); //Change here for max\r\n        return 0;\r\n    }\r\n} *root;\r\nmain(){\r\n    int n, q; cin >> n >> q;\r\n    root = new node();\r\n    while (q--){\r\n        int t; cin >> t;\r\n        if (t == 1){\r\n            int a, b, c; cin >> a >> b >> c;\r\n            root->update(1, n, a, b, c);\r\n        } else {\r\n            int a, b; cin >> a >> b;\r\n            cout << root->query(1, n, a, b) << '\\n';\r\n        }\r\n    }\r\n}"
    },
    {
        "username": "errorgorn",
        "id": 15515,
        "date": "2020-12-12 06:16:44",
        "code": "\r\n"
    }
]
```


</details>

Please note that the codes that are written by me (errorgorn) are broken. I don't know why. I think it is because there are Chinese characters in my code (I used to put  in my code header as a joke).

Let's do some analysis on this data.

There are 430 total AC submissions. 109 of them contain the substring "propo" and 145 of them contain the substring "propa".

Note that people might have submitted multiple AC codes. Especially, so when testing codes of other people. So it is a good to only use statistics when filtering by the **first** AC of each user.

When ignoring counts of repeated ACs, 211 distinct users with ACs in total and have 58 and 72 users using "propo" and "propa" respectively. Wow, there is actually a substantial number of people spelling propagte wrongly....

If we filter this by the year of the submission, we can actually observe the number of people using propo decreasing. So I guess someone finally fixed the spelling along the way.

| Year                                             | 2020 | 2021 | 2022 | 2023 | 2024 |
| ------------------------------------------------ | ---- | ---- | ---- | ---- | ---- |
| propo                                            | 24   | 15   | 12   | 4    | 3    |
| propa                                            | 8    | 7    | 22   | 22   | 13   |
| $\frac{\text{propo}}{\text{propo}+\text{propa}}$ | 0.75 | 0.68 | 0.35 | 0.15 | 0.19 |

Strangely, there are 4 submissions with the substring "propo" and "propa" inside their code. They have IDs 563732, 343819, 343816, 187268. It turns out they directly copied the lazy propagation code from that lecture notes, but they changed the function name `propogate` to `propagate`, but not instances of `propagate` in the comments. Perhaps the spelling was fixed in lectures of later years?

I suppose it would be a good idea to do some sort of comparison with this code to see who copied it to get AC. To do this, we will define the similarity of a code $A$ to our "model code" $B$ as $\frac{\text{LCS}(A,B)}{\text{len}(B)}$ where $\text{LCS}$ is the longest common subsequence. We will strip all whitespace.

We can try setting $B$ as the segment tree code with comments: 

`structnode{ints,e,m;//rangeis[s,e],misthemiddlepointintval;//sumof[s,e]intlazy;//lazytagof[s,e]node*l,*r;//createtwochildrenlandr,wherelis[s,m]and[m+1,e]node(intS,intE){//constructorcallednodes=S,e=E,m=(s+e)/2;val=0;//initiallyallvaluesare0lazy=0;//lazytagof0willmeanthereisnoupdate(sentinelvalue)if(s!=e){//nodeisnotyetaleaf,socreatetwochildrenl=newnode(s,m);//createleftchildr=newnode(m+1,e);//createrightchild}}voidpropagate(){if(lazy==0)return;//nothinghappensval+=lazy*(e-s+1);//(e-s+1)isthelengthoftherangeif(s!=e){//notaleaf,sendlazytagstochildrenl->lazy+=lazy;r->lazy+=lazy;}lazy=0;//setourlazytagvaluebacktothesentinel}voidupdate(intS,intE,intV){//increment[S,E]byVif(s==S&&e==E)lazy+=V;//updatecoversrange,updatelazytagelse{//gowehavetogodeeperif(E<=m)l->update(S,E,V);//[S,E]isintheleftchildelseif(m<S)r->update(S,E,V);//[S,E]isintherightchildelsel->update(S,m,V),r->update(m+1,E,V);l->propagate(),r->propagate();//remembertopropagateyourchildrenbeforeupdateyourselfval=l->val+r->val;//updatetherangesum}}intquery(intS,intE){propagate();//remembertopropagateif(s==S&&e==E)returnval;//case1elseif(E<=m)returnl->query(S,E);//case2,recursetoleftchildelseif(S>=m+1)returnr->query(S,E);//case3,recursetorightchildelsereturnl->query(S,m)+r->query(m+1,E);//case4,splitthequeryrange,recursetobothchilds}}*root;`

Or without comments:

`structnode{ints,e,m;intval;intlazy;node*l,*r;node(intS,intE){s=S,e=E,m=(s+e)/2;val=0;lazy=0;if(s!=e){l=newnode(s,m);r=newnode(m+1,e);//createrightchild}}voidpropagate(){if(lazy==0)return;val+=lazy*(e-s+1);if(s!=e){l->lazy+=lazy;r->lazy+=lazy;}lazy=0;}voidupdate(intS,intE,intV){if(s==S&&e==E)lazy+=V;else{//gowehavetogodeeperif(E<=m)l->update(S,E,V);elseif(m<S)r->update(S,E,V);elsel->update(S,m,V),r->update(m+1,E,V);l->propagate(),r->propagate();val=l->val+r->val;}}intquery(intS,intE){propagate();if(s==S&&e==E)returnval;elseif(E<=m)returnl->query(S,E);elseif(S>=m+1)returnr->query(S,E);elsereturnl->query(S,m)+r->query(m+1,E);range,recursetobothchilds}}*root;`

We will graph out the similarity to the code with and without comments. The points are colored:

- Green if they contain "propo" and "propa"
- Red if they contain "propo"
- Blue if they contain "propa"
- Black otherwise

We obtain this plot:

<center>
  <img src="/media/scatter_plot.png" width="100%">
</center>

Also this is a gif when we add these points by time.

<center>
  <img src="/media/scatter_plot_animation.gif" width="100%">
</center>

Notice that most of the red dots occur before 2022 and they do not even substantially match the code given in the lecture notes. I think this highly suggests that I actually made people type out `propo`...

This is the script I used for my analysis. Shoutout to ChatGPT.

```python
B0="structnode{ints,e,m;//rangeis[s,e],misthemiddlepointintval;//sumof[s,e]intlazy;//lazytagof[s,e]node*l,*r;//createtwochildrenlandr,wherelis[s,m]and[m+1,e]node(intS,intE){//constructorcallednodes=S,e=E,m=(s+e)/2;val=0;//initiallyallvaluesare0lazy=0;//lazytagof0willmeanthereisnoupdate(sentinelvalue)if(s!=e){//nodeisnotyetaleaf,socreatetwochildrenl=newnode(s,m);//createleftchildr=newnode(m+1,e);//createrightchild}}voidpropagate(){if(lazy==0)return;//nothinghappensval+=lazy*(e-s+1);//(e-s+1)isthelengthoftherangeif(s!=e){//notaleaf,sendlazytagstochildrenl->lazy+=lazy;r->lazy+=lazy;}lazy=0;//setourlazytagvaluebacktothesentinel}voidupdate(intS,intE,intV){//increment[S,E]byVif(s==S&&e==E)lazy+=V;//updatecoversrange,updatelazytagelse{//gowehavetogodeeperif(E<=m)l->update(S,E,V);//[S,E]isintheleftchildelseif(m<S)r->update(S,E,V);//[S,E]isintherightchildelsel->update(S,m,V),r->update(m+1,E,V);l->propagate(),r->propagate();//remembertopropagateyourchildrenbeforeupdateyourselfval=l->val+r->val;//updatetherangesum}}intquery(intS,intE){propagate();//remembertopropagateif(s==S&&e==E)returnval;//case1elseif(E<=m)returnl->query(S,E);//case2,recursetoleftchildelseif(S>=m+1)returnr->query(S,E);//case3,recursetorightchildelsereturnl->query(S,m)+r->query(m+1,E);//case4,splitthequeryrange,recursetobothchilds}}*root;"

B1="structnode{ints,e,m;intval;intlazy;node*l,*r;node(intS,intE){s=S,e=E,m=(s+e)/2;val=0;lazy=0;if(s!=e){l=newnode(s,m);r=newnode(m+1,e);//createrightchild}}voidpropagate(){if(lazy==0)return;val+=lazy*(e-s+1);if(s!=e){l->lazy+=lazy;r->lazy+=lazy;}lazy=0;}voidupdate(intS,intE,intV){if(s==S&&e==E)lazy+=V;else{//gowehavetogodeeperif(E<=m)l->update(S,E,V);elseif(m<S)r->update(S,E,V);elsel->update(S,m,V),r->update(m+1,E,V);l->propagate(),r->propagate();val=l->val+r->val;}}intquery(intS,intE){propagate();if(s==S&&e==E)returnval;elseif(E<=m)returnl->query(S,E);elseif(S>=m+1)returnr->query(S,E);elsereturnl->query(S,m)+r->query(m+1,E);range,recursetobothchilds}}*root;"

import json
import pylcs

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation

with open('data.json', 'r') as f:
	data = json.load(f)

data=data[::-1] #dates are reverse order in the json file

tot=0
num=[[0]*5,[0]*5]

X=[]
Y=[]
C=[]
D=[]

names=set()

for dat in data:
	if (dat["username"] in names):
		continue
		
	names.add(dat["username"])	#uncomment this line if you do not want distinct names
	
	tot+=1
	
	A=dat["code"]
	
	X.append(pylcs.lcs_sequence_length(A, B0)/len(B0))
	Y.append(pylcs.lcs_sequence_length(A, B1)/len(B1))
	
	propo = "propo" in A
	propa = "propa" in A
	
	if (propo and propa):
		print(dat["username"],dat["id"])
	
	year=ord(dat["date"][3])-ord('0')
	if (propo):
		num[0][year]+=1
	if (propa):
		num[1][year]+=1
	
	if (propo and propa):
		C.append("green")
	elif (propo):
		C.append("red")
	elif (propa):
		C.append("blue")
	else:
		C.append("black")
		
	D.append(dat["date"])
	

print(tot)
print(num)
print([num[0][i]/(num[0][i]+num[1][i]) for i in range(5)])
print(list(map(sum,num)))

fig, ax = plt.subplots(figsize=(15,10))

ax.set_xlim(0,1)
ax.set_ylim(0,1)
ax.set_xlabel('With Comments')
ax.set_ylabel('Without Comments')

line_y = [0,1]
line_x = [0, len(B1)/len(B0)]
plt.plot(line_x, line_y, color='red', linestyle='-')


scat = ax.scatter([], [], s=100)
title = ax.set_title('Scatter Plot Animation')

def update(frame):
    current_x = X[:frame + 1]
    current_y = Y[:frame + 1]
    current_colors = C[:frame + 1]
    scat.set_offsets(np.column_stack((current_x, current_y)))
    scat.set_color(current_colors)
    title.set_text(D[frame][:7])
    return scat, title

ani = FuncAnimation(fig, update, frames=len(X), interval=100, blit=True)

ani.save("scatter_plot_animation.gif", writer='pillow')

update(len(X) - 1)
fig.savefig("scatter_plot.png", dpi=100)
```

